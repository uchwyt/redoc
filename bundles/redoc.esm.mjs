var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decorateClass = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
  for (var i = decorators.length - 1, decorator2; i >= 0; i--)
    if (decorator2 = decorators[i])
      result = (kind ? decorator2(target, key2, result) : decorator2(result)) || result;
  if (kind && result) __defProp(target, key2, result);
  return result;
};
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends3() {
      return module.exports = _extends3 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r in t2) ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends3.apply(null, arguments);
    }
    module.exports = _extends3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(t2, e) {
      return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
        return t3.__proto__ = e2, t3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t2, e);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inheritsLoose.js
var require_inheritsLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/inheritsLoose.js"(exports, module) {
    var setPrototypeOf2 = require_setPrototypeOf();
    function _inheritsLoose(t2, o) {
      t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, setPrototypeOf2(t2, o);
    }
    module.exports = _inheritsLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(t2) {
      return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t2);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeFunction.js
var require_isNativeFunction = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeFunction.js"(exports, module) {
    function _isNativeFunction(t2) {
      try {
        return -1 !== Function.toString.call(t2).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t2;
      }
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module) {
    function _isNativeReflectConstruct() {
      try {
        var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t3) {
      }
      return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS({
  "node_modules/@babel/runtime/helpers/construct.js"(exports, module) {
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    var setPrototypeOf2 = require_setPrototypeOf();
    function _construct(t2, e, r) {
      if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t2.bind.apply(t2, o))();
      return r && setPrototypeOf2(p, r.prototype), p;
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var require_wrapNativeSuper = __commonJS({
  "node_modules/@babel/runtime/helpers/wrapNativeSuper.js"(exports, module) {
    var getPrototypeOf2 = require_getPrototypeOf();
    var setPrototypeOf2 = require_setPrototypeOf();
    var isNativeFunction = require_isNativeFunction();
    var construct2 = require_construct();
    function _wrapNativeSuper(t2) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return module.exports = _wrapNativeSuper = function _wrapNativeSuper2(t3) {
        if (null === t3 || !isNativeFunction(t3)) return t3;
        if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t3)) return r.get(t3);
          r.set(t3, Wrapper3);
        }
        function Wrapper3() {
          return construct2(t3, arguments, getPrototypeOf2(this).constructor);
        }
        return Wrapper3.prototype = Object.create(t3.prototype, {
          constructor: {
            value: Wrapper3,
            enumerable: false,
            writable: true,
            configurable: true
          }
        }), setPrototypeOf2(Wrapper3, t3);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t2);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/taggedTemplateLiteralLoose.js
var require_taggedTemplateLiteralLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/taggedTemplateLiteralLoose.js"(exports, module) {
    function _taggedTemplateLiteralLoose(e, t2) {
      return t2 || (t2 = e.slice(0)), e.raw = t2, e;
    }
    module.exports = _taggedTemplateLiteralLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/polished/dist/polished.cjs.js
var require_polished_cjs = __commonJS({
  "node_modules/polished/dist/polished.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends3 = require_extends();
    var _assertThisInitialized = require_assertThisInitialized();
    var _inheritsLoose = require_inheritsLoose();
    var _wrapNativeSuper = require_wrapNativeSuper();
    var _taggedTemplateLiteralLoose = require_taggedTemplateLiteralLoose();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _extends__default = /* @__PURE__ */ _interopDefaultLegacy(_extends3);
    var _assertThisInitialized__default = /* @__PURE__ */ _interopDefaultLegacy(_assertThisInitialized);
    var _inheritsLoose__default = /* @__PURE__ */ _interopDefaultLegacy(_inheritsLoose);
    var _wrapNativeSuper__default = /* @__PURE__ */ _interopDefaultLegacy(_wrapNativeSuper);
    var _taggedTemplateLiteralLoose__default = /* @__PURE__ */ _interopDefaultLegacy(_taggedTemplateLiteralLoose);
    function last() {
      var _ref;
      return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? void 0 : arguments[_ref];
    }
    function negation(a) {
      return -a;
    }
    function addition(a, b) {
      return a + b;
    }
    function subtraction(a, b) {
      return a - b;
    }
    function multiplication(a, b) {
      return a * b;
    }
    function division(a, b) {
      return a / b;
    }
    function max() {
      return Math.max.apply(Math, arguments);
    }
    function min() {
      return Math.min.apply(Math, arguments);
    }
    function comma() {
      return Array.of.apply(Array, arguments);
    }
    var defaultSymbols = {
      symbols: {
        "*": {
          infix: {
            symbol: "*",
            f: multiplication,
            notation: "infix",
            precedence: 4,
            rightToLeft: 0,
            argCount: 2
          },
          symbol: "*",
          regSymbol: "\\*"
        },
        "/": {
          infix: {
            symbol: "/",
            f: division,
            notation: "infix",
            precedence: 4,
            rightToLeft: 0,
            argCount: 2
          },
          symbol: "/",
          regSymbol: "/"
        },
        "+": {
          infix: {
            symbol: "+",
            f: addition,
            notation: "infix",
            precedence: 2,
            rightToLeft: 0,
            argCount: 2
          },
          prefix: {
            symbol: "+",
            f: last,
            notation: "prefix",
            precedence: 3,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "+",
          regSymbol: "\\+"
        },
        "-": {
          infix: {
            symbol: "-",
            f: subtraction,
            notation: "infix",
            precedence: 2,
            rightToLeft: 0,
            argCount: 2
          },
          prefix: {
            symbol: "-",
            f: negation,
            notation: "prefix",
            precedence: 3,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "-",
          regSymbol: "-"
        },
        ",": {
          infix: {
            symbol: ",",
            f: comma,
            notation: "infix",
            precedence: 1,
            rightToLeft: 0,
            argCount: 2
          },
          symbol: ",",
          regSymbol: ","
        },
        "(": {
          prefix: {
            symbol: "(",
            f: last,
            notation: "prefix",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "(",
          regSymbol: "\\("
        },
        ")": {
          postfix: {
            symbol: ")",
            f: void 0,
            notation: "postfix",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: ")",
          regSymbol: "\\)"
        },
        min: {
          func: {
            symbol: "min",
            f: min,
            notation: "func",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "min",
          regSymbol: "min\\b"
        },
        max: {
          func: {
            symbol: "max",
            f: max,
            notation: "func",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "max",
          regSymbol: "max\\b"
        }
      }
    };
    var defaultSymbolMap = defaultSymbols;
    var PolishedError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose__default["default"](PolishedError2, _Error);
      function PolishedError2(code) {
        var _this;
        if (true) {
          _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
        } else {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
        }
        return _assertThisInitialized__default["default"](_this);
      }
      return PolishedError2;
    }(/* @__PURE__ */ _wrapNativeSuper__default["default"](Error));
    var unitRegExp = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
    function mergeSymbolMaps(additionalSymbols) {
      var symbolMap = {};
      symbolMap.symbols = additionalSymbols ? _extends__default["default"]({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : _extends__default["default"]({}, defaultSymbolMap.symbols);
      return symbolMap;
    }
    function exec(operators, values) {
      var _ref;
      var op = operators.pop();
      values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));
      return op.precedence;
    }
    function calculate2(expression, additionalSymbols) {
      var symbolMap = mergeSymbolMaps(additionalSymbols);
      var match;
      var operators = [symbolMap.symbols["("].prefix];
      var values = [];
      var pattern = new RegExp(
        // Pattern for numbers
        "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
        Object.keys(symbolMap.symbols).map(function(key2) {
          return symbolMap.symbols[key2];
        }).sort(function(a, b) {
          return b.symbol.length - a.symbol.length;
        }).map(function(val) {
          return val.regSymbol;
        }).join("|") + "|(\\S)",
        "g"
      );
      pattern.lastIndex = 0;
      var afterValue = false;
      do {
        match = pattern.exec(expression);
        var _ref2 = match || [")", void 0], token = _ref2[0], bad = _ref2[1];
        var notNumber = symbolMap.symbols[token];
        var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;
        var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix;
        if (bad || (afterValue ? notAfterValue : notNewValue)) {
          throw new PolishedError(37, match ? match.index : expression.length, expression);
        }
        if (afterValue) {
          var curr = notNumber.postfix || notNumber.infix;
          do {
            var prev = operators[operators.length - 1];
            if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break;
          } while (exec(operators, values));
          afterValue = curr.notation === "postfix";
          if (curr.symbol !== ")") {
            operators.push(curr);
            if (afterValue) exec(operators, values);
          }
        } else if (notNumber) {
          operators.push(notNumber.prefix || notNumber.func);
          if (notNumber.func) {
            match = pattern.exec(expression);
            if (!match || match[0] !== "(") {
              throw new PolishedError(38, match ? match.index : expression.length, expression);
            }
          }
        } else {
          values.push(+token);
          afterValue = true;
        }
      } while (match && operators.length);
      if (operators.length) {
        throw new PolishedError(39, match ? match.index : expression.length, expression);
      } else if (match) {
        throw new PolishedError(40, match ? match.index : expression.length, expression);
      } else {
        return values.pop();
      }
    }
    function reverseString(str) {
      return str.split("").reverse().join("");
    }
    function math(formula, additionalSymbols) {
      var reversedFormula = reverseString(formula);
      var formulaMatch = reversedFormula.match(unitRegExp);
      if (formulaMatch && !formulaMatch.every(function(unit) {
        return unit === formulaMatch[0];
      })) {
        throw new PolishedError(41);
      }
      var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, ""));
      return "" + calculate2(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : "");
    }
    var cssVariableRegex = /--[\S]*/g;
    function cssVar(cssVariable, defaultValue) {
      if (!cssVariable || !cssVariable.match(cssVariableRegex)) {
        throw new PolishedError(73);
      }
      var variableValue;
      if (typeof document !== "undefined" && document.documentElement !== null) {
        variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);
      }
      if (variableValue) {
        return variableValue.trim();
      } else if (defaultValue) {
        return defaultValue;
      }
      throw new PolishedError(74);
    }
    function capitalizeString(string2) {
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    var positionMap$1 = ["Top", "Right", "Bottom", "Left"];
    function generateProperty(property, position2) {
      if (!property) return position2.toLowerCase();
      var splitProperty = property.split("-");
      if (splitProperty.length > 1) {
        splitProperty.splice(1, 0, position2);
        return splitProperty.reduce(function(acc, val) {
          return "" + acc + capitalizeString(val);
        });
      }
      var joinedProperty = property.replace(/([a-z])([A-Z])/g, "$1" + position2 + "$2");
      return property === joinedProperty ? "" + property + position2 : joinedProperty;
    }
    function generateStyles(property, valuesWithDefaults) {
      var styles = {};
      for (var i = 0; i < valuesWithDefaults.length; i += 1) {
        if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {
          styles[generateProperty(property, positionMap$1[i])] = valuesWithDefaults[i];
        }
      }
      return styles;
    }
    function directionalProperty(property) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }
      var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;
      var valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];
      return generateStyles(property, valuesWithDefaults);
    }
    function endsWith(string2, suffix) {
      return string2.substr(-suffix.length) === suffix;
    }
    var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
    function stripUnit(value) {
      if (typeof value !== "string") return value;
      var matchedValue = value.match(cssRegex$1);
      return matchedValue ? parseFloat(value) : value;
    }
    var pxtoFactory = function pxtoFactory2(to) {
      return function(pxval, base2) {
        if (base2 === void 0) {
          base2 = "16px";
        }
        var newPxval = pxval;
        var newBase = base2;
        if (typeof pxval === "string") {
          if (!endsWith(pxval, "px")) {
            throw new PolishedError(69, to, pxval);
          }
          newPxval = stripUnit(pxval);
        }
        if (typeof base2 === "string") {
          if (!endsWith(base2, "px")) {
            throw new PolishedError(70, to, base2);
          }
          newBase = stripUnit(base2);
        }
        if (typeof newPxval === "string") {
          throw new PolishedError(71, pxval, to);
        }
        if (typeof newBase === "string") {
          throw new PolishedError(72, base2, to);
        }
        return "" + newPxval / newBase + to;
      };
    };
    var pixelsto = pxtoFactory;
    var em = pixelsto("em");
    var em$1 = em;
    var cssRegex = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
    function getValueAndUnit(value) {
      if (typeof value !== "string") return [value, ""];
      var matchedValue = value.match(cssRegex);
      if (matchedValue) return [parseFloat(value), matchedValue[2]];
      return [value, void 0];
    }
    function important(styleBlock, rules) {
      if (typeof styleBlock !== "object" || styleBlock === null) {
        throw new PolishedError(75, typeof styleBlock);
      }
      var newStyleBlock = {};
      Object.keys(styleBlock).forEach(function(key2) {
        if (typeof styleBlock[key2] === "object" && styleBlock[key2] !== null) {
          newStyleBlock[key2] = important(styleBlock[key2], rules);
        } else if (!rules || rules && (rules === key2 || rules.indexOf(key2) >= 0)) {
          newStyleBlock[key2] = styleBlock[key2] + " !important";
        } else {
          newStyleBlock[key2] = styleBlock[key2];
        }
      });
      return newStyleBlock;
    }
    var ratioNames = {
      minorSecond: 1.067,
      majorSecond: 1.125,
      minorThird: 1.2,
      majorThird: 1.25,
      perfectFourth: 1.333,
      augFourth: 1.414,
      perfectFifth: 1.5,
      minorSixth: 1.6,
      goldenSection: 1.618,
      majorSixth: 1.667,
      minorSeventh: 1.778,
      majorSeventh: 1.875,
      octave: 2,
      majorTenth: 2.5,
      majorEleventh: 2.667,
      majorTwelfth: 3,
      doubleOctave: 4
    };
    function getRatio(ratioName) {
      return ratioNames[ratioName];
    }
    function modularScale(steps, base2, ratio) {
      if (base2 === void 0) {
        base2 = "1em";
      }
      if (ratio === void 0) {
        ratio = 1.333;
      }
      if (typeof steps !== "number") {
        throw new PolishedError(42);
      }
      if (typeof ratio === "string" && !ratioNames[ratio]) {
        throw new PolishedError(43);
      }
      var _ref = typeof base2 === "string" ? getValueAndUnit(base2) : [base2, ""], realBase = _ref[0], unit = _ref[1];
      var realRatio = typeof ratio === "string" ? getRatio(ratio) : ratio;
      if (typeof realBase === "string") {
        throw new PolishedError(44, base2);
      }
      return "" + realBase * Math.pow(realRatio, steps) + (unit || "");
    }
    var rem = pixelsto("rem");
    var rem$1 = rem;
    var defaultFontSize = 16;
    function convertBase(base2) {
      var deconstructedValue = getValueAndUnit(base2);
      if (deconstructedValue[1] === "px") {
        return parseFloat(base2);
      }
      if (deconstructedValue[1] === "%") {
        return parseFloat(base2) / 100 * defaultFontSize;
      }
      throw new PolishedError(78, deconstructedValue[1]);
    }
    function getBaseFromDoc() {
      if (typeof document !== "undefined" && document.documentElement !== null) {
        var rootFontSize = getComputedStyle(document.documentElement).fontSize;
        return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;
      }
      return defaultFontSize;
    }
    function remToPx(value, base2) {
      var deconstructedValue = getValueAndUnit(value);
      if (deconstructedValue[1] !== "rem" && deconstructedValue[1] !== "") {
        throw new PolishedError(77, deconstructedValue[1]);
      }
      var newBase = base2 ? convertBase(base2) : getBaseFromDoc();
      return deconstructedValue[0] * newBase + "px";
    }
    var functionsMap$3 = {
      back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
      circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
      cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
      expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
      quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
      quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
      quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
      sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)"
    };
    function easeIn(functionName) {
      return functionsMap$3[functionName.toLowerCase().trim()];
    }
    var functionsMap$2 = {
      back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
      circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
      cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
      expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
      quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
      quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
      quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
      sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
    };
    function easeInOut(functionName) {
      return functionsMap$2[functionName.toLowerCase().trim()];
    }
    var functionsMap$1 = {
      back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
      cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
      circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
      expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
      quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
      quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
      quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
      sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)"
    };
    function easeOut(functionName) {
      return functionsMap$1[functionName.toLowerCase().trim()];
    }
    function between(fromSize, toSize, minScreen, maxScreen) {
      if (minScreen === void 0) {
        minScreen = "320px";
      }
      if (maxScreen === void 0) {
        maxScreen = "1200px";
      }
      var _getValueAndUnit = getValueAndUnit(fromSize), unitlessFromSize = _getValueAndUnit[0], fromSizeUnit = _getValueAndUnit[1];
      var _getValueAndUnit2 = getValueAndUnit(toSize), unitlessToSize = _getValueAndUnit2[0], toSizeUnit = _getValueAndUnit2[1];
      var _getValueAndUnit3 = getValueAndUnit(minScreen), unitlessMinScreen = _getValueAndUnit3[0], minScreenUnit = _getValueAndUnit3[1];
      var _getValueAndUnit4 = getValueAndUnit(maxScreen), unitlessMaxScreen = _getValueAndUnit4[0], maxScreenUnit = _getValueAndUnit4[1];
      if (typeof unitlessMinScreen !== "number" || typeof unitlessMaxScreen !== "number" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {
        throw new PolishedError(47);
      }
      if (typeof unitlessFromSize !== "number" || typeof unitlessToSize !== "number" || fromSizeUnit !== toSizeUnit) {
        throw new PolishedError(48);
      }
      if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {
        throw new PolishedError(76);
      }
      var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);
      var base2 = unitlessToSize - slope * unitlessMaxScreen;
      return "calc(" + base2.toFixed(2) + (fromSizeUnit || "") + " + " + (100 * slope).toFixed(2) + "vw)";
    }
    function clearFix(parent) {
      var _ref;
      if (parent === void 0) {
        parent = "&";
      }
      var pseudoSelector = parent + "::after";
      return _ref = {}, _ref[pseudoSelector] = {
        clear: "both",
        content: '""',
        display: "table"
      }, _ref;
    }
    function cover(offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return {
        position: "absolute",
        top: offset,
        right: offset,
        bottom: offset,
        left: offset
      };
    }
    function ellipsis(width, lines) {
      if (lines === void 0) {
        lines = 1;
      }
      var styles = {
        display: "inline-block",
        maxWidth: width || "100%",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      };
      return lines > 1 ? _extends__default["default"]({}, styles, {
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: lines,
        display: "-webkit-box",
        whiteSpace: "normal"
      }) : styles;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function fluidRange(cssProp, minScreen, maxScreen) {
      if (minScreen === void 0) {
        minScreen = "320px";
      }
      if (maxScreen === void 0) {
        maxScreen = "1200px";
      }
      if (!Array.isArray(cssProp) && typeof cssProp !== "object" || cssProp === null) {
        throw new PolishedError(49);
      }
      if (Array.isArray(cssProp)) {
        var mediaQueries = {};
        var fallbacks = {};
        for (var _iterator = _createForOfIteratorHelperLoose(cssProp), _step; !(_step = _iterator()).done; ) {
          var _extends22, _extends32;
          var obj = _step.value;
          if (!obj.prop || !obj.fromSize || !obj.toSize) {
            throw new PolishedError(50);
          }
          fallbacks[obj.prop] = obj.fromSize;
          mediaQueries["@media (min-width: " + minScreen + ")"] = _extends__default["default"]({}, mediaQueries["@media (min-width: " + minScreen + ")"], (_extends22 = {}, _extends22[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends22));
          mediaQueries["@media (min-width: " + maxScreen + ")"] = _extends__default["default"]({}, mediaQueries["@media (min-width: " + maxScreen + ")"], (_extends32 = {}, _extends32[obj.prop] = obj.toSize, _extends32));
        }
        return _extends__default["default"]({}, fallbacks, mediaQueries);
      } else {
        var _ref, _ref2, _ref3;
        if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {
          throw new PolishedError(51);
        }
        return _ref3 = {}, _ref3[cssProp.prop] = cssProp.fromSize, _ref3["@media (min-width: " + minScreen + ")"] = (_ref = {}, _ref[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref), _ref3["@media (min-width: " + maxScreen + ")"] = (_ref2 = {}, _ref2[cssProp.prop] = cssProp.toSize, _ref2), _ref3;
      }
    }
    var dataURIRegex = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i;
    var formatHintMap = {
      woff: "woff",
      woff2: "woff2",
      ttf: "truetype",
      otf: "opentype",
      eot: "embedded-opentype",
      svg: "svg",
      svgz: "svg"
    };
    function generateFormatHint(format2, formatHint) {
      if (!formatHint) return "";
      return ' format("' + formatHintMap[format2] + '")';
    }
    function isDataURI(fontFilePath) {
      return !!fontFilePath.replace(/\s+/g, " ").match(dataURIRegex);
    }
    function generateFileReferences(fontFilePath, fileFormats, formatHint) {
      if (isDataURI(fontFilePath)) {
        return 'url("' + fontFilePath + '")' + generateFormatHint(fileFormats[0], formatHint);
      }
      var fileFontReferences = fileFormats.map(function(format2) {
        return 'url("' + fontFilePath + "." + format2 + '")' + generateFormatHint(format2, formatHint);
      });
      return fileFontReferences.join(", ");
    }
    function generateLocalReferences(localFonts) {
      var localFontReferences = localFonts.map(function(font) {
        return 'local("' + font + '")';
      });
      return localFontReferences.join(", ");
    }
    function generateSources(fontFilePath, localFonts, fileFormats, formatHint) {
      var fontReferences = [];
      if (localFonts) fontReferences.push(generateLocalReferences(localFonts));
      if (fontFilePath) {
        fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));
      }
      return fontReferences.join(", ");
    }
    function fontFace(_ref) {
      var fontFamily = _ref.fontFamily, fontFilePath = _ref.fontFilePath, fontStretch = _ref.fontStretch, fontStyle = _ref.fontStyle, fontVariant = _ref.fontVariant, fontWeight = _ref.fontWeight, _ref$fileFormats = _ref.fileFormats, fileFormats = _ref$fileFormats === void 0 ? ["eot", "woff2", "woff", "ttf", "svg"] : _ref$fileFormats, _ref$formatHint = _ref.formatHint, formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint, _ref$localFonts = _ref.localFonts, localFonts = _ref$localFonts === void 0 ? [fontFamily] : _ref$localFonts, unicodeRange = _ref.unicodeRange, fontDisplay = _ref.fontDisplay, fontVariationSettings = _ref.fontVariationSettings, fontFeatureSettings = _ref.fontFeatureSettings;
      if (!fontFamily) throw new PolishedError(55);
      if (!fontFilePath && !localFonts) {
        throw new PolishedError(52);
      }
      if (localFonts && !Array.isArray(localFonts)) {
        throw new PolishedError(53);
      }
      if (!Array.isArray(fileFormats)) {
        throw new PolishedError(54);
      }
      var fontFaceDeclaration = {
        "@font-face": {
          fontFamily,
          src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),
          unicodeRange,
          fontStretch,
          fontStyle,
          fontVariant,
          fontWeight,
          fontDisplay,
          fontVariationSettings,
          fontFeatureSettings
        }
      };
      return JSON.parse(JSON.stringify(fontFaceDeclaration));
    }
    function hideText() {
      return {
        textIndent: "101%",
        overflow: "hidden",
        whiteSpace: "nowrap"
      };
    }
    function hideVisually() {
      return {
        border: "0",
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        whiteSpace: "nowrap",
        width: "1px"
      };
    }
    function hiDPI(ratio) {
      if (ratio === void 0) {
        ratio = 1.3;
      }
      return "\n    @media only screen and (-webkit-min-device-pixel-ratio: " + ratio + "),\n    only screen and (min--moz-device-pixel-ratio: " + ratio + "),\n    only screen and (-o-min-device-pixel-ratio: " + ratio + "/1),\n    only screen and (min-resolution: " + Math.round(ratio * 96) + "dpi),\n    only screen and (min-resolution: " + ratio + "dppx)\n  ";
    }
    function constructGradientValue(literals) {
      var template2 = "";
      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        substitutions[_key - 1] = arguments[_key];
      }
      for (var i = 0; i < literals.length; i += 1) {
        template2 += literals[i];
        if (i === substitutions.length - 1 && substitutions[i]) {
          var definedValues = substitutions.filter(function(substitute) {
            return !!substitute;
          });
          if (definedValues.length > 1) {
            template2 = template2.slice(0, -1);
            template2 += ", " + substitutions[i];
          } else if (definedValues.length === 1) {
            template2 += "" + substitutions[i];
          }
        } else if (substitutions[i]) {
          template2 += substitutions[i] + " ";
        }
      }
      return template2.trim();
    }
    var _templateObject$1;
    function linearGradient(_ref) {
      var colorStops = _ref.colorStops, fallback = _ref.fallback, _ref$toDirection = _ref.toDirection, toDirection = _ref$toDirection === void 0 ? "" : _ref$toDirection;
      if (!colorStops || colorStops.length < 2) {
        throw new PolishedError(56);
      }
      return {
        backgroundColor: fallback || colorStops[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "),
        backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose__default["default"](["linear-gradient(", "", ")"])), toDirection, colorStops.join(", ").replace(/,(?=\S)/g, ", "))
      };
    }
    function normalize() {
      var _ref;
      return [(_ref = {
        html: {
          lineHeight: "1.15",
          textSizeAdjust: "100%"
        },
        body: {
          margin: "0"
        },
        main: {
          display: "block"
        },
        h1: {
          fontSize: "2em",
          margin: "0.67em 0"
        },
        hr: {
          boxSizing: "content-box",
          height: "0",
          overflow: "visible"
        },
        pre: {
          fontFamily: "monospace, monospace",
          fontSize: "1em"
        },
        a: {
          backgroundColor: "transparent"
        },
        "abbr[title]": {
          borderBottom: "none",
          textDecoration: "underline"
        }
      }, _ref["b,\n    strong"] = {
        fontWeight: "bolder"
      }, _ref["code,\n    kbd,\n    samp"] = {
        fontFamily: "monospace, monospace",
        fontSize: "1em"
      }, _ref.small = {
        fontSize: "80%"
      }, _ref["sub,\n    sup"] = {
        fontSize: "75%",
        lineHeight: "0",
        position: "relative",
        verticalAlign: "baseline"
      }, _ref.sub = {
        bottom: "-0.25em"
      }, _ref.sup = {
        top: "-0.5em"
      }, _ref.img = {
        borderStyle: "none"
      }, _ref["button,\n    input,\n    optgroup,\n    select,\n    textarea"] = {
        fontFamily: "inherit",
        fontSize: "100%",
        lineHeight: "1.15",
        margin: "0"
      }, _ref["button,\n    input"] = {
        overflow: "visible"
      }, _ref["button,\n    select"] = {
        textTransform: "none"
      }, _ref['button,\n    html [type="button"],\n    [type="reset"],\n    [type="submit"]'] = {
        WebkitAppearance: "button"
      }, _ref['button::-moz-focus-inner,\n    [type="button"]::-moz-focus-inner,\n    [type="reset"]::-moz-focus-inner,\n    [type="submit"]::-moz-focus-inner'] = {
        borderStyle: "none",
        padding: "0"
      }, _ref['button:-moz-focusring,\n    [type="button"]:-moz-focusring,\n    [type="reset"]:-moz-focusring,\n    [type="submit"]:-moz-focusring'] = {
        outline: "1px dotted ButtonText"
      }, _ref.fieldset = {
        padding: "0.35em 0.625em 0.75em"
      }, _ref.legend = {
        boxSizing: "border-box",
        color: "inherit",
        display: "table",
        maxWidth: "100%",
        padding: "0",
        whiteSpace: "normal"
      }, _ref.progress = {
        verticalAlign: "baseline"
      }, _ref.textarea = {
        overflow: "auto"
      }, _ref['[type="checkbox"],\n    [type="radio"]'] = {
        boxSizing: "border-box",
        padding: "0"
      }, _ref['[type="number"]::-webkit-inner-spin-button,\n    [type="number"]::-webkit-outer-spin-button'] = {
        height: "auto"
      }, _ref['[type="search"]'] = {
        WebkitAppearance: "textfield",
        outlineOffset: "-2px"
      }, _ref['[type="search"]::-webkit-search-decoration'] = {
        WebkitAppearance: "none"
      }, _ref["::-webkit-file-upload-button"] = {
        WebkitAppearance: "button",
        font: "inherit"
      }, _ref.details = {
        display: "block"
      }, _ref.summary = {
        display: "list-item"
      }, _ref.template = {
        display: "none"
      }, _ref["[hidden]"] = {
        display: "none"
      }, _ref), {
        "abbr[title]": {
          textDecoration: "underline dotted"
        }
      }];
    }
    var _templateObject;
    function radialGradient(_ref) {
      var colorStops = _ref.colorStops, _ref$extent = _ref.extent, extent = _ref$extent === void 0 ? "" : _ref$extent, fallback = _ref.fallback, _ref$position = _ref.position, position2 = _ref$position === void 0 ? "" : _ref$position, _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? "" : _ref$shape;
      if (!colorStops || colorStops.length < 2) {
        throw new PolishedError(57);
      }
      return {
        backgroundColor: fallback || colorStops[0].split(" ")[0],
        backgroundImage: constructGradientValue(_templateObject || (_templateObject = _taggedTemplateLiteralLoose__default["default"](["radial-gradient(", "", "", "", ")"])), position2, shape, extent, colorStops.join(", "))
      };
    }
    function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {
      var _ref;
      if (extension === void 0) {
        extension = "png";
      }
      if (retinaSuffix === void 0) {
        retinaSuffix = "_2x";
      }
      if (!filename) {
        throw new PolishedError(58);
      }
      var ext = extension.replace(/^\./, "");
      var rFilename = retinaFilename ? retinaFilename + "." + ext : "" + filename + retinaSuffix + "." + ext;
      return _ref = {
        backgroundImage: "url(" + filename + "." + ext + ")"
      }, _ref[hiDPI()] = _extends__default["default"]({
        backgroundImage: "url(" + rFilename + ")"
      }, backgroundSize ? {
        backgroundSize
      } : {}), _ref;
    }
    var functionsMap = {
      easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
      easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
      easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
      easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
      easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
      easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
      easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
      easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)",
      easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
      easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
      easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
      easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
      easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
      easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
      easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
      easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)",
      easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
      easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
      easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
      easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
      easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
      easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
      easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
      easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
    };
    function getTimingFunction(functionName) {
      return functionsMap[functionName];
    }
    function timingFunctions(timingFunction) {
      return getTimingFunction(timingFunction);
    }
    var getBorderWidth = function getBorderWidth2(pointingDirection, height, width) {
      var fullWidth = "" + width[0] + (width[1] || "");
      var halfWidth = "" + width[0] / 2 + (width[1] || "");
      var fullHeight = "" + height[0] + (height[1] || "");
      var halfHeight = "" + height[0] / 2 + (height[1] || "");
      switch (pointingDirection) {
        case "top":
          return "0 " + halfWidth + " " + fullHeight + " " + halfWidth;
        case "topLeft":
          return fullWidth + " " + fullHeight + " 0 0";
        case "left":
          return halfHeight + " " + fullWidth + " " + halfHeight + " 0";
        case "bottomLeft":
          return fullWidth + " 0 0 " + fullHeight;
        case "bottom":
          return fullHeight + " " + halfWidth + " 0 " + halfWidth;
        case "bottomRight":
          return "0 0 " + fullWidth + " " + fullHeight;
        case "right":
          return halfHeight + " 0 " + halfHeight + " " + fullWidth;
        case "topRight":
        default:
          return "0 " + fullWidth + " " + fullHeight + " 0";
      }
    };
    var getBorderColor = function getBorderColor2(pointingDirection, foregroundColor) {
      switch (pointingDirection) {
        case "top":
        case "bottomRight":
          return {
            borderBottomColor: foregroundColor
          };
        case "right":
        case "bottomLeft":
          return {
            borderLeftColor: foregroundColor
          };
        case "bottom":
        case "topLeft":
          return {
            borderTopColor: foregroundColor
          };
        case "left":
        case "topRight":
          return {
            borderRightColor: foregroundColor
          };
        default:
          throw new PolishedError(59);
      }
    };
    function triangle(_ref) {
      var pointingDirection = _ref.pointingDirection, height = _ref.height, width = _ref.width, foregroundColor = _ref.foregroundColor, _ref$backgroundColor = _ref.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? "transparent" : _ref$backgroundColor;
      var widthAndUnit = getValueAndUnit(width);
      var heightAndUnit = getValueAndUnit(height);
      if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {
        throw new PolishedError(60);
      }
      return _extends__default["default"]({
        width: "0",
        height: "0",
        borderColor: backgroundColor
      }, getBorderColor(pointingDirection, foregroundColor), {
        borderStyle: "solid",
        borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)
      });
    }
    function wordWrap(wrap) {
      if (wrap === void 0) {
        wrap = "break-word";
      }
      var wordBreak = wrap === "break-word" ? "break-all" : wrap;
      return {
        overflowWrap: wrap,
        wordWrap: wrap,
        wordBreak
      };
    }
    function colorToInt(color) {
      return Math.round(color * 255);
    }
    function convertToInt(red, green, blue) {
      return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
    }
    function hslToRgb(hue, saturation, lightness, convert) {
      if (convert === void 0) {
        convert = convertToInt;
      }
      if (saturation === 0) {
        return convert(lightness, lightness, lightness);
      }
      var huePrime = (hue % 360 + 360) % 360 / 60;
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      var red = 0;
      var green = 0;
      var blue = 0;
      if (huePrime >= 0 && huePrime < 1) {
        red = chroma;
        green = secondComponent;
      } else if (huePrime >= 1 && huePrime < 2) {
        red = secondComponent;
        green = chroma;
      } else if (huePrime >= 2 && huePrime < 3) {
        green = chroma;
        blue = secondComponent;
      } else if (huePrime >= 3 && huePrime < 4) {
        green = secondComponent;
        blue = chroma;
      } else if (huePrime >= 4 && huePrime < 5) {
        red = secondComponent;
        blue = chroma;
      } else if (huePrime >= 5 && huePrime < 6) {
        red = chroma;
        blue = secondComponent;
      }
      var lightnessModification = lightness - chroma / 2;
      var finalRed = red + lightnessModification;
      var finalGreen = green + lightnessModification;
      var finalBlue = blue + lightnessModification;
      return convert(finalRed, finalGreen, finalBlue);
    }
    var namedColorMap = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "639",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    function nameToHex(color) {
      if (typeof color !== "string") return color;
      var normalizedColorName = color.toLowerCase();
      return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
    }
    var hexRegex = /^#[a-fA-F0-9]{6}$/;
    var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
    var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
    var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
    var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
    var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
    var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
    var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
    function parseToRgb(color) {
      if (typeof color !== "string") {
        throw new PolishedError(3);
      }
      var normalizedColor = nameToHex(color);
      if (normalizedColor.match(hexRegex)) {
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
          green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
          blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
        };
      }
      if (normalizedColor.match(hexRgbaRegex)) {
        var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
          green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
          blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
          alpha
        };
      }
      if (normalizedColor.match(reducedHexRegex)) {
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
          green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
          blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
        };
      }
      if (normalizedColor.match(reducedRgbaHexRegex)) {
        var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
          green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
          blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
          alpha: _alpha
        };
      }
      var rgbMatched = rgbRegex.exec(normalizedColor);
      if (rgbMatched) {
        return {
          red: parseInt("" + rgbMatched[1], 10),
          green: parseInt("" + rgbMatched[2], 10),
          blue: parseInt("" + rgbMatched[3], 10)
        };
      }
      var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
      if (rgbaMatched) {
        return {
          red: parseInt("" + rgbaMatched[1], 10),
          green: parseInt("" + rgbaMatched[2], 10),
          blue: parseInt("" + rgbaMatched[3], 10),
          alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
        };
      }
      var hslMatched = hslRegex.exec(normalizedColor);
      if (hslMatched) {
        var hue = parseInt("" + hslMatched[1], 10);
        var saturation = parseInt("" + hslMatched[2], 10) / 100;
        var lightness = parseInt("" + hslMatched[3], 10) / 100;
        var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
        var hslRgbMatched = rgbRegex.exec(rgbColorString);
        if (!hslRgbMatched) {
          throw new PolishedError(4, normalizedColor, rgbColorString);
        }
        return {
          red: parseInt("" + hslRgbMatched[1], 10),
          green: parseInt("" + hslRgbMatched[2], 10),
          blue: parseInt("" + hslRgbMatched[3], 10)
        };
      }
      var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
      if (hslaMatched) {
        var _hue = parseInt("" + hslaMatched[1], 10);
        var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
        var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
        var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
        if (!_hslRgbMatched) {
          throw new PolishedError(4, normalizedColor, _rgbColorString);
        }
        return {
          red: parseInt("" + _hslRgbMatched[1], 10),
          green: parseInt("" + _hslRgbMatched[2], 10),
          blue: parseInt("" + _hslRgbMatched[3], 10),
          alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
        };
      }
      throw new PolishedError(5);
    }
    function rgbToHsl(color) {
      var red = color.red / 255;
      var green = color.green / 255;
      var blue = color.blue / 255;
      var max2 = Math.max(red, green, blue);
      var min2 = Math.min(red, green, blue);
      var lightness = (max2 + min2) / 2;
      if (max2 === min2) {
        if (color.alpha !== void 0) {
          return {
            hue: 0,
            saturation: 0,
            lightness,
            alpha: color.alpha
          };
        } else {
          return {
            hue: 0,
            saturation: 0,
            lightness
          };
        }
      }
      var hue;
      var delta = max2 - min2;
      var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
      switch (max2) {
        case red:
          hue = (green - blue) / delta + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / delta + 2;
          break;
        default:
          hue = (red - green) / delta + 4;
          break;
      }
      hue *= 60;
      if (color.alpha !== void 0) {
        return {
          hue,
          saturation,
          lightness,
          alpha: color.alpha
        };
      }
      return {
        hue,
        saturation,
        lightness
      };
    }
    function parseToHsl(color) {
      return rgbToHsl(parseToRgb(color));
    }
    var reduceHexValue = function reduceHexValue2(value) {
      if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
        return "#" + value[1] + value[3] + value[5];
      }
      return value;
    };
    var reduceHexValue$1 = reduceHexValue;
    function numberToHex(value) {
      var hex = value.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }
    function colorToHex(color) {
      return numberToHex(Math.round(color * 255));
    }
    function convertToHex(red, green, blue) {
      return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
    }
    function hslToHex(hue, saturation, lightness) {
      return hslToRgb(hue, saturation, lightness, convertToHex);
    }
    function hsl(value, saturation, lightness) {
      if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
        return hslToHex(value, saturation, lightness);
      } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
        return hslToHex(value.hue, value.saturation, value.lightness);
      }
      throw new PolishedError(1);
    }
    function hsla(value, saturation, lightness, alpha) {
      if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
        return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
      } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
        return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
      }
      throw new PolishedError(2);
    }
    function rgb(value, green, blue) {
      if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
        return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
      } else if (typeof value === "object" && green === void 0 && blue === void 0) {
        return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
      }
      throw new PolishedError(6);
    }
    function rgba(firstValue, secondValue, thirdValue, fourthValue) {
      if (typeof firstValue === "string" && typeof secondValue === "number") {
        var rgbValue = parseToRgb(firstValue);
        return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
      } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
      } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
      }
      throw new PolishedError(7);
    }
    var isRgb = function isRgb2(color) {
      return typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number" && (typeof color.alpha !== "number" || typeof color.alpha === "undefined");
    };
    var isRgba = function isRgba2(color) {
      return typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number" && typeof color.alpha === "number";
    };
    var isHsl = function isHsl2(color) {
      return typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number" && (typeof color.alpha !== "number" || typeof color.alpha === "undefined");
    };
    var isHsla = function isHsla2(color) {
      return typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number" && typeof color.alpha === "number";
    };
    function toColorString(color) {
      if (typeof color !== "object") throw new PolishedError(8);
      if (isRgba(color)) return rgba(color);
      if (isRgb(color)) return rgb(color);
      if (isHsla(color)) return hsla(color);
      if (isHsl(color)) return hsl(color);
      throw new PolishedError(8);
    }
    function curried(f, length, acc) {
      return function fn() {
        var combined = acc.concat(Array.prototype.slice.call(arguments));
        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
      };
    }
    function curry(f) {
      return curried(f, f.length, []);
    }
    function adjustHue(degree, color) {
      if (color === "transparent") return color;
      var hslColor = parseToHsl(color);
      return toColorString(_extends__default["default"]({}, hslColor, {
        hue: hslColor.hue + parseFloat(degree)
      }));
    }
    var curriedAdjustHue = curry(adjustHue);
    var curriedAdjustHue$1 = curriedAdjustHue;
    function complement(color) {
      if (color === "transparent") return color;
      var hslColor = parseToHsl(color);
      return toColorString(_extends__default["default"]({}, hslColor, {
        hue: (hslColor.hue + 180) % 360
      }));
    }
    function guard(lowerBoundary, upperBoundary, value) {
      return Math.max(lowerBoundary, Math.min(upperBoundary, value));
    }
    function darken7(amount, color) {
      if (color === "transparent") return color;
      var hslColor = parseToHsl(color);
      return toColorString(_extends__default["default"]({}, hslColor, {
        lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
      }));
    }
    var curriedDarken = curry(darken7);
    var curriedDarken$1 = curriedDarken;
    function desaturate2(amount, color) {
      if (color === "transparent") return color;
      var hslColor = parseToHsl(color);
      return toColorString(_extends__default["default"]({}, hslColor, {
        saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
      }));
    }
    var curriedDesaturate = curry(desaturate2);
    var curriedDesaturate$1 = curriedDesaturate;
    function getLuminance2(color) {
      if (color === "transparent") return 0;
      var rgbColor = parseToRgb(color);
      var _Object$keys$map = Object.keys(rgbColor).map(function(key2) {
        var channel = rgbColor[key2] / 255;
        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
      }), r = _Object$keys$map[0], g = _Object$keys$map[1], b = _Object$keys$map[2];
      return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));
    }
    function getContrast(color1, color2) {
      var luminance1 = getLuminance2(color1);
      var luminance2 = getLuminance2(color2);
      return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));
    }
    function grayscale(color) {
      if (color === "transparent") return color;
      return toColorString(_extends__default["default"]({}, parseToHsl(color), {
        saturation: 0
      }));
    }
    function hslToColorString(color) {
      if (typeof color === "object" && typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number") {
        if (color.alpha && typeof color.alpha === "number") {
          return hsla({
            hue: color.hue,
            saturation: color.saturation,
            lightness: color.lightness,
            alpha: color.alpha
          });
        }
        return hsl({
          hue: color.hue,
          saturation: color.saturation,
          lightness: color.lightness
        });
      }
      throw new PolishedError(45);
    }
    function invert(color) {
      if (color === "transparent") return color;
      var value = parseToRgb(color);
      return toColorString(_extends__default["default"]({}, value, {
        red: 255 - value.red,
        green: 255 - value.green,
        blue: 255 - value.blue
      }));
    }
    function lighten3(amount, color) {
      if (color === "transparent") return color;
      var hslColor = parseToHsl(color);
      return toColorString(_extends__default["default"]({}, hslColor, {
        lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
      }));
    }
    var curriedLighten = curry(lighten3);
    var curriedLighten$1 = curriedLighten;
    function meetsContrastGuidelines(color1, color2) {
      var contrastRatio = getContrast(color1, color2);
      return {
        AA: contrastRatio >= 4.5,
        AALarge: contrastRatio >= 3,
        AAA: contrastRatio >= 7,
        AAALarge: contrastRatio >= 4.5
      };
    }
    function mix(weight, color, otherColor) {
      if (color === "transparent") return otherColor;
      if (otherColor === "transparent") return color;
      if (weight === 0) return otherColor;
      var parsedColor1 = parseToRgb(color);
      var color1 = _extends__default["default"]({}, parsedColor1, {
        alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
      });
      var parsedColor2 = parseToRgb(otherColor);
      var color2 = _extends__default["default"]({}, parsedColor2, {
        alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
      });
      var alphaDelta = color1.alpha - color2.alpha;
      var x = parseFloat(weight) * 2 - 1;
      var y = x * alphaDelta === -1 ? x : x + alphaDelta;
      var z = 1 + x * alphaDelta;
      var weight1 = (y / z + 1) / 2;
      var weight2 = 1 - weight1;
      var mixedColor = {
        red: Math.floor(color1.red * weight1 + color2.red * weight2),
        green: Math.floor(color1.green * weight1 + color2.green * weight2),
        blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
        alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))
      };
      return rgba(mixedColor);
    }
    var curriedMix = curry(mix);
    var mix$1 = curriedMix;
    function opacify(amount, color) {
      if (color === "transparent") return color;
      var parsedColor = parseToRgb(color);
      var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
      var colorWithAlpha = _extends__default["default"]({}, parsedColor, {
        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
      });
      return rgba(colorWithAlpha);
    }
    var curriedOpacify = curry(opacify);
    var curriedOpacify$1 = curriedOpacify;
    var defaultReturnIfLightColor = "#000";
    var defaultReturnIfDarkColor = "#fff";
    function readableColor2(color, returnIfLightColor, returnIfDarkColor, strict) {
      if (returnIfLightColor === void 0) {
        returnIfLightColor = defaultReturnIfLightColor;
      }
      if (returnIfDarkColor === void 0) {
        returnIfDarkColor = defaultReturnIfDarkColor;
      }
      if (strict === void 0) {
        strict = true;
      }
      var isColorLight = getLuminance2(color) > 0.179;
      var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;
      if (!strict || getContrast(color, preferredReturnColor) >= 4.5) {
        return preferredReturnColor;
      }
      return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;
    }
    function rgbToColorString(color) {
      if (typeof color === "object" && typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number") {
        if (typeof color.alpha === "number") {
          return rgba({
            red: color.red,
            green: color.green,
            blue: color.blue,
            alpha: color.alpha
          });
        }
        return rgb({
          red: color.red,
          green: color.green,
          blue: color.blue
        });
      }
      throw new PolishedError(46);
    }
    function saturate(amount, color) {
      if (color === "transparent") return color;
      var hslColor = parseToHsl(color);
      return toColorString(_extends__default["default"]({}, hslColor, {
        saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
      }));
    }
    var curriedSaturate = curry(saturate);
    var curriedSaturate$1 = curriedSaturate;
    function setHue(hue, color) {
      if (color === "transparent") return color;
      return toColorString(_extends__default["default"]({}, parseToHsl(color), {
        hue: parseFloat(hue)
      }));
    }
    var curriedSetHue = curry(setHue);
    var curriedSetHue$1 = curriedSetHue;
    function setLightness(lightness, color) {
      if (color === "transparent") return color;
      return toColorString(_extends__default["default"]({}, parseToHsl(color), {
        lightness: parseFloat(lightness)
      }));
    }
    var curriedSetLightness = curry(setLightness);
    var curriedSetLightness$1 = curriedSetLightness;
    function setSaturation(saturation, color) {
      if (color === "transparent") return color;
      return toColorString(_extends__default["default"]({}, parseToHsl(color), {
        saturation: parseFloat(saturation)
      }));
    }
    var curriedSetSaturation = curry(setSaturation);
    var curriedSetSaturation$1 = curriedSetSaturation;
    function shade(percentage, color) {
      if (color === "transparent") return color;
      return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color);
    }
    var curriedShade = curry(shade);
    var curriedShade$1 = curriedShade;
    function tint(percentage, color) {
      if (color === "transparent") return color;
      return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color);
    }
    var curriedTint = curry(tint);
    var curriedTint$1 = curriedTint;
    function transparentize4(amount, color) {
      if (color === "transparent") return color;
      var parsedColor = parseToRgb(color);
      var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
      var colorWithAlpha = _extends__default["default"]({}, parsedColor, {
        alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
      });
      return rgba(colorWithAlpha);
    }
    var curriedTransparentize = curry(transparentize4);
    var curriedTransparentize$1 = curriedTransparentize;
    function animation() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var multiMode = Array.isArray(args[0]);
      if (!multiMode && args.length > 8) {
        throw new PolishedError(64);
      }
      var code = args.map(function(arg) {
        if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {
          throw new PolishedError(65);
        }
        if (Array.isArray(arg) && arg.length > 8) {
          throw new PolishedError(66);
        }
        return Array.isArray(arg) ? arg.join(" ") : arg;
      }).join(", ");
      return {
        animation: code
      };
    }
    function backgroundImages() {
      for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
        properties[_key] = arguments[_key];
      }
      return {
        backgroundImage: properties.join(", ")
      };
    }
    function backgrounds() {
      for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
        properties[_key] = arguments[_key];
      }
      return {
        background: properties.join(", ")
      };
    }
    var sideMap = ["top", "right", "bottom", "left"];
    function border(sideKeyword) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }
      if (typeof sideKeyword === "string" && sideMap.indexOf(sideKeyword) >= 0) {
        var _ref;
        return _ref = {}, _ref["border" + capitalizeString(sideKeyword) + "Width"] = values[0], _ref["border" + capitalizeString(sideKeyword) + "Style"] = values[1], _ref["border" + capitalizeString(sideKeyword) + "Color"] = values[2], _ref;
      } else {
        values.unshift(sideKeyword);
        return {
          borderWidth: values[0],
          borderStyle: values[1],
          borderColor: values[2]
        };
      }
    }
    function borderColor() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      return directionalProperty.apply(void 0, ["borderColor"].concat(values));
    }
    function borderRadius(side, radius) {
      var uppercaseSide = capitalizeString(side);
      if (!radius && radius !== 0) {
        throw new PolishedError(62);
      }
      if (uppercaseSide === "Top" || uppercaseSide === "Bottom") {
        var _ref;
        return _ref = {}, _ref["border" + uppercaseSide + "RightRadius"] = radius, _ref["border" + uppercaseSide + "LeftRadius"] = radius, _ref;
      }
      if (uppercaseSide === "Left" || uppercaseSide === "Right") {
        var _ref2;
        return _ref2 = {}, _ref2["borderTop" + uppercaseSide + "Radius"] = radius, _ref2["borderBottom" + uppercaseSide + "Radius"] = radius, _ref2;
      }
      throw new PolishedError(63);
    }
    function borderStyle() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      return directionalProperty.apply(void 0, ["borderStyle"].concat(values));
    }
    function borderWidth() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      return directionalProperty.apply(void 0, ["borderWidth"].concat(values));
    }
    function generateSelectors(template2, state) {
      var stateSuffix = state ? ":" + state : "";
      return template2(stateSuffix);
    }
    function statefulSelectors(states, template2, stateMap2) {
      if (!template2) throw new PolishedError(67);
      if (states.length === 0) return generateSelectors(template2, null);
      var selectors = [];
      for (var i = 0; i < states.length; i += 1) {
        if (stateMap2 && stateMap2.indexOf(states[i]) < 0) {
          throw new PolishedError(68);
        }
        selectors.push(generateSelectors(template2, states[i]));
      }
      selectors = selectors.join(",");
      return selectors;
    }
    var stateMap$1 = [void 0, null, "active", "focus", "hover"];
    function template$1(state) {
      return "button" + state + ',\n  input[type="button"]' + state + ',\n  input[type="reset"]' + state + ',\n  input[type="submit"]' + state;
    }
    function buttons() {
      for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
        states[_key] = arguments[_key];
      }
      return statefulSelectors(states, template$1, stateMap$1);
    }
    function margin() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      return directionalProperty.apply(void 0, ["margin"].concat(values));
    }
    function padding() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      return directionalProperty.apply(void 0, ["padding"].concat(values));
    }
    var positionMap = ["absolute", "fixed", "relative", "static", "sticky"];
    function position(firstValue) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }
      if (positionMap.indexOf(firstValue) >= 0 && firstValue) {
        return _extends__default["default"]({}, directionalProperty.apply(void 0, [""].concat(values)), {
          position: firstValue
        });
      } else {
        return directionalProperty.apply(void 0, ["", firstValue].concat(values));
      }
    }
    function size(height, width) {
      if (width === void 0) {
        width = height;
      }
      return {
        height,
        width
      };
    }
    var stateMap = [void 0, null, "active", "focus", "hover"];
    function template(state) {
      return 'input[type="color"]' + state + ',\n    input[type="date"]' + state + ',\n    input[type="datetime"]' + state + ',\n    input[type="datetime-local"]' + state + ',\n    input[type="email"]' + state + ',\n    input[type="month"]' + state + ',\n    input[type="number"]' + state + ',\n    input[type="password"]' + state + ',\n    input[type="search"]' + state + ',\n    input[type="tel"]' + state + ',\n    input[type="text"]' + state + ',\n    input[type="time"]' + state + ',\n    input[type="url"]' + state + ',\n    input[type="week"]' + state + ",\n    input:not([type])" + state + ",\n    textarea" + state;
    }
    function textInputs() {
      for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
        states[_key] = arguments[_key];
      }
      return statefulSelectors(states, template, stateMap);
    }
    function transitions() {
      for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
        properties[_key] = arguments[_key];
      }
      if (Array.isArray(properties[0]) && properties.length === 2) {
        var value = properties[1];
        if (typeof value !== "string") {
          throw new PolishedError(61);
        }
        var transitionsString = properties[0].map(function(property) {
          return property + " " + value;
        }).join(", ");
        return {
          transition: transitionsString
        };
      } else {
        return {
          transition: properties.join(", ")
        };
      }
    }
    exports.adjustHue = curriedAdjustHue$1;
    exports.animation = animation;
    exports.backgroundImages = backgroundImages;
    exports.backgrounds = backgrounds;
    exports.between = between;
    exports.border = border;
    exports.borderColor = borderColor;
    exports.borderRadius = borderRadius;
    exports.borderStyle = borderStyle;
    exports.borderWidth = borderWidth;
    exports.buttons = buttons;
    exports.clearFix = clearFix;
    exports.complement = complement;
    exports.cover = cover;
    exports.cssVar = cssVar;
    exports.darken = curriedDarken$1;
    exports.desaturate = curriedDesaturate$1;
    exports.directionalProperty = directionalProperty;
    exports.easeIn = easeIn;
    exports.easeInOut = easeInOut;
    exports.easeOut = easeOut;
    exports.ellipsis = ellipsis;
    exports.em = em$1;
    exports.fluidRange = fluidRange;
    exports.fontFace = fontFace;
    exports.getContrast = getContrast;
    exports.getLuminance = getLuminance2;
    exports.getValueAndUnit = getValueAndUnit;
    exports.grayscale = grayscale;
    exports.hiDPI = hiDPI;
    exports.hideText = hideText;
    exports.hideVisually = hideVisually;
    exports.hsl = hsl;
    exports.hslToColorString = hslToColorString;
    exports.hsla = hsla;
    exports.important = important;
    exports.invert = invert;
    exports.lighten = curriedLighten$1;
    exports.linearGradient = linearGradient;
    exports.margin = margin;
    exports.math = math;
    exports.meetsContrastGuidelines = meetsContrastGuidelines;
    exports.mix = mix$1;
    exports.modularScale = modularScale;
    exports.normalize = normalize;
    exports.opacify = curriedOpacify$1;
    exports.padding = padding;
    exports.parseToHsl = parseToHsl;
    exports.parseToRgb = parseToRgb;
    exports.position = position;
    exports.radialGradient = radialGradient;
    exports.readableColor = readableColor2;
    exports.rem = rem$1;
    exports.remToPx = remToPx;
    exports.retinaImage = retinaImage;
    exports.rgb = rgb;
    exports.rgbToColorString = rgbToColorString;
    exports.rgba = rgba;
    exports.saturate = curriedSaturate$1;
    exports.setHue = curriedSetHue$1;
    exports.setLightness = curriedSetLightness$1;
    exports.setSaturation = curriedSetSaturation$1;
    exports.shade = curriedShade$1;
    exports.size = size;
    exports.stripUnit = stripUnit;
    exports.textInputs = textInputs;
    exports.timingFunctions = timingFunctions;
    exports.tint = curriedTint$1;
    exports.toColorString = toColorString;
    exports.transitions = transitions;
    exports.transparentize = curriedTransparentize$1;
    exports.triangle = triangle;
    exports.wordWrap = wordWrap;
  }
});

// node_modules/slugify/slugify.js
var require_slugify = __commonJS({
  "node_modules/slugify/slugify.js"(exports, module) {
    (function(name2, root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
        module.exports["default"] = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root[name2] = factory();
      }
    })("slugify", exports, function() {
      var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","\xA2":"cent","\xA3":"pound","\xA4":"currency","\xA5":"yen","\xA9":"(c)","\xAA":"a","\xAE":"(r)","\xBA":"o","\xC0":"A","\xC1":"A","\xC2":"A","\xC3":"A","\xC4":"A","\xC5":"A","\xC6":"AE","\xC7":"C","\xC8":"E","\xC9":"E","\xCA":"E","\xCB":"E","\xCC":"I","\xCD":"I","\xCE":"I","\xCF":"I","\xD0":"D","\xD1":"N","\xD2":"O","\xD3":"O","\xD4":"O","\xD5":"O","\xD6":"O","\xD8":"O","\xD9":"U","\xDA":"U","\xDB":"U","\xDC":"U","\xDD":"Y","\xDE":"TH","\xDF":"ss","\xE0":"a","\xE1":"a","\xE2":"a","\xE3":"a","\xE4":"a","\xE5":"a","\xE6":"ae","\xE7":"c","\xE8":"e","\xE9":"e","\xEA":"e","\xEB":"e","\xEC":"i","\xED":"i","\xEE":"i","\xEF":"i","\xF0":"d","\xF1":"n","\xF2":"o","\xF3":"o","\xF4":"o","\xF5":"o","\xF6":"o","\xF8":"o","\xF9":"u","\xFA":"u","\xFB":"u","\xFC":"u","\xFD":"y","\xFE":"th","\xFF":"y","\u0100":"A","\u0101":"a","\u0102":"A","\u0103":"a","\u0104":"A","\u0105":"a","\u0106":"C","\u0107":"c","\u010C":"C","\u010D":"c","\u010E":"D","\u010F":"d","\u0110":"DJ","\u0111":"dj","\u0112":"E","\u0113":"e","\u0116":"E","\u0117":"e","\u0118":"e","\u0119":"e","\u011A":"E","\u011B":"e","\u011E":"G","\u011F":"g","\u0122":"G","\u0123":"g","\u0128":"I","\u0129":"i","\u012A":"i","\u012B":"i","\u012E":"I","\u012F":"i","\u0130":"I","\u0131":"i","\u0136":"k","\u0137":"k","\u013B":"L","\u013C":"l","\u013D":"L","\u013E":"l","\u0141":"L","\u0142":"l","\u0143":"N","\u0144":"n","\u0145":"N","\u0146":"n","\u0147":"N","\u0148":"n","\u014C":"O","\u014D":"o","\u0150":"O","\u0151":"o","\u0152":"OE","\u0153":"oe","\u0154":"R","\u0155":"r","\u0158":"R","\u0159":"r","\u015A":"S","\u015B":"s","\u015E":"S","\u015F":"s","\u0160":"S","\u0161":"s","\u0162":"T","\u0163":"t","\u0164":"T","\u0165":"t","\u0168":"U","\u0169":"u","\u016A":"u","\u016B":"u","\u016E":"U","\u016F":"u","\u0170":"U","\u0171":"u","\u0172":"U","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017A":"z","\u017B":"Z","\u017C":"z","\u017D":"Z","\u017E":"z","\u018F":"E","\u0192":"f","\u01A0":"O","\u01A1":"o","\u01AF":"U","\u01B0":"u","\u01C8":"LJ","\u01C9":"lj","\u01CB":"NJ","\u01CC":"nj","\u0218":"S","\u0219":"s","\u021A":"T","\u021B":"t","\u0259":"e","\u02DA":"o","\u0386":"A","\u0388":"E","\u0389":"H","\u038A":"I","\u038C":"O","\u038E":"Y","\u038F":"W","\u0390":"i","\u0391":"A","\u0392":"B","\u0393":"G","\u0394":"D","\u0395":"E","\u0396":"Z","\u0397":"H","\u0398":"8","\u0399":"I","\u039A":"K","\u039B":"L","\u039C":"M","\u039D":"N","\u039E":"3","\u039F":"O","\u03A0":"P","\u03A1":"R","\u03A3":"S","\u03A4":"T","\u03A5":"Y","\u03A6":"F","\u03A7":"X","\u03A8":"PS","\u03A9":"W","\u03AA":"I","\u03AB":"Y","\u03AC":"a","\u03AD":"e","\u03AE":"h","\u03AF":"i","\u03B0":"y","\u03B1":"a","\u03B2":"b","\u03B3":"g","\u03B4":"d","\u03B5":"e","\u03B6":"z","\u03B7":"h","\u03B8":"8","\u03B9":"i","\u03BA":"k","\u03BB":"l","\u03BC":"m","\u03BD":"n","\u03BE":"3","\u03BF":"o","\u03C0":"p","\u03C1":"r","\u03C2":"s","\u03C3":"s","\u03C4":"t","\u03C5":"y","\u03C6":"f","\u03C7":"x","\u03C8":"ps","\u03C9":"w","\u03CA":"i","\u03CB":"y","\u03CC":"o","\u03CD":"y","\u03CE":"w","\u0401":"Yo","\u0402":"DJ","\u0404":"Ye","\u0406":"I","\u0407":"Yi","\u0408":"J","\u0409":"LJ","\u040A":"NJ","\u040B":"C","\u040F":"DZ","\u0410":"A","\u0411":"B","\u0412":"V","\u0413":"G","\u0414":"D","\u0415":"E","\u0416":"Zh","\u0417":"Z","\u0418":"I","\u0419":"J","\u041A":"K","\u041B":"L","\u041C":"M","\u041D":"N","\u041E":"O","\u041F":"P","\u0420":"R","\u0421":"S","\u0422":"T","\u0423":"U","\u0424":"F","\u0425":"H","\u0426":"C","\u0427":"Ch","\u0428":"Sh","\u0429":"Sh","\u042A":"U","\u042B":"Y","\u042C":"","\u042D":"E","\u042E":"Yu","\u042F":"Ya","\u0430":"a","\u0431":"b","\u0432":"v","\u0433":"g","\u0434":"d","\u0435":"e","\u0436":"zh","\u0437":"z","\u0438":"i","\u0439":"j","\u043A":"k","\u043B":"l","\u043C":"m","\u043D":"n","\u043E":"o","\u043F":"p","\u0440":"r","\u0441":"s","\u0442":"t","\u0443":"u","\u0444":"f","\u0445":"h","\u0446":"c","\u0447":"ch","\u0448":"sh","\u0449":"sh","\u044A":"u","\u044B":"y","\u044C":"","\u044D":"e","\u044E":"yu","\u044F":"ya","\u0451":"yo","\u0452":"dj","\u0454":"ye","\u0456":"i","\u0457":"yi","\u0458":"j","\u0459":"lj","\u045A":"nj","\u045B":"c","\u045D":"u","\u045F":"dz","\u0490":"G","\u0491":"g","\u0492":"GH","\u0493":"gh","\u049A":"KH","\u049B":"kh","\u04A2":"NG","\u04A3":"ng","\u04AE":"UE","\u04AF":"ue","\u04B0":"U","\u04B1":"u","\u04BA":"H","\u04BB":"h","\u04D8":"AE","\u04D9":"ae","\u04E8":"OE","\u04E9":"oe","\u0E3F":"baht","\u10D0":"a","\u10D1":"b","\u10D2":"g","\u10D3":"d","\u10D4":"e","\u10D5":"v","\u10D6":"z","\u10D7":"t","\u10D8":"i","\u10D9":"k","\u10DA":"l","\u10DB":"m","\u10DC":"n","\u10DD":"o","\u10DE":"p","\u10DF":"zh","\u10E0":"r","\u10E1":"s","\u10E2":"t","\u10E3":"u","\u10E4":"f","\u10E5":"k","\u10E6":"gh","\u10E7":"q","\u10E8":"sh","\u10E9":"ch","\u10EA":"ts","\u10EB":"dz","\u10EC":"ts","\u10ED":"ch","\u10EE":"kh","\u10EF":"j","\u10F0":"h","\u1E80":"W","\u1E81":"w","\u1E82":"W","\u1E83":"w","\u1E84":"W","\u1E85":"w","\u1E9E":"SS","\u1EA0":"A","\u1EA1":"a","\u1EA2":"A","\u1EA3":"a","\u1EA4":"A","\u1EA5":"a","\u1EA6":"A","\u1EA7":"a","\u1EA8":"A","\u1EA9":"a","\u1EAA":"A","\u1EAB":"a","\u1EAC":"A","\u1EAD":"a","\u1EAE":"A","\u1EAF":"a","\u1EB0":"A","\u1EB1":"a","\u1EB2":"A","\u1EB3":"a","\u1EB4":"A","\u1EB5":"a","\u1EB6":"A","\u1EB7":"a","\u1EB8":"E","\u1EB9":"e","\u1EBA":"E","\u1EBB":"e","\u1EBC":"E","\u1EBD":"e","\u1EBE":"E","\u1EBF":"e","\u1EC0":"E","\u1EC1":"e","\u1EC2":"E","\u1EC3":"e","\u1EC4":"E","\u1EC5":"e","\u1EC6":"E","\u1EC7":"e","\u1EC8":"I","\u1EC9":"i","\u1ECA":"I","\u1ECB":"i","\u1ECC":"O","\u1ECD":"o","\u1ECE":"O","\u1ECF":"o","\u1ED0":"O","\u1ED1":"o","\u1ED2":"O","\u1ED3":"o","\u1ED4":"O","\u1ED5":"o","\u1ED6":"O","\u1ED7":"o","\u1ED8":"O","\u1ED9":"o","\u1EDA":"O","\u1EDB":"o","\u1EDC":"O","\u1EDD":"o","\u1EDE":"O","\u1EDF":"o","\u1EE0":"O","\u1EE1":"o","\u1EE2":"O","\u1EE3":"o","\u1EE4":"U","\u1EE5":"u","\u1EE6":"U","\u1EE7":"u","\u1EE8":"U","\u1EE9":"u","\u1EEA":"U","\u1EEB":"u","\u1EEC":"U","\u1EED":"u","\u1EEE":"U","\u1EEF":"u","\u1EF0":"U","\u1EF1":"u","\u1EF2":"Y","\u1EF3":"y","\u1EF4":"Y","\u1EF5":"y","\u1EF6":"Y","\u1EF7":"y","\u1EF8":"Y","\u1EF9":"y","\u2018":"'","\u2019":"'","\u201C":"\\"","\u201D":"\\"","\u2020":"+","\u2022":"*","\u2026":"...","\u20A0":"ecu","\u20A2":"cruzeiro","\u20A3":"french franc","\u20A4":"lira","\u20A5":"mill","\u20A6":"naira","\u20A7":"peseta","\u20A8":"rupee","\u20A9":"won","\u20AA":"new shequel","\u20AB":"dong","\u20AC":"euro","\u20AD":"kip","\u20AE":"tugrik","\u20AF":"drachma","\u20B0":"penny","\u20B1":"peso","\u20B2":"guarani","\u20B3":"austral","\u20B4":"hryvnia","\u20B5":"cedi","\u20B8":"kazakhstani tenge","\u20B9":"indian rupee","\u20BA":"turkish lira","\u20BD":"russian ruble","\u20BF":"bitcoin","\u2120":"sm","\u2122":"tm","\u2202":"d","\u2206":"delta","\u2211":"sum","\u221E":"infinity","\u2665":"love","\u5143":"yuan","\u5186":"yen","\uFDFC":"rial"}`);
      var locales = JSON.parse('{"de":{"\xC4":"AE","\xE4":"ae","\xD6":"OE","\xF6":"oe","\xDC":"UE","\xFC":"ue","%":"prozent","&":"und","|":"oder","\u2211":"summe","\u221E":"unendlich","\u2665":"liebe"},"vi":{"\u0110":"D","\u0111":"d"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","\xA2":"centime","\xA3":"livre","\xA4":"devise","\u20A3":"franc","\u2211":"somme","\u221E":"infini","\u2665":"amour"}}');
      function replace2(string2, options2) {
        if (typeof string2 !== "string") {
          throw new Error("slugify: string argument expected");
        }
        options2 = typeof options2 === "string" ? { replacement: options2 } : options2 || {};
        var locale = locales[options2.locale] || {};
        var replacement = options2.replacement === void 0 ? "-" : options2.replacement;
        var slug = string2.split("").reduce(function(result, ch) {
          return result + (locale[ch] || charMap[ch] || ch).replace(options2.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "").trim().replace(new RegExp("[\\s" + replacement + "]+", "g"), replacement);
        if (options2.lower) {
          slug = slug.toLowerCase();
        }
        if (options2.strict) {
          slug = slug.replace(new RegExp("[^a-zA-Z0-9" + replacement + "]", "g"), "").replace(new RegExp("[\\s" + replacement + "]+", "g"), replacement);
        }
        return slug;
      }
      replace2.extend = function(customMap) {
        for (var key2 in customMap) {
          charMap[key2] = customMap[key2];
        }
      };
      return replace2;
    });
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/factoryWithThrowingShims.js
var require_factoryWithThrowingShims = __commonJS({
  "node_modules/prop-types/factoryWithThrowingShims.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    module.exports = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      ;
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      ;
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (false) {
      ReactIs = null;
      throwOnDirectAccess = true;
      module.exports = null(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = require_factoryWithThrowingShims()();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@redocly/openapi-core/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/@redocly/openapi-core/node_modules/minimatch/lib/path.js"(exports, module) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand3(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand3(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand3(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand3(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand3(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand3(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/@redocly/openapi-core/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/@redocly/openapi-core/node_modules/minimatch/minimatch.js"(exports, module) {
    var minimatch = module.exports = (p, pattern, options2 = {}) => {
      assertValidPattern(pattern);
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options2).match(p);
    };
    module.exports = minimatch;
    var path = require_path();
    minimatch.sep = path.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand3 = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options2 = {}) => (p, i, list) => minimatch(p, pattern, options2);
    var ext = (a, b = {}) => {
      const t2 = {};
      Object.keys(a).forEach((k) => t2[k] = a[k]);
      Object.keys(b).forEach((k) => t2[k] = b[k]);
      return t2;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options2) => orig(p, pattern, ext(def, options2));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options2) {
          super(pattern, ext(def, options2));
        }
      };
      m.Minimatch.defaults = (options2) => orig.defaults(ext(def, options2)).Minimatch;
      m.filter = (pattern, options2) => orig.filter(pattern, ext(def, options2));
      m.defaults = (options2) => orig.defaults(ext(def, options2));
      m.makeRe = (pattern, options2) => orig.makeRe(pattern, ext(def, options2));
      m.braceExpand = (pattern, options2) => orig.braceExpand(pattern, ext(def, options2));
      m.match = (list, pattern, options2) => orig.match(list, pattern, ext(def, options2));
      return m;
    };
    minimatch.braceExpand = (pattern, options2) => braceExpand(pattern, options2);
    var braceExpand = (pattern, options2 = {}) => {
      assertValidPattern(pattern);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand3(pattern);
    };
    var MAX_PATTERN_LENGTH2 = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH2) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options2) => new Minimatch(pattern, options2 || {}).makeRe();
    minimatch.match = (list, pattern, options2 = {}) => {
      const mm = new Minimatch(pattern, options2);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options2) {
        assertValidPattern(pattern);
        if (!options2) options2 = {};
        this.options = options2;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options2.debug) this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options2 = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options2 = this.options;
        if (pattern === "**") {
          if (!options2.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "") return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options2.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1) c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options2.noext) clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t2 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t2 + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options2.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options2.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = options2.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate) re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) return false;
        if (this.empty) return f === "";
        if (f === "/" && partial) return true;
        const options2 = this.options;
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename) break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options2.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options2.flipNegate) return true;
            return !this.negate;
          }
        }
        if (options2.flipNegate) return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports, module) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject2(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence)) return sequence;
      else if (isNothing(sequence)) return [];
      return [sequence];
    }
    function extend(target, source) {
      var index2, length, key2, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
          key2 = sourceKeys[index2];
          target[key2] = source[key2];
        }
      }
      return target;
    }
    function repeat(string2, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string2;
      }
      return result;
    }
    function isNegativeZero(number2) {
      return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
    }
    module.exports.isNothing = isNothing;
    module.exports.isObject = isObject2;
    module.exports.toArray = toArray;
    module.exports.repeat = repeat;
    module.exports.isNegativeZero = isNegativeZero;
    module.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports, module) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark) return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports, module) {
    "use strict";
    var common = require_common();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string2, max) {
      return common.repeat(" ", max - string2.length) + string2;
    }
    function makeSnippet(mark, options2) {
      options2 = Object.create(options2 || null);
      if (!mark.buffer) return null;
      if (!options2.maxLength) options2.maxLength = 79;
      if (typeof options2.indent !== "number") options2.indent = 1;
      if (typeof options2.linesBefore !== "number") options2.linesBefore = 3;
      if (typeof options2.linesAfter !== "number") options2.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
      for (i = 1; i <= options2.linesBefore; i++) {
        if (foundLineNo - i < 0) break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common.repeat(" ", options2.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options2.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length) break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common.repeat(" ", options2.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports, module) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options2) {
      options2 = options2 || {};
      Object.keys(options2).forEach(function(name2) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
          throw new YAMLException('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options2;
      this.tag = tag;
      this.kind = options2["kind"] || null;
      this.resolve = options2["resolve"] || function() {
        return true;
      };
      this.construct = options2["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options2["instanceOf"] || null;
      this.predicate = options2["predicate"] || null;
      this.represent = options2["represent"] || null;
      this.representName = options2["representName"] || null;
      this.defaultStyle = options2["defaultStyle"] || null;
      this.multi = options2["multi"] || false;
      this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports, module) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name2) {
      var result = [];
      schema[name2].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index2, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
        arguments[index2].forEach(collectType);
      }
      return result;
    }
    function Schema2(definition) {
      return this.extend(definition);
    }
    Schema2.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema2.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module.exports = Schema2;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports, module) {
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports, module) {
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports, module) {
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports, module) {
    "use strict";
    var Schema2 = require_schema();
    module.exports = new Schema2({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports, module) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null) return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports, module) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null) return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean2(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean2,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports, module) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null) return false;
      var max = data.length, index2 = 0, hasDigits = false, ch;
      if (!max) return false;
      ch = data[index2];
      if (ch === "-" || ch === "+") {
        ch = data[++index2];
      }
      if (ch === "0") {
        if (index2 + 1 === max) return true;
        ch = data[++index2];
        if (ch === "b") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_") continue;
            if (ch !== "0" && ch !== "1") return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_") continue;
            if (!isHexCode(data.charCodeAt(index2))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_") continue;
            if (!isOctCode(data.charCodeAt(index2))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_") return false;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (!isDecCode(data.charCodeAt(index2))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_") return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0") return 0;
      if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports, module) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports, module) {
    "use strict";
    module.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports, module) {
    "use strict";
    module.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports, module) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null) throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-") delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports, module) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports, module) {
    "use strict";
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null) return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64) continue;
        if (code < 0) return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports, module) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null) return true;
      var objectKeys = [], index2, length, pair2, pairKey, pairHasKey, object = data;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair2 = object[index2];
        pairHasKey = false;
        if (_toString.call(pair2) !== "[object Object]") return false;
        for (pairKey in pair2) {
          if (_hasOwnProperty.call(pair2, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports, module) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null) return true;
      var index2, length, pair2, keys2, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair2 = object[index2];
        if (_toString.call(pair2) !== "[object Object]") return false;
        keys2 = Object.keys(pair2);
        if (keys2.length !== 1) return false;
        result[index2] = [keys2[0], pair2[keys2[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null) return [];
      var index2, length, pair2, keys2, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair2 = object[index2];
        keys2 = Object.keys(pair2);
        result[index2] = [keys2[0], pair2[keys2[0]]];
      }
      return result;
    }
    module.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports, module) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null) return true;
      var key2, object = data;
      for (key2 in object) {
        if (_hasOwnProperty.call(object, key2)) {
          if (object[key2] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports, module) {
    "use strict";
    module.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports, module) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options2) {
      this.input = input;
      this.filename = options2["filename"] || null;
      this.schema = options2["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options2["onWarning"] || null;
      this.legacy = options2["legacy"] || false;
      this.json = options2["json"] || false;
      this.listener = options2["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name2, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name2, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key2, index2, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
        key2 = sourceKeys[index2];
        if (!_hasOwnProperty.call(destination, key2)) {
          destination[key2] = source[key2];
          overridableKeys[key2] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index2, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
          if (Array.isArray(keyNode[index2])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
            keyNode[index2] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
            mergeMappings(state, _result, valueNode[index2], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33) return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38) return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options2) {
      input = String(input);
      options2 = options2 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options2);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options2) {
      if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options2);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
        iterator(documents[index2]);
      }
    }
    function load2(input, options2) {
      var documents = loadDocuments(input, options2);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module.exports.loadAll = loadAll;
    module.exports.load = load2;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports, module) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys2, index2, length, tag, style, type;
      if (map === null) return {};
      result = {};
      keys2 = Object.keys(map);
      for (index2 = 0, length = keys2.length; index2 < length; index2 += 1) {
        tag = keys2[index2];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string2, handle, length;
      string2 = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string2.length) + string2;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options2) {
      this.schema = options2["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options2["indent"] || 2);
      this.noArrayIndent = options2["noArrayIndent"] || false;
      this.skipInvalid = options2["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
      this.sortKeys = options2["sortKeys"] || false;
      this.lineWidth = options2["lineWidth"] || 80;
      this.noRefs = options2["noRefs"] || false;
      this.noCompatMode = options2["noCompatMode"] || false;
      this.condenseFlow = options2["condenseFlow"] || false;
      this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options2["forceQuotes"] || false;
      this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString2(string2, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
      while (position < length) {
        next = string2.indexOf("\n", position);
        if (next === -1) {
          line = string2.slice(position);
          position = length;
        } else {
          line = string2.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level2) {
      return "\n" + common.repeat(" ", state.indent * level2);
    }
    function testImplicitResolving(state, str) {
      var index2, length, type;
      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
        type = state.implicitTypes[index2];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt3(string2, pos) {
      var first = string2.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
        second = string2.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string2) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string2);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar2 = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt3(string2, 0)) && isPlainSafeLast(codePointAt3(string2, string2.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt3(string2, i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar2, inblock);
          prevChar2 = char;
        }
      } else {
        for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt3(string2, i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar2, inblock);
          prevChar2 = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string2)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string2)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string2, level2, iskey, inblock) {
      state.dump = function() {
        if (string2.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
          }
        }
        var indent = state.indent * Math.max(1, level2);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level2 >= state.flowLevel;
        function testAmbiguity(string3) {
          return testImplicitResolving(state, string3);
        }
        switch (chooseScalarStyle(
          string2,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string2;
          case STYLE_SINGLE:
            return "'" + string2.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString2(string2, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString2(foldString(string2, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string2, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string2, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
      var clip2 = string2[string2.length - 1] === "\n";
      var keep = clip2 && (string2[string2.length - 2] === "\n" || string2 === "\n");
      var chomp = keep ? "+" : clip2 ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string2) {
      return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
    }
    function foldString(string2, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string2.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string2.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string2.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string2)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ") return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string2) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt3(string2, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string2[i];
          if (char >= 65536) result += string2[i + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level2, object) {
      var _result = "", _tag = state.tag, index2, length, value;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        value = object[index2];
        if (state.replacer) {
          value = state.replacer.call(object, String(index2), value);
        }
        if (writeNode(state, level2, value, false, false) || typeof value === "undefined" && writeNode(state, level2, null, false, false)) {
          if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level2, object, compact) {
      var _result = "", _tag = state.tag, index2, length, value;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        value = object[index2];
        if (state.replacer) {
          value = state.replacer.call(object, String(index2), value);
        }
        if (writeNode(state, level2 + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level2 + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level2);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level2, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (_result !== "") pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level2, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level2, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level2, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level2);
        }
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level2 + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level2);
        }
        if (!writeNode(state, level2 + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType2(state, object, explicit) {
      var _result, typeList, index2, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
        type = typeList[index2];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level2, object, block2, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType2(state, object, false)) {
        detectType2(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block2;
      var tagStr;
      if (block2) {
        block2 = state.flowLevel < 0 || state.flowLevel > level2;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level2 > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block2 && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level2, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level2, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block2 && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level2 > 0) {
              writeBlockSequence(state, level2 - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level2, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level2, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level2, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid) return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index2, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index2]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index2, length;
      if (object !== null && typeof object === "object") {
        index2 = objects.indexOf(object);
        if (index2 !== -1) {
          if (duplicatesIndexes.indexOf(index2) === -1) {
            duplicatesIndexes.push(index2);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
              inspectNode(object[index2], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options2) {
      options2 = options2 || {};
      var state = new State(options2);
      if (!state.noRefs) getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
      return "";
    }
    module.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports, module) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module.exports.Type = require_type();
    module.exports.Schema = require_schema();
    module.exports.FAILSAFE_SCHEMA = require_failsafe();
    module.exports.JSON_SCHEMA = require_json();
    module.exports.CORE_SCHEMA = require_core();
    module.exports.DEFAULT_SCHEMA = require_default();
    module.exports.load = loader.load;
    module.exports.loadAll = loader.loadAll;
    module.exports.dump = dumper.dump;
    module.exports.YAMLException = require_exception();
    module.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module.exports.safeLoad = renamed("safeLoad", "load");
    module.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/@redocly/openapi-core/lib/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/js-yaml/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringifyYaml = exports.parseYaml = void 0;
    var js_yaml_1 = require_js_yaml();
    var DEFAULT_SCHEMA_WITHOUT_TIMESTAMP = js_yaml_1.JSON_SCHEMA.extend({
      implicit: [js_yaml_1.types.merge],
      explicit: [js_yaml_1.types.binary, js_yaml_1.types.omap, js_yaml_1.types.pairs, js_yaml_1.types.set]
    });
    var parseYaml = (str, opts2) => (0, js_yaml_1.load)(str, { schema: DEFAULT_SCHEMA_WITHOUT_TIMESTAMP, ...opts2 });
    exports.parseYaml = parseYaml;
    var stringifyYaml = (obj, opts2) => (0, js_yaml_1.dump)(obj, opts2);
    exports.stringifyYaml = stringifyYaml;
  }
});

// node_modules/@redocly/openapi-core/lib/env.js
var require_env = __commonJS({
  "node_modules/@redocly/openapi-core/lib/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.env = exports.isBrowser = void 0;
    exports.isBrowser = typeof window !== "undefined" || typeof process === "undefined" || (process == null ? void 0 : process.platform) === "browser";
    exports.env = exports.isBrowser ? {} : process.env || {};
  }
});

// node_modules/colorette/index.cjs
var require_colorette = __commonJS({
  "node_modules/colorette/index.cjs"(exports) {
    var tty = __require("tty");
    var env = process.env;
    var isDisabled = "NO_COLOR" in env;
    var isForced = "FORCE_COLOR" in env;
    var isWindows = process.platform === "win32";
    var isCompatibleTerminal = tty && tty.isatty(1) && env.TERM && env.TERM !== "dumb";
    var isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
    var enabled = !isDisabled && (isForced || isWindows || isCompatibleTerminal || isCI);
    var raw = (open, close, searchRegex, replaceValue) => (s) => enabled ? open + (~(s += "").indexOf(close, 4) ? s.replace(searchRegex, replaceValue) : s) + close : s;
    var init = (open, close) => {
      return raw(
        `\x1B[${open}m`,
        `\x1B[${close}m`,
        new RegExp(`\\x1b\\[${close}m`, "g"),
        `\x1B[${open}m`
      );
    };
    exports.options = Object.defineProperty({}, "enabled", {
      get: () => enabled,
      set: (value) => enabled = value
    });
    exports.reset = init(0, 0);
    exports.bold = raw("\x1B[1m", "\x1B[22m", /\x1b\[22m/g, "\x1B[22m\x1B[1m");
    exports.dim = raw("\x1B[2m", "\x1B[22m", /\x1b\[22m/g, "\x1B[22m\x1B[2m");
    exports.italic = init(3, 23);
    exports.underline = init(4, 24);
    exports.inverse = init(7, 27);
    exports.hidden = init(8, 28);
    exports.strikethrough = init(9, 29);
    exports.black = init(30, 39);
    exports.red = init(31, 39);
    exports.green = init(32, 39);
    exports.yellow = init(33, 39);
    exports.blue = init(34, 39);
    exports.magenta = init(35, 39);
    exports.cyan = init(36, 39);
    exports.white = init(37, 39);
    exports.gray = init(90, 39);
    exports.bgBlack = init(40, 49);
    exports.bgRed = init(41, 49);
    exports.bgGreen = init(42, 49);
    exports.bgYellow = init(43, 49);
    exports.bgBlue = init(44, 49);
    exports.bgMagenta = init(45, 49);
    exports.bgCyan = init(46, 49);
    exports.bgWhite = init(47, 49);
    exports.blackBright = init(90, 39);
    exports.redBright = init(91, 39);
    exports.greenBright = init(92, 39);
    exports.yellowBright = init(93, 39);
    exports.blueBright = init(94, 39);
    exports.magentaBright = init(95, 39);
    exports.cyanBright = init(96, 39);
    exports.whiteBright = init(97, 39);
    exports.bgBlackBright = init(100, 49);
    exports.bgRedBright = init(101, 49);
    exports.bgGreenBright = init(102, 49);
    exports.bgYellowBright = init(103, 49);
    exports.bgBlueBright = init(104, 49);
    exports.bgMagentaBright = init(105, 49);
    exports.bgCyanBright = init(106, 49);
    exports.bgWhiteBright = init(107, 49);
  }
});

// node_modules/@redocly/openapi-core/lib/logger.js
var require_logger = __commonJS({
  "node_modules/@redocly/openapi-core/lib/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = exports.colorize = exports.colorOptions = void 0;
    var colorette = require_colorette();
    var env_1 = require_env();
    var utils_1 = require_utils();
    exports.colorOptions = colorette.options;
    exports.colorize = new Proxy(colorette, {
      get(target, prop) {
        if (env_1.isBrowser) {
          return utils_1.identity;
        }
        return target[prop];
      }
    });
    var Logger = class {
      stderr(str) {
        return process.stderr.write(str);
      }
      info(str) {
        return env_1.isBrowser ? console.log(str) : this.stderr(str);
      }
      warn(str) {
        return env_1.isBrowser ? console.warn(str) : this.stderr(exports.colorize.yellow(str));
      }
      error(str) {
        return env_1.isBrowser ? console.error(str) : this.stderr(exports.colorize.red(str));
      }
    };
    exports.logger = new Logger();
  }
});

// node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.req = exports.json = exports.toBuffer = void 0;
    var http = __importStar(__require("http"));
    var https = __importStar(__require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports.toBuffer = toBuffer;
    async function json2(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports.json = json2;
    function req(url, opts2 = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https : http).request(url, opts2);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports.req = req;
  }
});

// node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent = void 0;
    var net = __importStar(__require("net"));
    var http = __importStar(__require("http"));
    var https_1 = __require("https");
    __exportStar(require_helpers(), exports);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http.Agent {
      constructor(opts2) {
        super(opts2);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options2) {
        if (options2) {
          if (typeof options2.secureEndpoint === "boolean") {
            return options2.secureEndpoint;
          }
          if (typeof options2.protocol === "string") {
            return options2.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name2) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name2]) {
          this.sockets[name2] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name2].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name2, socket) {
        if (!this.sockets[name2] || socket === null) {
          return;
        }
        const sockets = this.sockets[name2];
        const index2 = sockets.indexOf(socket);
        if (index2 !== -1) {
          sockets.splice(index2, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name2];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options2) {
        const secureEndpoint = typeof options2.secureEndpoint === "boolean" ? options2.secureEndpoint : this.isSecureEndpoint(options2);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options2);
        }
        return super.getName(options2);
      }
      createSocket(req, options2, cb) {
        const connectOpts = {
          ...options2,
          secureEndpoint: this.isSecureEndpoint(options2)
        };
        const name2 = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name2);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name2, fakeSocket);
          if (socket instanceof http.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options2, cb);
        }, (err) => {
          this.decrementSockets(name2, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        var _a2;
        return (_a2 = this[INTERNAL].defaultPort) != null ? _a2 : this.protocol === "https:" ? 443 : 80;
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        var _a2;
        return (_a2 = this[INTERNAL].protocol) != null ? _a2 : this.isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports.Agent = Agent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseProxyResponse = void 0;
    var debug_1 = __importDefault(__require("debug"));
    var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key2 = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key2];
            if (typeof current === "string") {
              headers[key2] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key2] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpsProxyAgent = void 0;
    var net = __importStar(__require("net"));
    var tls = __importStar(__require("tls"));
    var assert_1 = __importDefault(__require("assert"));
    var debug_1 = __importDefault(__require("debug"));
    var agent_base_1 = require_dist();
    var url_1 = __require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options2) => {
      if (options2.servername === void 0 && options2.host && !net.isIP(options2.host)) {
        return {
          ...options2,
          servername: options2.host
        };
      }
      return options2;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts2) {
        var _a2;
        super(opts2);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = (_a2 = opts2 == null ? void 0 : opts2.headers) != null ? _a2 : {};
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts2 ? omit(opts2, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts2) {
        const { proxy } = this;
        if (!opts2.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts2.host) ? `[${opts2.host}]` : opts2.host;
        let payload = `CONNECT ${host}:${opts2.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts2.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name2 of Object.keys(headers)) {
          payload += `${name2}: ${headers[name2]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts2.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts2), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys2) {
      const ret = {};
      let key2;
      for (key2 in obj) {
        if (!keys2.includes(key2)) {
          ret[key2] = obj[key2];
        }
      }
      return ret;
    }
  }
});

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module) {
    (function(root, pluralize) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root.pluralize = pluralize();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token) {
        if (word === token) return token;
        if (word === word.toLowerCase()) return token.toLowerCase();
        if (word === word.toUpperCase()) return token.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index2) {
          return args[index2] || "";
        });
      }
      function replace2(word, rule) {
        return word.replace(rule[0], function(match, index2) {
          var result = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word[index2 - 1], result);
          }
          return restoreCase(match, result);
        });
      }
      function sanitizeWord(token, word, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace2(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
          }
          return sanitizeWord(token, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) return true;
          if (replaceMap.hasOwnProperty(token)) return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      function pluralize(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word, "$0");
        pluralize.addSingularRule(word, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// node_modules/@redocly/openapi-core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@redocly/openapi-core/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignConfig = exports.stringifyYaml = exports.parseYaml = void 0;
    exports.pushStack = pushStack;
    exports.pluralize = pluralize;
    exports.popStack = popStack;
    exports.loadYaml = loadYaml;
    exports.isDefined = isDefined;
    exports.isPlainObject = isPlainObject;
    exports.isEmptyObject = isEmptyObject;
    exports.isNotEmptyObject = isNotEmptyObject;
    exports.isEmptyArray = isEmptyArray;
    exports.isNotEmptyArray = isNotEmptyArray;
    exports.readFileFromUrl = readFileFromUrl;
    exports.pickObjectProps = pickObjectProps;
    exports.omitObjectProps = omitObjectProps;
    exports.splitCamelCaseIntoWords = splitCamelCaseIntoWords;
    exports.validateMimeType = validateMimeType;
    exports.validateMimeTypeOAS3 = validateMimeTypeOAS3;
    exports.readFileAsStringSync = readFileAsStringSync;
    exports.yamlAndJsonSyncReader = yamlAndJsonSyncReader;
    exports.isPathParameter = isPathParameter;
    exports.slash = slash;
    exports.isString = isString;
    exports.isNotString = isNotString;
    exports.assignOnlyExistingConfig = assignOnlyExistingConfig;
    exports.getMatchingStatusCodeRange = getMatchingStatusCodeRange;
    exports.isCustomRuleId = isCustomRuleId;
    exports.doesYamlFileExist = doesYamlFileExist;
    exports.showWarningForDeprecatedField = showWarningForDeprecatedField;
    exports.showErrorForDeprecatedField = showErrorForDeprecatedField;
    exports.isTruthy = isTruthy;
    exports.identity = identity;
    exports.keysOf = keysOf;
    exports.pickDefined = pickDefined;
    exports.nextTick = nextTick;
    exports.pause = pause;
    exports.getProxyAgent = getProxyAgent;
    exports.dequal = dequal;
    var fs = __require("fs");
    var path_1 = __require("path");
    var minimatch = require_minimatch();
    var js_yaml_1 = require_js_yaml2();
    var env_1 = require_env();
    var logger_1 = require_logger();
    var https_proxy_agent_1 = require_dist2();
    var pluralizeOne = require_pluralize();
    var js_yaml_2 = require_js_yaml2();
    Object.defineProperty(exports, "parseYaml", { enumerable: true, get: function() {
      return js_yaml_2.parseYaml;
    } });
    Object.defineProperty(exports, "stringifyYaml", { enumerable: true, get: function() {
      return js_yaml_2.stringifyYaml;
    } });
    function pushStack(head, value) {
      return { prev: head, value };
    }
    function pluralize(sentence, count, inclusive) {
      return sentence.split(" ").map((word) => pluralizeOne(word, count, inclusive)).join(" ");
    }
    function popStack(head) {
      var _a2;
      return (_a2 = head == null ? void 0 : head.prev) != null ? _a2 : null;
    }
    async function loadYaml(filename) {
      const contents = await fs.promises.readFile(filename, "utf-8");
      return (0, js_yaml_1.parseYaml)(contents);
    }
    function isDefined(x) {
      return x !== void 0;
    }
    function isPlainObject(value) {
      return value !== null && typeof value === "object" && !Array.isArray(value);
    }
    function isEmptyObject(value) {
      return isPlainObject(value) && Object.keys(value).length === 0;
    }
    function isNotEmptyObject(obj) {
      return isPlainObject(obj) && !isEmptyObject(obj);
    }
    function isEmptyArray(value) {
      return Array.isArray(value) && value.length === 0;
    }
    function isNotEmptyArray(args) {
      return !!args && Array.isArray(args) && !!args.length;
    }
    async function readFileFromUrl(url, config3) {
      const headers = {};
      for (const header of config3.headers) {
        if (match(url, header.matches)) {
          headers[header.name] = header.envVariable !== void 0 ? env_1.env[header.envVariable] || "" : header.value;
        }
      }
      const req = await (config3.customFetch || fetch)(url, {
        headers
      });
      if (!req.ok) {
        throw new Error(`Failed to load ${url}: ${req.status} ${req.statusText}`);
      }
      return { body: await req.text(), mimeType: req.headers.get("content-type") };
    }
    function match(url, pattern) {
      if (!pattern.match(/^https?:\/\//)) {
        url = url.replace(/^https?:\/\//, "");
      }
      return minimatch(url, pattern);
    }
    function pickObjectProps(object, keys2) {
      return Object.fromEntries(keys2.filter((key2) => key2 in object).map((key2) => [key2, object[key2]]));
    }
    function omitObjectProps(object, keys2) {
      return Object.fromEntries(Object.entries(object).filter(([key2]) => !keys2.includes(key2)));
    }
    function splitCamelCaseIntoWords(str) {
      const camel = str.split(/(?:[-._])|([A-Z][a-z]+)/).filter(isTruthy).map((item) => item.toLocaleLowerCase());
      const caps = str.split(/([A-Z]{2,})/).filter((e) => e && e === e.toUpperCase()).map((item) => item.toLocaleLowerCase());
      return /* @__PURE__ */ new Set([...camel, ...caps]);
    }
    function validateMimeType({ type, value }, { report, location }, allowedValues) {
      const ruleType = type === "consumes" ? "request" : "response";
      if (!allowedValues)
        throw new Error(`Parameter "allowedValues" is not provided for "${ruleType}-mime-type" rule`);
      if (!value[type])
        return;
      for (const mime of value[type]) {
        if (!allowedValues.includes(mime)) {
          report({
            message: `Mime type "${mime}" is not allowed`,
            location: location.child(value[type].indexOf(mime)).key()
          });
        }
      }
    }
    function validateMimeTypeOAS3({ type, value }, { report, location }, allowedValues) {
      const ruleType = type === "consumes" ? "request" : "response";
      if (!allowedValues)
        throw new Error(`Parameter "allowedValues" is not provided for "${ruleType}-mime-type" rule`);
      if (!value.content)
        return;
      for (const mime of Object.keys(value.content)) {
        if (!allowedValues.includes(mime)) {
          report({
            message: `Mime type "${mime}" is not allowed`,
            location: location.child("content").child(mime).key()
          });
        }
      }
    }
    function readFileAsStringSync(filePath) {
      return fs.readFileSync(filePath, "utf-8");
    }
    function yamlAndJsonSyncReader(filePath) {
      const content2 = fs.readFileSync(filePath, "utf-8");
      return (0, js_yaml_1.parseYaml)(content2);
    }
    function isPathParameter(pathSegment) {
      return pathSegment.startsWith("{") && pathSegment.endsWith("}");
    }
    function slash(path) {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path);
      if (isExtendedLengthPath) {
        return path;
      }
      return path.replace(/\\/g, "/");
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isNotString(value) {
      return !isString(value);
    }
    var assignConfig = (target, obj) => {
      if (!obj)
        return;
      for (const k of Object.keys(obj)) {
        if (isPlainObject(target[k]) && typeof obj[k] === "string") {
          target[k].severity = obj[k];
        } else {
          target[k] = obj[k];
        }
      }
    };
    exports.assignConfig = assignConfig;
    function assignOnlyExistingConfig(target, obj) {
      if (!obj)
        return;
      for (const k of Object.keys(obj)) {
        if (!target.hasOwnProperty(k))
          continue;
        if (isPlainObject(target[k]) && typeof obj[k] === "string") {
          target[k].severity = obj[k];
        } else {
          target[k] = obj[k];
        }
      }
    }
    function getMatchingStatusCodeRange(code) {
      return `${code}`.replace(/^(\d)\d\d$/, (_, firstDigit) => `${firstDigit}XX`);
    }
    function isCustomRuleId(id) {
      return id.includes("/");
    }
    function doesYamlFileExist(filePath) {
      var _a2;
      return ((0, path_1.extname)(filePath) === ".yaml" || (0, path_1.extname)(filePath) === ".yml") && ((_a2 = fs == null ? void 0 : fs.hasOwnProperty) == null ? void 0 : _a2.call(fs, "existsSync")) && fs.existsSync(filePath);
    }
    function showWarningForDeprecatedField(deprecatedField, updatedField, updatedObject, link) {
      const readMoreText = link ? `Read more about this change: ${link}` : "";
      logger_1.logger.warn(`The '${logger_1.colorize.red(deprecatedField)}' field is deprecated. ${updatedField ? `Use ${logger_1.colorize.green(getUpdatedFieldName(updatedField, updatedObject))} instead. ` : ""}${readMoreText}
`);
    }
    function showErrorForDeprecatedField(deprecatedField, updatedField, updatedObject) {
      throw new Error(`Do not use '${deprecatedField}' field. ${updatedField ? `Use '${getUpdatedFieldName(updatedField, updatedObject)}' instead. ` : ""}
`);
    }
    function isTruthy(value) {
      return !!value;
    }
    function identity(value) {
      return value;
    }
    function keysOf(obj) {
      if (!obj)
        return [];
      return Object.keys(obj);
    }
    function pickDefined(obj) {
      if (!obj)
        return void 0;
      const res = {};
      for (const key2 in obj) {
        if (obj[key2] !== void 0) {
          res[key2] = obj[key2];
        }
      }
      return res;
    }
    function nextTick() {
      return new Promise((resolve) => {
        setTimeout(resolve);
      });
    }
    async function pause(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    function getUpdatedFieldName(updatedField, updatedObject) {
      return `${typeof updatedObject !== "undefined" ? `${updatedObject}.` : ""}${updatedField}`;
    }
    function getProxyAgent() {
      const proxy = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
      return proxy ? new https_proxy_agent_1.HttpsProxyAgent(proxy) : void 0;
    }
    function dequal(foo, bar) {
      let ctor, len;
      if (foo === bar)
        return true;
      if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date)
          return foo.getTime() === bar.getTime();
        if (ctor === RegExp)
          return foo.toString() === bar.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar.length) {
            while (len-- && dequal(foo[len], bar[len]))
              ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (Object.prototype.hasOwnProperty.call(foo, ctor) && ++len && !Object.prototype.hasOwnProperty.call(bar, ctor))
              return false;
            if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
              return false;
          }
          return Object.keys(bar).length === len;
        }
      }
      return foo !== foo && bar !== bar;
    }
  }
});

// node_modules/@redocly/openapi-core/lib/ref-utils.js
var require_ref_utils = __commonJS({
  "node_modules/@redocly/openapi-core/lib/ref-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Location = void 0;
    exports.joinPointer = joinPointer;
    exports.isRef = isRef;
    exports.isExternalValue = isExternalValue;
    exports.unescapePointer = unescapePointer;
    exports.escapePointer = escapePointer;
    exports.parseRef = parseRef;
    exports.parsePointer = parsePointer;
    exports.pointerBaseName = pointerBaseName;
    exports.refBaseName = refBaseName;
    exports.isAbsoluteUrl = isAbsoluteUrl2;
    exports.isMappingRef = isMappingRef;
    exports.isAnchor = isAnchor;
    var utils_1 = require_utils();
    function joinPointer(base2, key2) {
      if (base2 === "")
        base2 = "#/";
      return base2[base2.length - 1] === "/" ? base2 + key2 : base2 + "/" + key2;
    }
    function isRef(node) {
      return (0, utils_1.isPlainObject)(node) && typeof node.$ref === "string";
    }
    function isExternalValue(node) {
      return (0, utils_1.isPlainObject)(node) && typeof node.externalValue === "string";
    }
    var Location = class _Location {
      constructor(source, pointer) {
        this.source = source;
        this.pointer = pointer;
      }
      child(components) {
        return new _Location(this.source, joinPointer(this.pointer, (Array.isArray(components) ? components : [components]).map(escapePointer).join("/")));
      }
      key() {
        return { ...this, reportOnKey: true };
      }
      get absolutePointer() {
        return this.source.absoluteRef + (this.pointer === "#/" ? "" : this.pointer);
      }
    };
    exports.Location = Location;
    function unescapePointer(fragment) {
      return decodeURIComponent(fragment.replace(/~1/g, "/").replace(/~0/g, "~"));
    }
    function escapePointer(fragment) {
      if (typeof fragment === "number")
        return fragment;
      return fragment.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function parseRef(ref) {
      const [uri, pointer = ""] = ref.split("#/");
      return {
        uri: (uri.endsWith("#") ? uri.slice(0, -1) : uri) || null,
        pointer: parsePointer(pointer)
      };
    }
    function parsePointer(pointer) {
      return pointer.split("/").map(unescapePointer).filter(utils_1.isTruthy);
    }
    function pointerBaseName(pointer) {
      const parts = pointer.split("/");
      return parts[parts.length - 1];
    }
    function refBaseName(ref) {
      const parts = ref.split(/[\/\\]/);
      return parts[parts.length - 1].replace(/\.[^.]+$/, "");
    }
    function isAbsoluteUrl2(ref) {
      return ref.startsWith("http://") || ref.startsWith("https://");
    }
    function isMappingRef(mapping) {
      return mapping.startsWith("#") || mapping.startsWith("https://") || mapping.startsWith("http://") || mapping.startsWith("./") || mapping.startsWith("../") || mapping.indexOf("/") > -1;
    }
    function isAnchor(ref) {
      return /^#[A-Za-z][A-Za-z0-9\-_:.]*$/.test(ref);
    }
  }
});

// node_modules/@redocly/openapi-core/lib/types/index.js
var require_types = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpecExtension = void 0;
    exports.listOf = listOf;
    exports.mapOf = mapOf;
    exports.normalizeTypes = normalizeTypes;
    exports.isNamedType = isNamedType;
    function listOf(typeName2) {
      return {
        name: `${typeName2}List`,
        properties: {},
        items: typeName2
      };
    }
    function mapOf(typeName2) {
      return {
        name: `${typeName2}Map`,
        properties: {},
        additionalProperties: () => typeName2
      };
    }
    exports.SpecExtension = {
      name: "SpecExtension",
      properties: {},
      // skip validation of additional properties for unknown extensions
      additionalProperties: { resolvable: true }
    };
    function normalizeTypes(types2, options2 = {}) {
      const normalizedTypes = {};
      for (const typeName2 of Object.keys(types2)) {
        normalizedTypes[typeName2] = {
          ...types2[typeName2],
          name: typeName2
        };
      }
      for (const type of Object.values(normalizedTypes)) {
        normalizeType(type);
      }
      normalizedTypes["SpecExtension"] = exports.SpecExtension;
      return normalizedTypes;
      function normalizeType(type) {
        if (type.additionalProperties) {
          type.additionalProperties = resolveType(type.additionalProperties);
        }
        if (type.items) {
          type.items = resolveType(type.items);
        }
        if (type.properties) {
          const mappedProps = {};
          for (const [propName, prop] of Object.entries(type.properties)) {
            mappedProps[propName] = resolveType(prop);
            if (options2.doNotResolveExamples && prop && prop.isExample) {
              mappedProps[propName] = {
                ...prop,
                resolvable: false
              };
            }
          }
          type.properties = mappedProps;
        }
      }
      function resolveType(type) {
        if (typeof type === "string") {
          if (!normalizedTypes[type]) {
            throw new Error(`Unknown type name found: ${type}`);
          }
          return normalizedTypes[type];
        } else if (typeof type === "function") {
          return (value, key2) => {
            return resolveType(type(value, key2));
          };
        } else if (type && type.name) {
          type = { ...type };
          normalizeType(type);
          return type;
        } else if (type && type.directResolveAs) {
          return {
            ...type,
            directResolveAs: resolveType(type.directResolveAs)
          };
        } else {
          return type;
        }
      }
    }
    function isNamedType(t2) {
      return typeof (t2 == null ? void 0 : t2.name) === "string";
    }
  }
});

// node_modules/@redocly/openapi-core/lib/resolve.js
var require_resolve = __commonJS({
  "node_modules/@redocly/openapi-core/lib/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseResolver = exports.YamlParseError = exports.ResolveError = exports.Source = void 0;
    exports.makeRefId = makeRefId;
    exports.makeDocumentFromString = makeDocumentFromString;
    exports.resolveDocument = resolveDocument;
    var fs = __require("fs");
    var path = __require("path");
    var ref_utils_1 = require_ref_utils();
    var types_1 = require_types();
    var utils_1 = require_utils();
    var Source = class {
      constructor(absoluteRef, body, mimeType) {
        this.absoluteRef = absoluteRef;
        this.body = body;
        this.mimeType = mimeType;
      }
      // pass safeLoad as argument to separate it from browser bundle
      getAst(safeLoad) {
        var _a2;
        if (this._ast === void 0) {
          this._ast = (_a2 = safeLoad(this.body, { filename: this.absoluteRef })) != null ? _a2 : void 0;
          if (this._ast && this._ast.kind === 0 && // KIND.scalar = 0
          this._ast.value === "" && this._ast.startPosition !== 1) {
            this._ast.startPosition = 1;
            this._ast.endPosition = 1;
          }
        }
        return this._ast;
      }
      getLines() {
        if (this._lines === void 0) {
          this._lines = this.body.split(/\r\n|[\n\r]/g);
        }
        return this._lines;
      }
    };
    exports.Source = Source;
    var ResolveError = class _ResolveError extends Error {
      constructor(originalError) {
        super(originalError.message);
        this.originalError = originalError;
        Object.setPrototypeOf(this, _ResolveError.prototype);
      }
    };
    exports.ResolveError = ResolveError;
    var jsYamlErrorLineColRegexp = /\((\d+):(\d+)\)$/;
    var YamlParseError = class _YamlParseError extends Error {
      constructor(originalError, source) {
        super(originalError.message.split("\n")[0]);
        this.originalError = originalError;
        this.source = source;
        Object.setPrototypeOf(this, _YamlParseError.prototype);
        const [, line, col] = this.message.match(jsYamlErrorLineColRegexp) || [];
        this.line = parseInt(line, 10);
        this.col = parseInt(col, 10);
      }
    };
    exports.YamlParseError = YamlParseError;
    function makeRefId(absoluteRef, pointer) {
      return absoluteRef + "::" + pointer;
    }
    function makeDocumentFromString(sourceString, absoluteRef) {
      const source = new Source(absoluteRef, sourceString);
      try {
        return {
          source,
          parsed: (0, utils_1.parseYaml)(sourceString, { filename: absoluteRef })
        };
      } catch (e) {
        throw new YamlParseError(e, source);
      }
    }
    var BaseResolver = class {
      constructor(config3 = { http: { headers: [] } }) {
        this.config = config3;
        this.cache = /* @__PURE__ */ new Map();
      }
      getFiles() {
        return new Set(Array.from(this.cache.keys()));
      }
      resolveExternalRef(base2, ref) {
        if ((0, ref_utils_1.isAbsoluteUrl)(ref)) {
          return ref;
        }
        if (base2 && (0, ref_utils_1.isAbsoluteUrl)(base2)) {
          return new URL(ref, base2).href;
        }
        return path.resolve(base2 ? path.dirname(base2) : process.cwd(), ref);
      }
      async loadExternalRef(absoluteRef) {
        try {
          if ((0, ref_utils_1.isAbsoluteUrl)(absoluteRef)) {
            const { body, mimeType } = await (0, utils_1.readFileFromUrl)(absoluteRef, this.config.http);
            return new Source(absoluteRef, body, mimeType);
          } else {
            if (fs.lstatSync(absoluteRef).isDirectory()) {
              throw new Error(`Expected a file but received a folder at ${absoluteRef}.`);
            }
            const content2 = await fs.promises.readFile(absoluteRef, "utf-8");
            return new Source(absoluteRef, content2.replace(/\r\n/g, "\n"));
          }
        } catch (error) {
          error.message = error.message.replace(", lstat", "");
          throw new ResolveError(error);
        }
      }
      parseDocument(source, isRoot = false) {
        var _a2;
        const ext = source.absoluteRef.substr(source.absoluteRef.lastIndexOf("."));
        if (![".json", ".json", ".yml", ".yaml"].includes(ext) && !((_a2 = source.mimeType) == null ? void 0 : _a2.match(/(json|yaml|openapi)/)) && !isRoot) {
          return { source, parsed: source.body };
        }
        try {
          return {
            source,
            parsed: (0, utils_1.parseYaml)(source.body, { filename: source.absoluteRef })
          };
        } catch (e) {
          throw new YamlParseError(e, source);
        }
      }
      async resolveDocument(base2, ref, isRoot = false) {
        const absoluteRef = this.resolveExternalRef(base2, ref);
        const cachedDocument = this.cache.get(absoluteRef);
        if (cachedDocument) {
          return cachedDocument;
        }
        const doc2 = this.loadExternalRef(absoluteRef).then((source) => {
          return this.parseDocument(source, isRoot);
        });
        this.cache.set(absoluteRef, doc2);
        return doc2;
      }
    };
    exports.BaseResolver = BaseResolver;
    function pushRef2(head, node) {
      return {
        prev: head,
        node
      };
    }
    function hasRef(head, node) {
      while (head) {
        if (head.node === node) {
          return true;
        }
        head = head.prev;
      }
      return false;
    }
    var unknownType = { name: "unknown", properties: {} };
    var resolvableScalarType = { name: "scalar", properties: {} };
    async function resolveDocument(opts2) {
      const { rootDocument, externalRefResolver, rootType } = opts2;
      const resolvedRefMap = /* @__PURE__ */ new Map();
      const seenNodes = /* @__PURE__ */ new Set();
      const resolvePromises = [];
      resolveRefsInParallel(rootDocument.parsed, rootDocument, "#/", rootType);
      let resolved;
      do {
        resolved = await Promise.all(resolvePromises);
      } while (resolvePromises.length !== resolved.length);
      return resolvedRefMap;
      function resolveRefsInParallel(rootNode, rootNodeDocument, rootNodePointer, type) {
        const rootNodeDocAbsoluteRef = rootNodeDocument.source.absoluteRef;
        const anchorRefsMap = /* @__PURE__ */ new Map();
        walk(rootNode, type, rootNodeDocAbsoluteRef + rootNodePointer);
        function walk(node, type2, nodeAbsoluteRef) {
          if (typeof node !== "object" || node === null) {
            return;
          }
          const nodeId = `${type2.name}::${nodeAbsoluteRef}`;
          if (seenNodes.has(nodeId)) {
            return;
          }
          seenNodes.add(nodeId);
          const [_, anchor] = Object.entries(node).find(([key2]) => key2 === "$anchor") || [];
          if (anchor) {
            anchorRefsMap.set(`#${anchor}`, node);
          }
          if (Array.isArray(node)) {
            const itemsType = type2.items;
            if (itemsType === void 0 && type2 !== unknownType && type2 !== types_1.SpecExtension) {
              return;
            }
            const isTypeAFunction = typeof itemsType === "function";
            for (let i = 0; i < node.length; i++) {
              const itemType = isTypeAFunction ? itemsType(node[i], (0, ref_utils_1.joinPointer)(nodeAbsoluteRef, i)) : itemsType;
              if (itemType === void 0 && type2 !== unknownType && type2 !== types_1.SpecExtension) {
                continue;
              }
              walk(node[i], (0, types_1.isNamedType)(itemType) ? itemType : unknownType, (0, ref_utils_1.joinPointer)(nodeAbsoluteRef, i));
            }
            return;
          }
          for (const propName of Object.keys(node)) {
            let propValue = node[propName];
            let propType = type2.properties[propName];
            if (propType === void 0)
              propType = type2.additionalProperties;
            if (typeof propType === "function")
              propType = propType(propValue, propName);
            if (propType === void 0)
              propType = unknownType;
            if (type2.extensionsPrefix && propName.startsWith(type2.extensionsPrefix) && propType === unknownType) {
              propType = types_1.SpecExtension;
            }
            if (!(0, types_1.isNamedType)(propType) && (propType == null ? void 0 : propType.directResolveAs)) {
              propType = propType.directResolveAs;
              propValue = { $ref: propValue };
            }
            if (propType && propType.name === void 0 && propType.resolvable !== false) {
              propType = resolvableScalarType;
            }
            if (!(0, types_1.isNamedType)(propType) || typeof propValue !== "object") {
              continue;
            }
            walk(propValue, propType, (0, ref_utils_1.joinPointer)(nodeAbsoluteRef, (0, ref_utils_1.escapePointer)(propName)));
          }
          if ((0, ref_utils_1.isRef)(node)) {
            const promise = followRef(rootNodeDocument, node, {
              prev: null,
              node
            }).then((resolvedRef) => {
              if (resolvedRef.resolved) {
                resolveRefsInParallel(resolvedRef.node, resolvedRef.document, resolvedRef.nodePointer, type2);
              }
            });
            resolvePromises.push(promise);
          }
          if ((0, ref_utils_1.isExternalValue)(node)) {
            const promise = followRef(rootNodeDocument, { $ref: node.externalValue }, {
              prev: null,
              node
            }).then((resolvedRef) => {
              if (resolvedRef.resolved) {
                resolveRefsInParallel(resolvedRef.node, resolvedRef.document, resolvedRef.nodePointer, type2);
              }
            });
            resolvePromises.push(promise);
          }
        }
        async function followRef(document2, ref, refStack) {
          if (hasRef(refStack.prev, ref)) {
            throw new Error("Self-referencing circular pointer");
          }
          if ((0, ref_utils_1.isAnchor)(ref.$ref)) {
            await (0, utils_1.nextTick)();
            const resolvedRef2 = {
              resolved: true,
              isRemote: false,
              node: anchorRefsMap.get(ref.$ref),
              document: document2,
              nodePointer: ref.$ref
            };
            const refId2 = makeRefId(document2.source.absoluteRef, ref.$ref);
            resolvedRefMap.set(refId2, resolvedRef2);
            return resolvedRef2;
          }
          const { uri, pointer } = (0, ref_utils_1.parseRef)(ref.$ref);
          const isRemote = uri !== null;
          let targetDoc;
          try {
            targetDoc = isRemote ? await externalRefResolver.resolveDocument(document2.source.absoluteRef, uri) : document2;
          } catch (error) {
            const resolvedRef2 = {
              resolved: false,
              isRemote,
              document: void 0,
              error
            };
            const refId2 = makeRefId(document2.source.absoluteRef, ref.$ref);
            resolvedRefMap.set(refId2, resolvedRef2);
            return resolvedRef2;
          }
          let resolvedRef = {
            resolved: true,
            document: targetDoc,
            isRemote,
            node: document2.parsed,
            nodePointer: "#/"
          };
          let target = targetDoc.parsed;
          const segments = pointer;
          for (const segment of segments) {
            if (typeof target !== "object") {
              target = void 0;
              break;
            } else if (target[segment] !== void 0) {
              target = target[segment];
              resolvedRef.nodePointer = (0, ref_utils_1.joinPointer)(resolvedRef.nodePointer, (0, ref_utils_1.escapePointer)(segment));
            } else if ((0, ref_utils_1.isRef)(target)) {
              resolvedRef = await followRef(targetDoc, target, pushRef2(refStack, target));
              targetDoc = resolvedRef.document || targetDoc;
              if (typeof resolvedRef.node !== "object") {
                target = void 0;
                break;
              }
              target = resolvedRef.node[segment];
              resolvedRef.nodePointer = (0, ref_utils_1.joinPointer)(resolvedRef.nodePointer, (0, ref_utils_1.escapePointer)(segment));
            } else {
              target = void 0;
              break;
            }
          }
          resolvedRef.node = target;
          resolvedRef.document = targetDoc;
          const refId = makeRefId(document2.source.absoluteRef, ref.$ref);
          if (resolvedRef.document && (0, ref_utils_1.isRef)(target)) {
            resolvedRef = await followRef(resolvedRef.document, target, pushRef2(refStack, target));
          }
          resolvedRefMap.set(refId, resolvedRef);
          return { ...resolvedRef };
        }
      }
    }
  }
});

// node_modules/@redocly/openapi-core/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/@redocly/openapi-core/lib/visitors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeVisitors = normalizeVisitors;
    var types_1 = require_types();
    var legacyTypesMap = {
      Root: "DefinitionRoot",
      ServerVariablesMap: "ServerVariableMap",
      Paths: ["PathMap", "PathsMap"],
      CallbacksMap: "CallbackMap",
      MediaTypesMap: "MediaTypeMap",
      ExamplesMap: "ExampleMap",
      EncodingMap: "EncodingsMap",
      HeadersMap: "HeaderMap",
      LinksMap: "LinkMap",
      OAuth2Flows: "SecuritySchemeFlows",
      Responses: "ResponsesMap"
    };
    function normalizeVisitors(visitorsConfig, types2) {
      const normalizedVisitors = {};
      normalizedVisitors.any = {
        enter: [],
        leave: []
      };
      for (const typeName2 of Object.keys(types2)) {
        normalizedVisitors[typeName2] = {
          enter: [],
          leave: []
        };
      }
      normalizedVisitors.ref = {
        enter: [],
        leave: []
      };
      for (const { ruleId, severity, message, visitor } of visitorsConfig) {
        normalizeVisitorLevel({ ruleId, severity, message }, visitor, null);
      }
      for (const v of Object.keys(normalizedVisitors)) {
        normalizedVisitors[v].enter.sort((a, b) => b.depth - a.depth);
        normalizedVisitors[v].leave.sort((a, b) => a.depth - b.depth);
      }
      return normalizedVisitors;
      function addWeakNodes(ruleConf, from, to, parentContext, stack = []) {
        if (stack.includes(from))
          return;
        stack = [...stack, from];
        const possibleChildren = /* @__PURE__ */ new Set();
        for (const type of Object.values(from.properties)) {
          if (type === to) {
            addWeakFromStack(ruleConf, stack);
            continue;
          }
          if (typeof type === "object" && type !== null && type.name) {
            possibleChildren.add(type);
          }
        }
        if (from.additionalProperties && typeof from.additionalProperties !== "function") {
          if (from.additionalProperties === to) {
            addWeakFromStack(ruleConf, stack);
          } else if (from.additionalProperties.name !== void 0) {
            possibleChildren.add(from.additionalProperties);
          }
        }
        if (from.items && typeof from.items !== "function") {
          if (from.items === to) {
            addWeakFromStack(ruleConf, stack);
          } else if (from.items.name !== void 0) {
            possibleChildren.add(from.items);
          }
        }
        if (from.extensionsPrefix) {
          possibleChildren.add(types_1.SpecExtension);
        }
        for (const fromType of Array.from(possibleChildren.values())) {
          addWeakNodes(ruleConf, fromType, to, parentContext, stack);
        }
        function addWeakFromStack(ruleConf2, stack2) {
          for (const interType of stack2.slice(1)) {
            normalizedVisitors[interType.name] = normalizedVisitors[interType.name] || {
              enter: [],
              leave: []
            };
            normalizedVisitors[interType.name].enter.push({
              ...ruleConf2,
              visit: () => void 0,
              depth: 0,
              context: {
                isSkippedLevel: true,
                seen: /* @__PURE__ */ new Set(),
                parent: parentContext
              }
            });
          }
        }
      }
      function findLegacyVisitorNode(visitor, typeName2) {
        if (Array.isArray(typeName2)) {
          const name2 = typeName2.find((name3) => visitor[name3]) || void 0;
          return name2 && visitor[name2];
        }
        return visitor[typeName2];
      }
      function normalizeVisitorLevel(ruleConf, visitor, parentContext, depth = 0) {
        const visitorKeys = Object.keys(types2);
        if (depth === 0) {
          visitorKeys.push("any");
          visitorKeys.push("ref");
        } else {
          if (visitor.any) {
            throw new Error("any() is allowed only on top level");
          }
          if (visitor.ref) {
            throw new Error("ref() is allowed only on top level");
          }
        }
        for (const typeName2 of visitorKeys) {
          const typeVisitor = visitor[typeName2] || findLegacyVisitorNode(visitor, legacyTypesMap[typeName2]);
          const normalizedTypeVisitor = normalizedVisitors[typeName2];
          if (!typeVisitor)
            continue;
          let visitorEnter;
          let visitorLeave;
          let visitorSkip;
          const isObjectVisitor = typeof typeVisitor === "object";
          if (typeName2 === "ref" && isObjectVisitor && typeVisitor.skip) {
            throw new Error("ref() visitor does not support skip");
          }
          if (typeof typeVisitor === "function") {
            visitorEnter = typeVisitor;
          } else if (isObjectVisitor) {
            visitorEnter = typeVisitor.enter;
            visitorLeave = typeVisitor.leave;
            visitorSkip = typeVisitor.skip;
          }
          const context = {
            activatedOn: null,
            type: types2[typeName2],
            parent: parentContext,
            isSkippedLevel: false
          };
          if (typeof typeVisitor === "object") {
            normalizeVisitorLevel(ruleConf, typeVisitor, context, depth + 1);
          }
          if (parentContext) {
            addWeakNodes(ruleConf, parentContext.type, types2[typeName2], parentContext);
          }
          if (visitorEnter || isObjectVisitor) {
            if (visitorEnter && typeof visitorEnter !== "function") {
              throw new Error("DEV: should be function");
            }
            normalizedTypeVisitor.enter.push({
              ...ruleConf,
              visit: visitorEnter || (() => void 0),
              skip: visitorSkip,
              depth,
              context
            });
          }
          if (visitorLeave) {
            if (typeof visitorLeave !== "function") {
              throw new Error("DEV: should be function");
            }
            normalizedTypeVisitor.leave.push({
              ...ruleConf,
              visit: visitorLeave,
              depth,
              context
            });
          }
        }
      }
    }
  }
});

// node_modules/@redocly/openapi-core/lib/walk.js
var require_walk = __commonJS({
  "node_modules/@redocly/openapi-core/lib/walk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walkDocument = walkDocument;
    var ref_utils_1 = require_ref_utils();
    var utils_1 = require_utils();
    var resolve_1 = require_resolve();
    var types_1 = require_types();
    function collectParents(ctx) {
      var _a2;
      const parents = {};
      while (ctx.parent) {
        parents[ctx.parent.type.name] = (_a2 = ctx.parent.activatedOn) == null ? void 0 : _a2.value.node;
        ctx = ctx.parent;
      }
      return parents;
    }
    function collectParentsLocations(ctx) {
      var _a2, _b;
      const locations = {};
      while (ctx.parent) {
        if ((_a2 = ctx.parent.activatedOn) == null ? void 0 : _a2.value.location) {
          locations[ctx.parent.type.name] = (_b = ctx.parent.activatedOn) == null ? void 0 : _b.value.location;
        }
        ctx = ctx.parent;
      }
      return locations;
    }
    function walkDocument(opts2) {
      const { document: document2, rootType, normalizedVisitors, resolvedRefMap, ctx } = opts2;
      const seenNodesPerType = {};
      const ignoredNodes = /* @__PURE__ */ new Set();
      walkNode(document2.parsed, rootType, new ref_utils_1.Location(document2.source, "#/"), void 0, "");
      function walkNode(node, type, location, parent, key2) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const resolve = (ref, from = currentLocation.source.absoluteRef) => {
          if (!(0, ref_utils_1.isRef)(ref))
            return { location, node: ref };
          const refId = (0, resolve_1.makeRefId)(from, ref.$ref);
          const resolvedRef = resolvedRefMap.get(refId);
          if (!resolvedRef) {
            return {
              location: void 0,
              node: void 0
            };
          }
          const { resolved, node: node2, document: document3, nodePointer, error: error2 } = resolvedRef;
          const newLocation = resolved ? new ref_utils_1.Location(document3.source, nodePointer) : error2 instanceof resolve_1.YamlParseError ? new ref_utils_1.Location(error2.source, "") : void 0;
          return { location: newLocation, node: node2, error: error2 };
        };
        const rawLocation = location;
        let currentLocation = location;
        const { node: resolvedNode, location: resolvedLocation, error } = resolve(node);
        const enteredContexts = /* @__PURE__ */ new Set();
        if ((0, ref_utils_1.isRef)(node)) {
          const refEnterVisitors = normalizedVisitors.ref.enter;
          for (const { visit: visitor, ruleId, severity, message, context } of refEnterVisitors) {
            enteredContexts.add(context);
            const report = reportFn.bind(void 0, ruleId, severity, message);
            visitor(node, {
              report,
              resolve,
              rawNode: node,
              rawLocation,
              location,
              type,
              parent,
              key: key2,
              parentLocations: {},
              oasVersion: ctx.oasVersion,
              getVisitorData: getVisitorDataFn.bind(void 0, ruleId)
            }, { node: resolvedNode, location: resolvedLocation, error });
            if ((resolvedLocation == null ? void 0 : resolvedLocation.source.absoluteRef) && ctx.refTypes) {
              ctx.refTypes.set(resolvedLocation == null ? void 0 : resolvedLocation.source.absoluteRef, type);
            }
          }
        }
        if (resolvedNode !== void 0 && resolvedLocation && type.name !== "scalar") {
          currentLocation = resolvedLocation;
          const isNodeSeen = (_b = (_a2 = seenNodesPerType[type.name]) == null ? void 0 : _a2.has) == null ? void 0 : _b.call(_a2, resolvedNode);
          let visitedBySome = false;
          const anyEnterVisitors = normalizedVisitors.any.enter;
          const currentEnterVisitors = anyEnterVisitors.concat(((_c = normalizedVisitors[type.name]) == null ? void 0 : _c.enter) || []);
          const activatedContexts = [];
          for (const { context, visit, skip, ruleId, severity, message } of currentEnterVisitors) {
            if (ignoredNodes.has(`${currentLocation.absolutePointer}${currentLocation.pointer}`))
              break;
            if (context.isSkippedLevel) {
              if (context.parent.activatedOn && !context.parent.activatedOn.value.nextLevelTypeActivated && !context.seen.has(node)) {
                context.seen.add(node);
                visitedBySome = true;
                activatedContexts.push(context);
              }
            } else {
              if (context.parent && // if nested
              context.parent.activatedOn && ((_d = context.activatedOn) == null ? void 0 : _d.value.withParentNode) !== context.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)
              ((_e = context.parent.activatedOn.value.nextLevelTypeActivated) == null ? void 0 : _e.value) !== type || !context.parent && !isNodeSeen) {
                activatedContexts.push(context);
                const activatedOn = {
                  node: resolvedNode,
                  location: resolvedLocation,
                  nextLevelTypeActivated: null,
                  withParentNode: (_g = (_f = context.parent) == null ? void 0 : _f.activatedOn) == null ? void 0 : _g.value.node,
                  skipped: (_j = ((_i = (_h = context.parent) == null ? void 0 : _h.activatedOn) == null ? void 0 : _i.value.skipped) || (skip == null ? void 0 : skip(resolvedNode, key2, {
                    location,
                    rawLocation,
                    resolve,
                    rawNode: node
                  }))) != null ? _j : false
                };
                context.activatedOn = (0, utils_1.pushStack)(context.activatedOn, activatedOn);
                let ctx2 = context.parent;
                while (ctx2) {
                  ctx2.activatedOn.value.nextLevelTypeActivated = (0, utils_1.pushStack)(ctx2.activatedOn.value.nextLevelTypeActivated, type);
                  ctx2 = ctx2.parent;
                }
                if (!activatedOn.skipped) {
                  visitedBySome = true;
                  enteredContexts.add(context);
                  visitWithContext(visit, resolvedNode, node, context, ruleId, severity, message);
                }
              }
            }
          }
          if (visitedBySome || !isNodeSeen) {
            seenNodesPerType[type.name] = seenNodesPerType[type.name] || /* @__PURE__ */ new Set();
            seenNodesPerType[type.name].add(resolvedNode);
            if (Array.isArray(resolvedNode)) {
              const itemsType = type.items;
              if (itemsType !== void 0) {
                const isTypeAFunction = typeof itemsType === "function";
                for (let i = 0; i < resolvedNode.length; i++) {
                  const itemType = isTypeAFunction ? itemsType(resolvedNode[i], resolvedLocation.child([i]).absolutePointer) : itemsType;
                  if ((0, types_1.isNamedType)(itemType)) {
                    walkNode(resolvedNode[i], itemType, resolvedLocation.child([i]), resolvedNode, i);
                  }
                }
              }
            } else if (typeof resolvedNode === "object" && resolvedNode !== null) {
              const props = Object.keys(type.properties);
              if (type.additionalProperties) {
                props.push(...Object.keys(resolvedNode).filter((k) => !props.includes(k)));
              } else if (type.extensionsPrefix) {
                props.push(...Object.keys(resolvedNode).filter((k) => k.startsWith(type.extensionsPrefix)));
              }
              if ((0, ref_utils_1.isRef)(node)) {
                props.push(...Object.keys(node).filter((k) => k !== "$ref" && !props.includes(k)));
              }
              for (const propName of props) {
                let value = resolvedNode[propName];
                let loc = resolvedLocation;
                if (value === void 0) {
                  value = node[propName];
                  loc = location;
                }
                let propType = type.properties[propName];
                if (propType === void 0)
                  propType = type.additionalProperties;
                if (typeof propType === "function")
                  propType = propType(value, propName);
                if (propType === void 0 && type.extensionsPrefix && propName.startsWith(type.extensionsPrefix)) {
                  propType = types_1.SpecExtension;
                }
                if (!(0, types_1.isNamedType)(propType) && (propType == null ? void 0 : propType.directResolveAs)) {
                  propType = propType.directResolveAs;
                  value = { $ref: value };
                }
                if (propType && propType.name === void 0 && propType.resolvable !== false) {
                  propType = { name: "scalar", properties: {} };
                }
                if (!(0, types_1.isNamedType)(propType) || propType.name === "scalar" && !(0, ref_utils_1.isRef)(value)) {
                  continue;
                }
                walkNode(value, propType, loc.child([propName]), resolvedNode, propName);
              }
            }
          }
          const anyLeaveVisitors = normalizedVisitors.any.leave;
          const currentLeaveVisitors = (((_k = normalizedVisitors[type.name]) == null ? void 0 : _k.leave) || []).concat(anyLeaveVisitors);
          for (const context of activatedContexts.reverse()) {
            if (context.isSkippedLevel) {
              context.seen.delete(resolvedNode);
            } else {
              context.activatedOn = (0, utils_1.popStack)(context.activatedOn);
              if (context.parent) {
                let ctx2 = context.parent;
                while (ctx2) {
                  ctx2.activatedOn.value.nextLevelTypeActivated = (0, utils_1.popStack)(ctx2.activatedOn.value.nextLevelTypeActivated);
                  ctx2 = ctx2.parent;
                }
              }
            }
          }
          for (const { context, visit, ruleId, severity, message } of currentLeaveVisitors) {
            if (!context.isSkippedLevel && enteredContexts.has(context)) {
              visitWithContext(visit, resolvedNode, node, context, ruleId, severity, message);
            }
          }
        }
        currentLocation = location;
        if ((0, ref_utils_1.isRef)(node)) {
          const refLeaveVisitors = normalizedVisitors.ref.leave;
          for (const { visit: visitor, ruleId, severity, context, message } of refLeaveVisitors) {
            if (enteredContexts.has(context)) {
              const report = reportFn.bind(void 0, ruleId, severity, message);
              visitor(node, {
                report,
                resolve,
                rawNode: node,
                rawLocation,
                location,
                type,
                parent,
                key: key2,
                parentLocations: {},
                oasVersion: ctx.oasVersion,
                getVisitorData: getVisitorDataFn.bind(void 0, ruleId)
              }, { node: resolvedNode, location: resolvedLocation, error });
            }
          }
        }
        function visitWithContext(visit, resolvedNode2, node2, context, ruleId, severity, customMessage) {
          const report = reportFn.bind(void 0, ruleId, severity, customMessage);
          visit(resolvedNode2, {
            report,
            resolve,
            rawNode: node2,
            location: currentLocation,
            rawLocation,
            type,
            parent,
            key: key2,
            parentLocations: collectParentsLocations(context),
            oasVersion: ctx.oasVersion,
            ignoreNextVisitorsOnNode: () => {
              ignoredNodes.add(`${currentLocation.absolutePointer}${currentLocation.pointer}`);
            },
            getVisitorData: getVisitorDataFn.bind(void 0, ruleId)
          }, collectParents(context), context);
        }
        function reportFn(ruleId, severity, customMessage, opts3) {
          const normalizedLocation = opts3.location ? Array.isArray(opts3.location) ? opts3.location : [opts3.location] : [{ ...currentLocation, reportOnKey: false }];
          const location2 = normalizedLocation.map((l2) => ({
            ...currentLocation,
            reportOnKey: false,
            ...l2
          }));
          const ruleSeverity = opts3.forceSeverity || severity;
          if (ruleSeverity !== "off") {
            ctx.problems.push({
              ruleId: opts3.ruleId || ruleId,
              severity: ruleSeverity,
              ...opts3,
              message: customMessage ? customMessage.replace("{{message}}", opts3.message) : opts3.message,
              suggest: opts3.suggest || [],
              location: location2
            });
          }
        }
        function getVisitorDataFn(ruleId) {
          ctx.visitorsData[ruleId] = ctx.visitorsData[ruleId] || {};
          return ctx.visitorsData[ruleId];
        }
      }
    }
  }
});

// node_modules/@redocly/openapi-core/lib/types/oas2.js
var require_oas2 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/oas2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Oas2Types = void 0;
    var _1 = require_types();
    var responseCodeRegexp = /^[0-9][0-9Xx]{2}$/;
    var Root2 = {
      properties: {
        swagger: { type: "string" },
        info: "Info",
        host: { type: "string" },
        basePath: { type: "string" },
        schemes: { type: "array", items: { type: "string" } },
        consumes: { type: "array", items: { type: "string" } },
        produces: { type: "array", items: { type: "string" } },
        paths: "Paths",
        definitions: "NamedSchemas",
        parameters: "NamedParameters",
        responses: "NamedResponses",
        securityDefinitions: "NamedSecuritySchemes",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        "x-servers": "XServerList",
        "x-tagGroups": "TagGroups",
        "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
      },
      required: ["swagger", "paths", "info"],
      extensionsPrefix: "x-"
    };
    var Info = {
      properties: {
        title: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License",
        version: { type: "string" },
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    };
    var Logo = {
      properties: {
        url: { type: "string" },
        altText: { type: "string" },
        backgroundColor: { type: "string" },
        href: { type: "string" }
      },
      extensionsPrefix: "x-"
    };
    var Contact = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      },
      extensionsPrefix: "x-"
    };
    var License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    };
    var Paths = {
      properties: {},
      additionalProperties: (_value, key2) => key2.startsWith("/") ? "PathItem" : void 0
    };
    var PathItem = {
      properties: {
        $ref: { type: "string" },
        // TODO: verify special $ref handling for Path Item
        parameters: "ParameterList",
        get: "Operation",
        put: "Operation",
        post: "Operation",
        delete: "Operation",
        options: "Operation",
        head: "Operation",
        patch: "Operation"
      },
      extensionsPrefix: "x-"
    };
    var Operation2 = {
      properties: {
        tags: { type: "array", items: { type: "string" } },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        consumes: { type: "array", items: { type: "string" } },
        produces: { type: "array", items: { type: "string" } },
        parameters: "ParameterList",
        responses: "Responses",
        schemes: { type: "array", items: { type: "string" } },
        deprecated: { type: "boolean" },
        security: "SecurityRequirementList",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      required: ["responses"],
      extensionsPrefix: "x-"
    };
    var XCodeSample = {
      properties: {
        lang: { type: "string" },
        label: { type: "string" },
        source: { type: "string" }
      }
    };
    var XServer = {
      properties: {
        url: { type: "string" },
        description: { type: "string" }
      },
      required: ["url"]
    };
    var ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"],
      extensionsPrefix: "x-"
    };
    var Parameter = {
      properties: {
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "path", "formData", "body"] },
        description: { type: "string" },
        required: { type: "boolean" },
        schema: "Schema",
        type: { type: "string", enum: ["string", "number", "integer", "boolean", "array", "file"] },
        format: { type: "string" },
        allowEmptyValue: { type: "boolean" },
        items: "ParameterItems",
        collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
        default: null,
        maximum: { type: "integer" },
        exclusiveMaximum: { type: "boolean" },
        minimum: { type: "integer" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer" },
        minLength: { type: "integer" },
        pattern: { type: "string" },
        maxItems: { type: "integer" },
        minItems: { type: "integer" },
        uniqueItems: { type: "boolean" },
        enum: { type: "array" },
        multipleOf: { type: "number" },
        "x-example": {},
        // any
        "x-examples": "ExamplesMap"
      },
      required(value) {
        if (!value || !value.in) {
          return ["name", "in"];
        }
        if (value.in === "body") {
          return ["name", "in", "schema"];
        } else {
          if (value.type === "array") {
            return ["name", "in", "type", "items"];
          } else {
            return ["name", "in", "type"];
          }
        }
      },
      extensionsPrefix: "x-"
    };
    var ParameterItems = {
      properties: {
        type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
        format: { type: "string" },
        items: "ParameterItems",
        collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
        default: null,
        maximum: { type: "integer" },
        exclusiveMaximum: { type: "boolean" },
        minimum: { type: "integer" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer" },
        minLength: { type: "integer" },
        pattern: { type: "string" },
        maxItems: { type: "integer" },
        minItems: { type: "integer" },
        uniqueItems: { type: "boolean" },
        enum: { type: "array" },
        multipleOf: { type: "number" }
      },
      required(value) {
        if (value && value.type === "array") {
          return ["type", "items"];
        } else {
          return ["type"];
        }
      },
      extensionsPrefix: "x-"
    };
    var Responses = {
      properties: {
        default: "Response"
      },
      additionalProperties: (_v, key2) => responseCodeRegexp.test(key2) ? "Response" : void 0
    };
    var Response = {
      properties: {
        description: { type: "string" },
        schema: "Schema",
        headers: (0, _1.mapOf)("Header"),
        examples: "Examples",
        "x-summary": { type: "string" }
      },
      required: ["description"],
      extensionsPrefix: "x-"
    };
    var Examples2 = {
      properties: {},
      additionalProperties: { isExample: true }
    };
    var Header3 = {
      properties: {
        description: { type: "string" },
        type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
        format: { type: "string" },
        items: "ParameterItems",
        collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
        default: null,
        maximum: { type: "integer" },
        exclusiveMaximum: { type: "boolean" },
        minimum: { type: "integer" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer" },
        minLength: { type: "integer" },
        pattern: { type: "string" },
        maxItems: { type: "integer" },
        minItems: { type: "integer" },
        uniqueItems: { type: "boolean" },
        enum: { type: "array" },
        multipleOf: { type: "number" }
      },
      required(value) {
        if (value && value.type === "array") {
          return ["type", "items"];
        } else {
          return ["type"];
        }
      },
      extensionsPrefix: "x-"
    };
    var Tag2 = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        "x-traitTag": { type: "boolean" },
        "x-displayName": { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    };
    var TagGroup = {
      properties: {
        name: { type: "string" },
        tags: { type: "array", items: { type: "string" } }
      }
    };
    var Schema2 = {
      properties: {
        format: { type: "string" },
        title: { type: "string" },
        description: { type: "string" },
        default: null,
        multipleOf: { type: "number" },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "boolean" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "number" },
        minLength: { type: "number" },
        pattern: { type: "string" },
        maxItems: { type: "number" },
        minItems: { type: "number" },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "number" },
        minProperties: { type: "number" },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: {
          type: "string",
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        items: (value) => {
          if (Array.isArray(value)) {
            return (0, _1.listOf)("Schema");
          } else {
            return "Schema";
          }
        },
        allOf: (0, _1.listOf)("Schema"),
        properties: "SchemaProperties",
        additionalProperties: (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return "Schema";
          }
        },
        discriminator: { type: "string" },
        readOnly: { type: "boolean" },
        xml: "Xml",
        externalDocs: "ExternalDocs",
        example: { isExample: true },
        "x-tags": { type: "array", items: { type: "string" } },
        "x-nullable": { type: "boolean" },
        "x-extendedDiscriminator": { type: "string" },
        "x-additionalPropertiesName": { type: "string" },
        "x-explicitMappingOnly": { type: "boolean" },
        "x-enumDescriptions": "EnumDescriptions"
      },
      extensionsPrefix: "x-"
    };
    var EnumDescriptions = {
      properties: {},
      additionalProperties: { type: "string" }
    };
    var SchemaProperties = {
      properties: {},
      additionalProperties: "Schema"
    };
    var Xml = {
      properties: {
        name: { type: "string" },
        namespace: { type: "string" },
        prefix: { type: "string" },
        attribute: { type: "boolean" },
        wrapped: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    var SecurityScheme = {
      properties: {
        type: { enum: ["basic", "apiKey", "oauth2"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header"] },
        flow: { enum: ["implicit", "password", "application", "accessCode"] },
        authorizationUrl: { type: "string" },
        tokenUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        "x-defaultClientId": { type: "string" }
      },
      required(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "oauth2":
            switch (value == null ? void 0 : value.flow) {
              case "implicit":
                return ["type", "flow", "authorizationUrl", "scopes"];
              case "accessCode":
                return ["type", "flow", "authorizationUrl", "tokenUrl", "scopes"];
              case "application":
              case "password":
                return ["type", "flow", "tokenUrl", "scopes"];
              default:
                return ["type", "flow", "scopes"];
            }
          default:
            return ["type"];
        }
      },
      allowed(value) {
        switch (value == null ? void 0 : value.type) {
          case "basic":
            return ["type", "description"];
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "oauth2":
            switch (value == null ? void 0 : value.flow) {
              case "implicit":
                return ["type", "flow", "authorizationUrl", "description", "scopes"];
              case "accessCode":
                return ["type", "flow", "authorizationUrl", "tokenUrl", "description", "scopes"];
              case "application":
              case "password":
                return ["type", "flow", "tokenUrl", "description", "scopes"];
              default:
                return ["type", "flow", "tokenUrl", "authorizationUrl", "description", "scopes"];
            }
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    var SecurityRequirement = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    };
    var Example2 = {
      properties: {
        value: { isExample: true },
        summary: { type: "string" },
        description: { type: "string" },
        externalValue: { type: "string" }
      },
      extensionsPrefix: "x-"
    };
    exports.Oas2Types = {
      Root: Root2,
      Tag: Tag2,
      TagList: (0, _1.listOf)("Tag"),
      TagGroups: (0, _1.listOf)("TagGroup"),
      TagGroup,
      ExternalDocs,
      Example: Example2,
      ExamplesMap: (0, _1.mapOf)("Example"),
      EnumDescriptions,
      SecurityRequirement,
      SecurityRequirementList: (0, _1.listOf)("SecurityRequirement"),
      Info,
      Contact,
      License,
      Logo,
      Paths,
      PathItem,
      Parameter,
      ParameterItems,
      ParameterList: (0, _1.listOf)("Parameter"),
      Operation: Operation2,
      Examples: Examples2,
      Header: Header3,
      Responses,
      Response,
      Schema: Schema2,
      Xml,
      SchemaProperties,
      NamedSchemas: (0, _1.mapOf)("Schema"),
      NamedResponses: (0, _1.mapOf)("Response"),
      NamedParameters: (0, _1.mapOf)("Parameter"),
      NamedSecuritySchemes: (0, _1.mapOf)("SecurityScheme"),
      SecurityScheme,
      XCodeSample,
      XCodeSampleList: (0, _1.listOf)("XCodeSample"),
      XServerList: (0, _1.listOf)("XServer"),
      XServer
    };
  }
});

// node_modules/@redocly/openapi-core/lib/types/oas3.js
var require_oas3 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/oas3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Oas3Types = exports.Discriminator = exports.DiscriminatorMapping = exports.Xml = exports.ExternalDocs = void 0;
    var _1 = require_types();
    var ref_utils_1 = require_ref_utils();
    var responseCodeRegexp = /^[0-9][0-9Xx]{2}$/;
    var Root2 = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        components: "Components",
        "x-webhooks": "WebhooksMap",
        "x-tagGroups": "TagGroups",
        "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
      },
      required: ["openapi", "paths", "info"],
      extensionsPrefix: "x-"
    };
    var Tag2 = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        "x-traitTag": { type: "boolean" },
        "x-displayName": { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    };
    var TagGroup = {
      properties: {
        name: { type: "string" },
        tags: { type: "array", items: { type: "string" } }
      },
      extensionsPrefix: "x-"
    };
    exports.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"],
      extensionsPrefix: "x-"
    };
    var Server = {
      properties: {
        url: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap"
      },
      required: ["url"],
      extensionsPrefix: "x-"
    };
    var ServerVariable = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" }
      },
      required: ["default"],
      extensionsPrefix: "x-"
    };
    var SecurityRequirement = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    };
    var Info = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    };
    var Logo = {
      properties: {
        url: { type: "string" },
        altText: { type: "string" },
        backgroundColor: { type: "string" },
        href: { type: "string" }
      }
    };
    var Contact = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      },
      extensionsPrefix: "x-"
    };
    var License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    };
    var Paths = {
      properties: {},
      additionalProperties: (_value, key2) => key2.startsWith("/") ? "PathItem" : void 0
    };
    var WebhooksMap = {
      properties: {},
      additionalProperties: () => "PathItem"
    };
    var PathItem = {
      properties: {
        $ref: { type: "string" },
        // TODO: verify special $ref handling for Path Item
        servers: "ServerList",
        parameters: "ParameterList",
        summary: { type: "string" },
        description: { type: "string" },
        get: "Operation",
        put: "Operation",
        post: "Operation",
        delete: "Operation",
        options: "Operation",
        head: "Operation",
        patch: "Operation",
        trace: "Operation"
      },
      extensionsPrefix: "x-"
    };
    var Parameter = {
      properties: {
        name: { type: "string" },
        in: { enum: ["query", "header", "path", "cookie"] },
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: true },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      required: ["name", "in"],
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    };
    var Operation2 = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      required: ["responses"],
      extensionsPrefix: "x-"
    };
    var XCodeSample = {
      properties: {
        lang: { type: "string" },
        label: { type: "string" },
        source: { type: "string" }
      }
    };
    var RequestBody2 = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        content: "MediaTypesMap"
      },
      required: ["content"],
      extensionsPrefix: "x-"
    };
    var MediaTypesMap = {
      properties: {},
      additionalProperties: "MediaType"
    };
    var MediaType = {
      properties: {
        schema: "Schema",
        example: { isExample: true },
        examples: "ExamplesMap",
        encoding: "EncodingMap"
      },
      extensionsPrefix: "x-"
    };
    var Example2 = {
      properties: {
        value: { isExample: true },
        summary: { type: "string" },
        description: { type: "string" },
        externalValue: { type: "string" }
      },
      extensionsPrefix: "x-"
    };
    var Encoding = {
      properties: {
        contentType: { type: "string" },
        headers: "HeadersMap",
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    var EnumDescriptions = {
      properties: {},
      additionalProperties: { type: "string" }
    };
    var Header3 = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: true },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    };
    var Responses = {
      properties: { default: "Response" },
      additionalProperties: (_v, key2) => responseCodeRegexp.test(key2) ? "Response" : void 0
    };
    var Response = {
      properties: {
        description: { type: "string" },
        headers: "HeadersMap",
        content: "MediaTypesMap",
        links: "LinksMap",
        "x-summary": { type: "string" }
      },
      required: ["description"],
      extensionsPrefix: "x-"
    };
    var Link3 = {
      properties: {
        operationRef: { type: "string" },
        operationId: { type: "string" },
        parameters: null,
        // TODO: figure out how to describe/validate this
        requestBody: null,
        // TODO: figure out how to describe/validate this
        description: { type: "string" },
        server: "Server"
      },
      extensionsPrefix: "x-"
    };
    var Schema2 = {
      properties: {
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "boolean" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: {
          enum: ["object", "array", "string", "number", "integer", "boolean"]
        },
        allOf: (0, _1.listOf)("Schema"),
        anyOf: (0, _1.listOf)("Schema"),
        oneOf: (0, _1.listOf)("Schema"),
        not: "Schema",
        properties: "SchemaProperties",
        items: (value) => {
          if (Array.isArray(value)) {
            return (0, _1.listOf)("Schema");
          } else {
            return "Schema";
          }
        },
        additionalProperties: (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return "Schema";
          }
        },
        description: { type: "string" },
        format: { type: "string" },
        default: null,
        nullable: { type: "boolean" },
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        example: { isExample: true },
        deprecated: { type: "boolean" },
        "x-tags": { type: "array", items: { type: "string" } },
        "x-additionalPropertiesName": { type: "string" },
        "x-explicitMappingOnly": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    exports.Xml = {
      properties: {
        name: { type: "string" },
        namespace: { type: "string" },
        prefix: { type: "string" },
        attribute: { type: "boolean" },
        wrapped: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    var SchemaProperties = {
      properties: {},
      additionalProperties: "Schema"
    };
    exports.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (value) => {
        if ((0, ref_utils_1.isMappingRef)(value)) {
          return { type: "string", directResolveAs: "Schema" };
        } else {
          return { type: "string" };
        }
      }
    };
    exports.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"],
      extensionsPrefix: "x-"
    };
    var Components = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks"
      },
      extensionsPrefix: "x-"
    };
    var ImplicitFlow = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"],
      extensionsPrefix: "x-"
    };
    var PasswordFlow = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    };
    var ClientCredentials = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    };
    var AuthorizationCode = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" },
        "x-usePkce": (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return "XUsePkce";
          }
        }
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    };
    var OAuth2Flows = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      },
      extensionsPrefix: "x-"
    };
    var SecurityScheme = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" },
        "x-defaultClientId": { type: "string" }
      },
      required(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    var XUsePkce = {
      properties: {
        disableManualConfiguration: { type: "boolean" },
        hideClientSecretInput: { type: "boolean" }
      }
    };
    exports.Oas3Types = {
      Root: Root2,
      Tag: Tag2,
      TagList: (0, _1.listOf)("Tag"),
      TagGroups: (0, _1.listOf)("TagGroup"),
      TagGroup,
      ExternalDocs: exports.ExternalDocs,
      Server,
      ServerList: (0, _1.listOf)("Server"),
      ServerVariable,
      ServerVariablesMap: (0, _1.mapOf)("ServerVariable"),
      SecurityRequirement,
      SecurityRequirementList: (0, _1.listOf)("SecurityRequirement"),
      Info,
      Contact,
      License,
      Paths,
      PathItem,
      Parameter,
      ParameterList: (0, _1.listOf)("Parameter"),
      Operation: Operation2,
      Callback: (0, _1.mapOf)("PathItem"),
      CallbacksMap: (0, _1.mapOf)("Callback"),
      RequestBody: RequestBody2,
      MediaTypesMap,
      MediaType,
      Example: Example2,
      ExamplesMap: (0, _1.mapOf)("Example"),
      Encoding,
      EncodingMap: (0, _1.mapOf)("Encoding"),
      EnumDescriptions,
      Header: Header3,
      HeadersMap: (0, _1.mapOf)("Header"),
      Responses,
      Response,
      Link: Link3,
      Logo,
      Schema: Schema2,
      Xml: exports.Xml,
      SchemaProperties,
      DiscriminatorMapping: exports.DiscriminatorMapping,
      Discriminator: exports.Discriminator,
      Components,
      LinksMap: (0, _1.mapOf)("Link"),
      NamedSchemas: (0, _1.mapOf)("Schema"),
      NamedResponses: (0, _1.mapOf)("Response"),
      NamedParameters: (0, _1.mapOf)("Parameter"),
      NamedExamples: (0, _1.mapOf)("Example"),
      NamedRequestBodies: (0, _1.mapOf)("RequestBody"),
      NamedHeaders: (0, _1.mapOf)("Header"),
      NamedSecuritySchemes: (0, _1.mapOf)("SecurityScheme"),
      NamedLinks: (0, _1.mapOf)("Link"),
      NamedCallbacks: (0, _1.mapOf)("Callback"),
      ImplicitFlow,
      PasswordFlow,
      ClientCredentials,
      AuthorizationCode,
      OAuth2Flows,
      SecurityScheme,
      XCodeSample,
      XCodeSampleList: (0, _1.listOf)("XCodeSample"),
      XUsePkce,
      WebhooksMap
    };
  }
});

// node_modules/@redocly/openapi-core/lib/types/oas3_1.js
var require_oas3_1 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/oas3_1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Oas3_1Types = exports.DependentRequired = exports.SchemaProperties = exports.Schema = void 0;
    var _1 = require_types();
    var oas3_1 = require_oas3();
    var Root2 = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        webhooks: "WebhooksMap",
        components: "Components",
        jsonSchemaDialect: { type: "string" }
      },
      required: ["openapi", "info"],
      requiredOneOf: ["paths", "components", "webhooks"],
      extensionsPrefix: "x-"
    };
    var License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        identifier: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    };
    var Info = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        summary: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    };
    var Components = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks",
        pathItems: "NamedPathItems"
      },
      extensionsPrefix: "x-"
    };
    var Operation2 = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    exports.Schema = {
      properties: {
        $id: { type: "string" },
        $anchor: { type: "string" },
        id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        $defs: "NamedSchemas",
        $vocabulary: { type: "string" },
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (value) => {
          if (Array.isArray(value)) {
            return {
              type: "array",
              items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
            };
          } else {
            return {
              enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
            };
          }
        },
        allOf: (0, _1.listOf)("Schema"),
        anyOf: (0, _1.listOf)("Schema"),
        oneOf: (0, _1.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        dependentSchemas: (0, _1.mapOf)("Schema"),
        dependentRequired: "DependentRequired",
        prefixItems: (0, _1.listOf)("Schema"),
        contains: "Schema",
        minContains: { type: "integer", minimum: 0 },
        maxContains: { type: "integer", minimum: 0 },
        patternProperties: "PatternProperties",
        propertyNames: "Schema",
        unevaluatedItems: (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return "Schema";
          }
        },
        unevaluatedProperties: (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return "Schema";
          }
        },
        summary: { type: "string" },
        properties: "SchemaProperties",
        items: (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return "Schema";
          }
        },
        additionalProperties: (value) => {
          return typeof value === "boolean" ? { type: "boolean" } : "Schema";
        },
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        contentSchema: "Schema",
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        examples: { type: "array" },
        example: { isExample: true },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        "x-tags": { type: "array", items: { type: "string" } },
        $dynamicAnchor: { type: "string" },
        $dynamicRef: { type: "string" }
      },
      extensionsPrefix: "x-"
    };
    exports.SchemaProperties = {
      properties: {},
      additionalProperties: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      }
    };
    var SecurityScheme = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect", "mutualTLS"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" }
      },
      required(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            switch (value == null ? void 0 : value.flows) {
              case "implicit":
                return ["type", "flows", "authorizationUrl", "refreshUrl", "description", "scopes"];
              case "password":
              case "clientCredentials":
                return ["type", "flows", "tokenUrl", "refreshUrl", "description", "scopes"];
              case "authorizationCode":
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
              default:
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
            }
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          case "mutualTLS":
            return ["type", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    exports.DependentRequired = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    };
    exports.Oas3_1Types = {
      ...oas3_1.Oas3Types,
      Info,
      Root: Root2,
      Schema: exports.Schema,
      SchemaProperties: exports.SchemaProperties,
      PatternProperties: exports.SchemaProperties,
      License,
      Components,
      NamedPathItems: (0, _1.mapOf)("PathItem"),
      SecurityScheme,
      Operation: Operation2,
      DependentRequired: exports.DependentRequired
    };
  }
});

// node_modules/@redocly/openapi-core/lib/types/asyncapi2.js
var require_asyncapi2 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/asyncapi2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncApi2Types = exports.AsyncApi2Bindings = exports.Dependencies = exports.SecuritySchemeFlows = exports.Discriminator = exports.DiscriminatorMapping = exports.SchemaProperties = exports.Schema = exports.MessageExample = exports.CorrelationId = exports.License = exports.Contact = exports.ServerVariable = exports.ServerMap = exports.ExternalDocs = exports.Tag = void 0;
    var _1 = require_types();
    var ref_utils_1 = require_ref_utils();
    var Root2 = {
      properties: {
        asyncapi: null,
        // TODO: validate semver format and supported version
        info: "Info",
        id: { type: "string" },
        servers: "ServerMap",
        channels: "ChannelMap",
        components: "Components",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        defaultContentType: { type: "string" }
      },
      required: ["asyncapi", "channels", "info"]
    };
    var Channel = {
      properties: {
        description: { type: "string" },
        subscribe: "Operation",
        publish: "Operation",
        parameters: "ParametersMap",
        bindings: "ChannelBindings",
        servers: { type: "array", items: { type: "string" } }
      }
    };
    var ChannelMap = {
      properties: {},
      additionalProperties: "Channel"
    };
    var ChannelBindings = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    exports.Tag = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs"
      },
      required: ["name"]
    };
    exports.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"]
    };
    var SecurityRequirement = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    };
    var ServerBindings = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    var Server = {
      properties: {
        url: { type: "string" },
        protocol: { type: "string" },
        protocolVersion: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap",
        security: "SecurityRequirementList",
        bindings: "ServerBindings",
        tags: "TagList"
      },
      required: ["url", "protocol"]
    };
    exports.ServerMap = {
      properties: {},
      additionalProperties: (_value, key2) => (
        // eslint-disable-next-line no-useless-escape
        key2.match(/^[A-Za-z0-9_\-]+$/) ? "Server" : void 0
      )
    };
    exports.ServerVariable = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" },
        examples: {
          type: "array",
          items: { type: "string" }
        }
      },
      required: []
    };
    var Info = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License"
      },
      required: ["title", "version"]
    };
    exports.Contact = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      }
    };
    exports.License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"]
    };
    var Parameter = {
      properties: {
        description: { type: "string" },
        schema: "Schema",
        location: { type: "string" }
      }
    };
    exports.CorrelationId = {
      properties: {
        description: { type: "string" },
        location: { type: "string" }
      },
      required: ["location"]
    };
    var Message = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        payload: "Schema",
        // TODO: strictly this does not cover all cases
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        // TODO: support official list of schema formats and custom values
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList",
        traits: "MessageTraitList"
      },
      additionalProperties: {}
    };
    var MessageBindings = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    var OperationBindings = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    var OperationTrait = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings"
      },
      required: []
    };
    var MessageTrait = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList"
      },
      additionalProperties: {}
    };
    var Operation2 = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings",
        traits: "OperationTraitList",
        message: "Message"
      },
      required: []
    };
    exports.MessageExample = {
      properties: {
        payload: { isExample: true },
        summary: { type: "string" },
        name: { type: "string" },
        headers: { type: "object" }
      }
    };
    exports.Schema = {
      properties: {
        $id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        myArbitraryKeyword: { type: "boolean" },
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (value) => {
          return Array.isArray(value) ? {
            type: "array",
            items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
          } : {
            enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
          };
        },
        allOf: (0, _1.listOf)("Schema"),
        anyOf: (0, _1.listOf)("Schema"),
        oneOf: (0, _1.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        contains: "Schema",
        patternProperties: { type: "object" },
        propertyNames: "Schema",
        properties: "SchemaProperties",
        items: (value) => {
          return Array.isArray(value) ? (0, _1.listOf)("Schema") : "Schema";
        },
        additionalProperties: (value) => {
          return typeof value === "boolean" ? { type: "boolean" } : "Schema";
        },
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        examples: { type: "array" },
        example: { isExample: true },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        additionalItems: (value) => {
          return typeof value === "boolean" ? { type: "boolean" } : "Schema";
        },
        dependencies: "Dependencies"
      }
    };
    exports.SchemaProperties = {
      properties: {},
      additionalProperties: (value) => {
        return typeof value === "boolean" ? { type: "boolean" } : "Schema";
      }
    };
    exports.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (value) => {
        if ((0, ref_utils_1.isMappingRef)(value)) {
          return { type: "string", directResolveAs: "Schema" };
        } else {
          return { type: "string" };
        }
      }
    };
    exports.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"]
    };
    var Components = {
      properties: {
        messages: "NamedMessages",
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        correlationIds: "NamedCorrelationIds",
        messageTraits: "NamedMessageTraits",
        operationTraits: "NamedOperationTraits",
        securitySchemes: "NamedSecuritySchemes",
        servers: "ServerMap",
        serverVariables: "ServerVariablesMap",
        channels: "ChannelMap",
        serverBindings: "ServerBindings",
        channelBindings: "ChannelBindings",
        operationBindings: "OperationBindings",
        messageBindings: "MessageBindings"
      }
    };
    var ImplicitFlow = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"]
    };
    var PasswordFlow = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    };
    var ClientCredentials = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    };
    var AuthorizationCode = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"]
    };
    exports.SecuritySchemeFlows = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      }
    };
    var SecurityScheme = {
      properties: {
        type: {
          enum: [
            "userPassword",
            "apiKey",
            "X509",
            "symmetricEncryption",
            "asymmetricEncryption",
            "httpApiKey",
            "http",
            "oauth2",
            "openIdConnect",
            "plain",
            "scramSha256",
            "scramSha512",
            "gssapi"
          ]
        },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "SecuritySchemeFlows",
        openIdConnectUrl: { type: "string" }
      },
      required(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "in"];
          case "httpApiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "in", "description"];
          case "httpApiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    exports.Dependencies = {
      properties: {},
      additionalProperties: (value) => {
        return Array.isArray(value) ? { type: "array", items: { type: "string" } } : "Schema";
      }
    };
    var HttpChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.http = HttpChannelBinding;
    var HttpServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.http = HttpServerBinding;
    var HttpMessageBinding = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    MessageBindings.properties.http = HttpMessageBinding;
    var HttpOperationBinding = {
      properties: {
        type: { type: "string" },
        method: {
          type: "string",
          enum: ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS", "CONNECT", "TRACE"]
        },
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    OperationBindings.properties.http = HttpOperationBinding;
    var WsChannelBinding = {
      properties: {
        method: { type: "string" },
        query: "Schema",
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    ChannelBindings.properties.ws = WsChannelBinding;
    var WsServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.ws = WsServerBinding;
    var WsMessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.ws = WsMessageBinding;
    var WsOperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.ws = WsOperationBinding;
    var KafkaTopicConfiguration = {
      properties: {
        "cleanup.policy": { type: "array", items: { enum: ["delete", "compact"] } },
        "retention.ms": { type: "integer" },
        "retention.bytes": { type: "integer" },
        "delete.retention.ms": { type: "integer" },
        "max.message.bytes": { type: "integer" }
      }
    };
    var KafkaChannelBinding = {
      properties: {
        topic: { type: "string" },
        partitions: { type: "integer" },
        replicas: { type: "integer" },
        topicConfiguration: "KafkaTopicConfiguration",
        bindingVersion: { type: "string" }
      }
    };
    ChannelBindings.properties.kafka = KafkaChannelBinding;
    var KafkaServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.kafka = KafkaServerBinding;
    var KafkaMessageBinding = {
      properties: {
        key: "Schema",
        // TODO: add avro support
        schemaIdLocation: { type: "string" },
        schemaIdPayloadEncoding: { type: "string" },
        schemaLookupStrategy: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    MessageBindings.properties.kafka = KafkaMessageBinding;
    var KafkaOperationBinding = {
      properties: {
        groupId: "Schema",
        clientId: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    OperationBindings.properties.kafka = KafkaOperationBinding;
    var AnypointmqChannelBinding = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    ChannelBindings.properties.anypointmq = AnypointmqChannelBinding;
    var AnypointmqServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.anypointmq = AnypointmqServerBinding;
    var AnypointmqMessageBinding = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    MessageBindings.properties.anypointmq = AnypointmqMessageBinding;
    var AnypointmqOperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.anypointmq = AnypointmqOperationBinding;
    var AmqpChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.amqp = AmqpChannelBinding;
    var AmqpServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.amqp = AmqpServerBinding;
    var AmqpMessageBinding = {
      properties: {
        contentEncoding: { type: "string" },
        messageType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    MessageBindings.properties.amqp = AmqpMessageBinding;
    var AmqpOperationBinding = {
      // TODO: some fields are subscribe only
      properties: {
        expiration: { type: "integer" },
        userId: { type: "string" },
        cc: { type: "array", items: { type: "string" } },
        priority: { type: "integer" },
        deliveryMode: { type: "integer" },
        // TODO: enum: [1, 2]
        mandatory: { type: "boolean" },
        bcc: { type: "array", items: { type: "string" } },
        replyTo: { type: "string" },
        timestamp: { type: "boolean" },
        ack: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    OperationBindings.properties.amqp = AmqpOperationBinding;
    var Amqp1ChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.amqp1 = Amqp1ChannelBinding;
    var Amqp1ServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.amqp1 = Amqp1ServerBinding;
    var Amqp1MessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.amqp1 = Amqp1MessageBinding;
    var Amqp1OperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.amqp1 = Amqp1OperationBinding;
    var MqttChannelBinding = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    ChannelBindings.properties.mqtt = MqttChannelBinding;
    var MqttServerBindingLastWill = {
      properties: {
        topic: { type: "string" },
        qos: { type: "integer" },
        message: { type: "string" },
        retain: { type: "boolean" }
      }
    };
    var MqttServerBinding = {
      properties: {
        clientId: { type: "string" },
        cleanSession: { type: "boolean" },
        lastWill: "MqttServerBindingLastWill",
        keepAlive: { type: "integer" },
        bindingVersion: { type: "string" }
      }
    };
    ServerBindings.properties.mqtt = MqttServerBinding;
    var MqttMessageBinding = {
      properties: {
        bindingVersion: { type: "string" }
      }
    };
    MessageBindings.properties.mqtt = MqttMessageBinding;
    var MqttOperationBinding = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    OperationBindings.properties.mqtt = MqttOperationBinding;
    var Mqtt5ChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.mqtt5 = Mqtt5ChannelBinding;
    var Mqtt5ServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.mqtt5 = Mqtt5ServerBinding;
    var Mqtt5MessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.mqtt5 = Mqtt5MessageBinding;
    var Mqtt5OperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.mqtt5 = Mqtt5OperationBinding;
    var NatsChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.nats = NatsChannelBinding;
    var NatsServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.nats = NatsServerBinding;
    var NatsMessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.nats = NatsMessageBinding;
    var NatsOperationBinding = {
      properties: {
        queue: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    OperationBindings.properties.nats = NatsOperationBinding;
    var JmsChannelBinding = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    ChannelBindings.properties.jms = JmsChannelBinding;
    var JmsServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.jms = JmsServerBinding;
    var JmsMessageBinding = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    MessageBindings.properties.jms = JmsMessageBinding;
    var JmsOperationBinding = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    OperationBindings.properties.jms = JmsOperationBinding;
    var SolaceChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.solace = SolaceChannelBinding;
    var SolaceServerBinding = {
      properties: {
        bindingVersion: { type: "string" },
        msgVpn: { type: "string" }
      }
    };
    ServerBindings.properties.solace = SolaceServerBinding;
    var SolaceMessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.solace = SolaceMessageBinding;
    var SolaceDestination = {
      properties: {
        destinationType: { type: "string", enum: ["queue", "topic"] },
        deliveryMode: { type: "string", enum: ["direct", "persistent"] },
        "queue.name": { type: "string" },
        "queue.topicSubscriptions": { type: "array", items: { type: "string" } },
        "queue.accessType": { type: "string", enum: ["exclusive", "nonexclusive"] },
        "queue.maxMsgSpoolSize": { type: "string" },
        "queue.maxTtl": { type: "string" },
        "topic.topicSubscriptions": { type: "array", items: { type: "string" } }
      }
    };
    var SolaceOperationBinding = {
      properties: {
        bindingVersion: { type: "string" },
        destinations: (0, _1.listOf)("SolaceDestination")
      }
    };
    OperationBindings.properties.solace = SolaceOperationBinding;
    var StompChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.stomp = StompChannelBinding;
    var StompServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.stomp = StompServerBinding;
    var StompMessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.stomp = StompMessageBinding;
    var StompOperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.stomp = StompOperationBinding;
    var RedisChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.redis = RedisChannelBinding;
    var RedisServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.redis = RedisServerBinding;
    var RedisMessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.redis = RedisMessageBinding;
    var RedisOperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.redis = RedisOperationBinding;
    var MercureChannelBinding = {
      properties: {}
      // empty object
    };
    ChannelBindings.properties.mercure = MercureChannelBinding;
    var MercureServerBinding = {
      properties: {}
      // empty object
    };
    ServerBindings.properties.mercure = MercureServerBinding;
    var MercureMessageBinding = {
      properties: {}
      // empty object
    };
    MessageBindings.properties.mercure = MercureMessageBinding;
    var MercureOperationBinding = {
      properties: {}
      // empty object
    };
    OperationBindings.properties.mercure = MercureOperationBinding;
    exports.AsyncApi2Bindings = {
      HttpServerBinding,
      HttpChannelBinding,
      HttpMessageBinding,
      HttpOperationBinding,
      WsServerBinding,
      WsChannelBinding,
      WsMessageBinding,
      WsOperationBinding,
      KafkaServerBinding,
      KafkaTopicConfiguration,
      KafkaChannelBinding,
      KafkaMessageBinding,
      KafkaOperationBinding,
      AnypointmqServerBinding,
      AnypointmqChannelBinding,
      AnypointmqMessageBinding,
      AnypointmqOperationBinding,
      AmqpServerBinding,
      AmqpChannelBinding,
      AmqpMessageBinding,
      AmqpOperationBinding,
      Amqp1ServerBinding,
      Amqp1ChannelBinding,
      Amqp1MessageBinding,
      Amqp1OperationBinding,
      MqttServerBindingLastWill,
      MqttServerBinding,
      MqttChannelBinding,
      MqttMessageBinding,
      MqttOperationBinding,
      Mqtt5ServerBinding,
      Mqtt5ChannelBinding,
      Mqtt5MessageBinding,
      Mqtt5OperationBinding,
      NatsServerBinding,
      NatsChannelBinding,
      NatsMessageBinding,
      NatsOperationBinding,
      JmsServerBinding,
      JmsChannelBinding,
      JmsMessageBinding,
      JmsOperationBinding,
      SolaceServerBinding,
      SolaceChannelBinding,
      SolaceMessageBinding,
      SolaceDestination,
      SolaceOperationBinding,
      StompServerBinding,
      StompChannelBinding,
      StompMessageBinding,
      StompOperationBinding,
      RedisServerBinding,
      RedisChannelBinding,
      RedisMessageBinding,
      RedisOperationBinding,
      MercureServerBinding,
      MercureChannelBinding,
      MercureMessageBinding,
      MercureOperationBinding,
      ServerBindings,
      ChannelBindings,
      MessageBindings,
      OperationBindings
    };
    exports.AsyncApi2Types = {
      ...exports.AsyncApi2Bindings,
      Root: Root2,
      Tag: exports.Tag,
      TagList: (0, _1.listOf)("Tag"),
      ServerMap: exports.ServerMap,
      ExternalDocs: exports.ExternalDocs,
      Server,
      ServerVariable: exports.ServerVariable,
      ServerVariablesMap: (0, _1.mapOf)("ServerVariable"),
      SecurityRequirement,
      SecurityRequirementList: (0, _1.listOf)("SecurityRequirement"),
      Info,
      Contact: exports.Contact,
      License: exports.License,
      ChannelMap,
      Channel,
      Parameter,
      ParametersMap: (0, _1.mapOf)("Parameter"),
      Operation: Operation2,
      Schema: exports.Schema,
      MessageExample: exports.MessageExample,
      SchemaProperties: exports.SchemaProperties,
      DiscriminatorMapping: exports.DiscriminatorMapping,
      Discriminator: exports.Discriminator,
      Components,
      NamedSchemas: (0, _1.mapOf)("Schema"),
      NamedMessages: (0, _1.mapOf)("Message"),
      NamedMessageTraits: (0, _1.mapOf)("MessageTrait"),
      NamedOperationTraits: (0, _1.mapOf)("OperationTrait"),
      NamedParameters: (0, _1.mapOf)("Parameter"),
      NamedSecuritySchemes: (0, _1.mapOf)("SecurityScheme"),
      NamedCorrelationIds: (0, _1.mapOf)("CorrelationId"),
      ImplicitFlow,
      PasswordFlow,
      ClientCredentials,
      AuthorizationCode,
      SecuritySchemeFlows: exports.SecuritySchemeFlows,
      SecurityScheme,
      Message,
      MessageBindings,
      OperationBindings,
      OperationTrait,
      OperationTraitList: (0, _1.listOf)("OperationTrait"),
      MessageTrait,
      MessageTraitList: (0, _1.listOf)("MessageTrait"),
      MessageExampleList: (0, _1.listOf)("MessageExample"),
      CorrelationId: exports.CorrelationId,
      Dependencies: exports.Dependencies
    };
  }
});

// node_modules/@redocly/openapi-core/lib/types/asyncapi3.js
var require_asyncapi3 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/asyncapi3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncApi3Types = void 0;
    var _1 = require_types();
    var asyncapi2_1 = require_asyncapi2();
    var Root2 = {
      properties: {
        asyncapi: { type: "string", enum: ["3.0.0"] },
        info: "Info",
        id: { type: "string" },
        servers: "ServerMap",
        channels: "NamedChannels",
        components: "Components",
        operations: "NamedOperations",
        defaultContentType: { type: "string" }
      },
      required: ["asyncapi", "info"]
    };
    var Channel = {
      properties: {
        address: { type: "string" },
        messages: "NamedMessages",
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        servers: "ServerList",
        parameters: "ParametersMap",
        bindings: "ChannelBindings",
        tags: "TagList",
        externalDocs: "ExternalDocs"
      }
    };
    var Server = {
      properties: {
        host: { type: "string" },
        pathname: { type: "string" },
        protocol: { type: "string" },
        protocolVersion: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap",
        security: "SecuritySchemeList",
        bindings: "ServerBindings",
        externalDocs: "ExternalDocs",
        tags: "TagList"
      },
      required: ["host", "protocol"]
    };
    var Info = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License",
        tags: "TagList",
        externalDocs: "ExternalDocs"
      },
      required: ["title", "version"]
    };
    var Parameter = {
      properties: {
        description: { type: "string" },
        enum: { type: "array", items: { type: "string" } },
        default: { type: "string" },
        examples: { type: "array", items: { type: "string" } },
        location: { type: "string" }
      }
    };
    var Message = {
      properties: {
        headers: "Schema",
        payload: (value) => {
          if (!!value && (value == null ? void 0 : value["schemaFormat"])) {
            return {
              properties: {
                schema: "Schema",
                schemaFormat: { type: "string" }
              },
              required: ["schema", "schemaFormat"]
            };
          } else {
            return "Schema";
          }
        },
        correlationId: "CorrelationId",
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList",
        traits: "MessageTraitList"
      },
      additionalProperties: {}
    };
    var OperationTrait = {
      properties: {
        tags: "TagList",
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        security: "SecuritySchemeList",
        bindings: "OperationBindings"
      },
      required: []
    };
    var MessageTrait = {
      properties: {
        headers: (value) => {
          if (typeof value === "function" || typeof value === "object" && !!value) {
            return {
              properties: {
                schema: "Schema",
                schemaFormat: { type: "string" }
              }
            };
          } else {
            return "Schema";
          }
        },
        correlationId: "CorrelationId",
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList"
      },
      additionalProperties: {}
    };
    var Operation2 = {
      properties: {
        action: { type: "string", enum: ["send", "receive"] },
        channel: "Channel",
        title: { type: "string" },
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecuritySchemeList",
        bindings: "OperationBindings",
        traits: "OperationTraitList",
        messages: "MessageList",
        reply: "OperationReply"
      },
      required: ["action", "channel"]
    };
    var OperationReply = {
      properties: {
        channel: "Channel",
        messages: "MessageList",
        address: "OperationReplyAddress"
      }
    };
    var OperationReplyAddress = {
      properties: {
        location: { type: "string" },
        description: { type: "string" }
      },
      required: ["location"]
    };
    var Components = {
      properties: {
        messages: "NamedMessages",
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        replies: "NamedOperationReplies",
        replyAddresses: "NamedOperationRelyAddresses",
        correlationIds: "NamedCorrelationIds",
        messageTraits: "NamedMessageTraits",
        operationTraits: "NamedOperationTraits",
        tags: "NamedTags",
        externalDocs: "NamedExternalDocs",
        securitySchemes: "NamedSecuritySchemes",
        servers: "ServerMap",
        serverVariables: "ServerVariablesMap",
        channels: "NamedChannels",
        operations: "NamedOperations",
        serverBindings: "ServerBindings",
        channelBindings: "ChannelBindings",
        operationBindings: "OperationBindings",
        messageBindings: "MessageBindings"
      }
    };
    var ImplicitFlow = {
      properties: {
        refreshUrl: { type: "string" },
        availableScopes: { type: "object", additionalProperties: { type: "string" } },
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "availableScopes"]
    };
    var PasswordFlow = {
      properties: {
        refreshUrl: { type: "string" },
        availableScopes: { type: "object", additionalProperties: { type: "string" } },
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "availableScopes"]
    };
    var ClientCredentials = {
      properties: {
        refreshUrl: { type: "string" },
        availableScopes: { type: "object", additionalProperties: { type: "string" } },
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "availableScopes"]
    };
    var AuthorizationCode = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        availableScopes: { type: "object", additionalProperties: { type: "string" } },
        tokenUrl: { type: "string" }
      },
      required: ["authorizationUrl", "tokenUrl", "availableScopes"]
    };
    var SecurityScheme = {
      properties: {
        type: {
          enum: [
            "userPassword",
            "apiKey",
            "X509",
            "symmetricEncryption",
            "asymmetricEncryption",
            "httpApiKey",
            "http",
            "oauth2",
            "openIdConnect",
            "plain",
            "scramSha256",
            "scramSha512",
            "gssapi"
          ]
        },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "SecuritySchemeFlows",
        openIdConnectUrl: { type: "string" },
        scopes: { type: "array", items: { type: "string" } }
      },
      required(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "in"];
          case "httpApiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(value) {
        switch (value == null ? void 0 : value.type) {
          case "apiKey":
            return ["type", "in", "description"];
          case "httpApiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description", "scopes"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description", "scopes"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    exports.AsyncApi3Types = {
      // from asyncapi2
      ...asyncapi2_1.AsyncApi2Bindings,
      CorrelationId: asyncapi2_1.CorrelationId,
      SecuritySchemeFlows: asyncapi2_1.SecuritySchemeFlows,
      ServerVariable: asyncapi2_1.ServerVariable,
      Contact: asyncapi2_1.Contact,
      License: asyncapi2_1.License,
      MessageExample: asyncapi2_1.MessageExample,
      Tag: asyncapi2_1.Tag,
      Dependencies: asyncapi2_1.Dependencies,
      Schema: asyncapi2_1.Schema,
      Discriminator: asyncapi2_1.Discriminator,
      DiscriminatorMapping: asyncapi2_1.DiscriminatorMapping,
      SchemaProperties: asyncapi2_1.SchemaProperties,
      ServerMap: asyncapi2_1.ServerMap,
      ExternalDocs: asyncapi2_1.ExternalDocs,
      Root: Root2,
      Channel,
      Parameter,
      Info,
      Server,
      MessageTrait,
      Operation: Operation2,
      OperationReply,
      OperationReplyAddress,
      Components,
      ImplicitFlow,
      PasswordFlow,
      ClientCredentials,
      AuthorizationCode,
      SecurityScheme,
      Message,
      OperationTrait,
      ServerVariablesMap: (0, _1.mapOf)("ServerVariable"),
      NamedTags: (0, _1.mapOf)("Tag"),
      NamedExternalDocs: (0, _1.mapOf)("ExternalDocs"),
      NamedChannels: (0, _1.mapOf)("Channel"),
      ParametersMap: (0, _1.mapOf)("Parameter"),
      NamedOperations: (0, _1.mapOf)("Operation"),
      NamedOperationReplies: (0, _1.mapOf)("OperationReply"),
      NamedOperationRelyAddresses: (0, _1.mapOf)("OperationReplyAddress"),
      NamedSchemas: (0, _1.mapOf)("Schema"),
      NamedMessages: (0, _1.mapOf)("Message"),
      NamedMessageTraits: (0, _1.mapOf)("MessageTrait"),
      NamedOperationTraits: (0, _1.mapOf)("OperationTrait"),
      NamedParameters: (0, _1.mapOf)("Parameter"),
      NamedSecuritySchemes: (0, _1.mapOf)("SecurityScheme"),
      NamedCorrelationIds: (0, _1.mapOf)("CorrelationId"),
      ServerList: (0, _1.listOf)("Server"),
      SecuritySchemeList: (0, _1.listOf)("SecurityScheme"),
      MessageList: (0, _1.listOf)("Message"),
      OperationTraitList: (0, _1.listOf)("OperationTrait"),
      MessageTraitList: (0, _1.listOf)("MessageTrait"),
      MessageExampleList: (0, _1.listOf)("MessageExample"),
      TagList: (0, _1.listOf)("Tag")
    };
  }
});

// node_modules/@redocly/openapi-core/lib/types/arazzo.js
var require_arazzo = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/arazzo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Arazzo1Types = void 0;
    var _1 = require_types();
    var oas3_1_1 = require_oas3_1();
    var oas3_1 = require_oas3();
    var Root2 = {
      properties: {
        arazzo: { type: "string" },
        info: "Info",
        sourceDescriptions: "SourceDescriptions",
        workflows: "Workflows",
        components: "Components"
      },
      required: ["arazzo", "info", "sourceDescriptions", "workflows"],
      extensionsPrefix: "x-"
    };
    var NamedParameters = {
      properties: {},
      additionalProperties: "Parameter"
    };
    var NamedSuccessActions = {
      properties: {},
      additionalProperties: "SuccessActionObject"
    };
    var NamedFailureActions = {
      properties: {},
      additionalProperties: "FailureActionObject"
    };
    var Components = {
      properties: {
        inputs: "NamedInputs",
        parameters: "NamedParameters",
        successActions: "NamedSuccessActions",
        failureActions: "NamedFailureActions"
      },
      extensionsPrefix: "x-"
    };
    var NamedInputs = (0, _1.mapOf)("Schema");
    var Info = {
      properties: {
        title: { type: "string" },
        description: { type: "string" },
        summary: { type: "string" },
        version: { type: "string" }
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    };
    var SourceDescriptions = {
      properties: {},
      items: (value) => {
        if ((value == null ? void 0 : value.type) === "openapi") {
          return "OpenAPISourceDescription";
        } else {
          return "ArazzoSourceDescription";
        }
      }
    };
    var OpenAPISourceDescription = {
      properties: {
        name: { type: "string" },
        type: { type: "string", enum: ["openapi"] },
        url: { type: "string" },
        "x-serverUrl": { type: "string" }
      },
      required: ["name", "type", "url"],
      extensionsPrefix: "x-"
    };
    var ArazzoSourceDescription = {
      properties: {
        name: { type: "string" },
        type: { type: "string", enum: ["arazzo"] },
        url: { type: "string" }
      },
      required: ["name", "type", "url"],
      extensionsPrefix: "x-"
    };
    var ReusableObject = {
      properties: {
        reference: { type: "string" },
        value: {}
        // any
      },
      required: ["reference"],
      extensionsPrefix: "x-"
    };
    var Parameter = {
      properties: {
        in: { type: "string", enum: ["header", "query", "path", "cookie"] },
        name: { type: "string" },
        value: {}
        // any
      },
      required: ["name", "value"],
      extensionsPrefix: "x-"
    };
    var Parameters2 = {
      properties: {},
      items: (value) => {
        if (value == null ? void 0 : value.reference) {
          return "ReusableObject";
        } else {
          return "Parameter";
        }
      }
    };
    var Workflow = {
      properties: {
        workflowId: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        parameters: "Parameters",
        dependsOn: { type: "array", items: { type: "string" } },
        inputs: "Schema",
        outputs: "Outputs",
        steps: "Steps",
        successActions: "OnSuccessActionList",
        failureActions: "OnFailureActionList"
      },
      required: ["workflowId", "steps"],
      extensionsPrefix: "x-"
    };
    var Workflows = (0, _1.listOf)("Workflow");
    var Steps = (0, _1.listOf)("Step");
    var Step = {
      properties: {
        stepId: { type: "string" },
        description: { type: "string" },
        operationId: { type: "string" },
        operationPath: { type: "string" },
        workflowId: { type: "string" },
        parameters: "Parameters",
        successCriteria: (0, _1.listOf)("CriterionObject"),
        onSuccess: "OnSuccessActionList",
        onFailure: "OnFailureActionList",
        outputs: "Outputs",
        "x-operation": "ExtendedOperation",
        requestBody: "RequestBody"
      },
      required: ["stepId"],
      requiredOneOf: ["x-operation", "operationId", "operationPath", "workflowId"],
      extensionsPrefix: "x-"
    };
    var Outputs = {
      properties: {},
      additionalProperties: {
        type: "string"
      }
    };
    var RequestBody2 = {
      properties: {
        contentType: { type: "string" },
        payload: {},
        replacements: (0, _1.listOf)("Replacement")
      },
      required: ["payload"],
      extensionsPrefix: "x-"
    };
    var Replacement = {
      properties: {
        target: { type: "string" },
        value: {}
      },
      required: ["target", "value"],
      extensionsPrefix: "x-"
    };
    var ExtendedOperation = {
      properties: {
        url: { type: "string" },
        method: {
          enum: [
            "get",
            "post",
            "put",
            "delete",
            "patch",
            "head",
            "options",
            "trace",
            "connect",
            "query",
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH",
            "OPTIONS",
            "HEAD",
            "TRACE",
            "CONNECT",
            "QUERY"
          ]
        }
      },
      required: ["url", "method"]
    };
    var CriterionObject = {
      properties: {
        condition: { type: "string" },
        context: { type: "string" },
        type: (value) => {
          if (!value) {
            return void 0;
          } else if (typeof value === "string") {
            return { enum: ["regex", "jsonpath", "simple", "xpath"] };
          } else if ((value == null ? void 0 : value.type) === "jsonpath") {
            return "JSONPathCriterion";
          } else {
            return "XPathCriterion";
          }
        }
      },
      required: ["condition"]
    };
    var JSONPathCriterion = {
      properties: {
        type: { type: "string", enum: ["jsonpath"] },
        version: { type: "string", enum: ["draft-goessner-dispatch-jsonpath-00"] }
      }
    };
    var XPathCriterion = {
      properties: {
        type: { type: "string", enum: ["xpath"] },
        version: { type: "string", enum: ["xpath-30", "xpath-20", "xpath-10"] }
      }
    };
    var SuccessActionObject = {
      properties: {
        name: { type: "string" },
        type: { type: "string", enum: ["goto", "end"] },
        stepId: { type: "string" },
        workflowId: { type: "string" },
        criteria: (0, _1.listOf)("CriterionObject")
      },
      required: ["type", "name"]
    };
    var OnSuccessActionList = {
      properties: {},
      items: (value) => {
        if ((value == null ? void 0 : value.type) && (value == null ? void 0 : value.name)) {
          return "SuccessActionObject";
        } else {
          return "ReusableObject";
        }
      }
    };
    var FailureActionObject = {
      properties: {
        name: { type: "string" },
        type: { type: "string", enum: ["goto", "retry", "end"] },
        workflowId: { type: "string" },
        stepId: { type: "string" },
        retryAfter: { type: "number" },
        retryLimit: { type: "number" },
        criteria: (0, _1.listOf)("CriterionObject")
      },
      required: ["type", "name"]
    };
    var OnFailureActionList = {
      properties: {},
      items: (value) => {
        if ((value == null ? void 0 : value.type) && (value == null ? void 0 : value.name)) {
          return "FailureActionObject";
        } else {
          return "ReusableObject";
        }
      }
    };
    exports.Arazzo1Types = {
      Root: Root2,
      Info,
      SourceDescriptions,
      OpenAPISourceDescription,
      ArazzoSourceDescription,
      Parameters: Parameters2,
      Parameter,
      ReusableObject,
      Workflows,
      Workflow,
      Steps,
      Step,
      RequestBody: RequestBody2,
      Replacement,
      ExtendedOperation,
      Outputs,
      CriterionObject,
      XPathCriterion,
      JSONPathCriterion,
      SuccessActionObject,
      OnSuccessActionList,
      FailureActionObject,
      OnFailureActionList,
      Schema: oas3_1_1.Schema,
      NamedSchemas: (0, _1.mapOf)("Schema"),
      ExternalDocs: oas3_1.ExternalDocs,
      DiscriminatorMapping: oas3_1.DiscriminatorMapping,
      Discriminator: oas3_1.Discriminator,
      DependentRequired: oas3_1_1.DependentRequired,
      SchemaProperties: oas3_1_1.SchemaProperties,
      PatternProperties: oas3_1_1.SchemaProperties,
      Components,
      NamedInputs,
      NamedParameters,
      NamedSuccessActions,
      NamedFailureActions,
      Xml: oas3_1.Xml
    };
  }
});

// node_modules/@redocly/openapi-core/lib/types/overlay.js
var require_overlay = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/overlay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Overlay1Types = void 0;
    var _1 = require_types();
    var Root2 = {
      properties: {
        overlay: { type: "string" },
        info: "Info",
        extends: { type: "string" },
        actions: "Actions"
      },
      required: ["overlay", "info", "actions"],
      extensionsPrefix: "x-"
    };
    var Info = {
      properties: {
        title: { type: "string" },
        version: { type: "string" }
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    };
    var Actions = (0, _1.listOf)("Action");
    var Action = {
      properties: {
        target: { type: "string" },
        description: { type: "string" },
        update: {},
        // any
        remove: { type: "boolean" }
      },
      required: ["target"],
      extensionsPrefix: "x-"
    };
    exports.Overlay1Types = {
      Root: Root2,
      Info,
      Actions,
      Action
    };
  }
});

// node_modules/@redocly/openapi-core/lib/typings/arazzo.js
var require_arazzo2 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/typings/arazzo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ARAZZO_VERSIONS_SUPPORTED_BY_RESPECT = exports.VERSION_PATTERN = void 0;
    exports.VERSION_PATTERN = /^1\.0\.\d+(-.+)?$/;
    exports.ARAZZO_VERSIONS_SUPPORTED_BY_RESPECT = ["1.0.1"];
  }
});

// node_modules/@redocly/openapi-core/lib/oas-types.js
var require_oas_types = __commonJS({
  "node_modules/@redocly/openapi-core/lib/oas-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpecMajorVersion = exports.SpecVersion = void 0;
    exports.detectSpec = detectSpec;
    exports.getMajorSpecVersion = getMajorSpecVersion;
    exports.getTypes = getTypes;
    var oas2_1 = require_oas2();
    var oas3_1 = require_oas3();
    var oas3_1_1 = require_oas3_1();
    var asyncapi2_1 = require_asyncapi2();
    var asyncapi3_1 = require_asyncapi3();
    var arazzo_1 = require_arazzo();
    var overlay_1 = require_overlay();
    var utils_1 = require_utils();
    var arazzo_2 = require_arazzo2();
    var SpecVersion;
    (function(SpecVersion2) {
      SpecVersion2["OAS2"] = "oas2";
      SpecVersion2["OAS3_0"] = "oas3_0";
      SpecVersion2["OAS3_1"] = "oas3_1";
      SpecVersion2["Async2"] = "async2";
      SpecVersion2["Async3"] = "async3";
      SpecVersion2["Arazzo1"] = "arazzo1";
      SpecVersion2["Overlay1"] = "overlay1";
    })(SpecVersion || (exports.SpecVersion = SpecVersion = {}));
    var SpecMajorVersion;
    (function(SpecMajorVersion2) {
      SpecMajorVersion2["OAS2"] = "oas2";
      SpecMajorVersion2["OAS3"] = "oas3";
      SpecMajorVersion2["Async2"] = "async2";
      SpecMajorVersion2["Async3"] = "async3";
      SpecMajorVersion2["Arazzo1"] = "arazzo1";
      SpecMajorVersion2["Overlay1"] = "overlay1";
    })(SpecMajorVersion || (exports.SpecMajorVersion = SpecMajorVersion = {}));
    var typesMap = {
      [SpecVersion.OAS2]: oas2_1.Oas2Types,
      [SpecVersion.OAS3_0]: oas3_1.Oas3Types,
      [SpecVersion.OAS3_1]: oas3_1_1.Oas3_1Types,
      [SpecVersion.Async2]: asyncapi2_1.AsyncApi2Types,
      [SpecVersion.Async3]: asyncapi3_1.AsyncApi3Types,
      [SpecVersion.Arazzo1]: arazzo_1.Arazzo1Types,
      [SpecVersion.Overlay1]: overlay_1.Overlay1Types
    };
    function detectSpec(root) {
      if (!(0, utils_1.isPlainObject)(root)) {
        throw new Error(`Document must be JSON object, got ${typeof root}`);
      }
      if (root.openapi && typeof root.openapi !== "string") {
        throw new Error(`Invalid OpenAPI version: should be a string but got "${typeof root.openapi}"`);
      }
      if (typeof root.openapi === "string" && root.openapi.startsWith("3.0")) {
        return SpecVersion.OAS3_0;
      }
      if (typeof root.openapi === "string" && root.openapi.startsWith("3.1")) {
        return SpecVersion.OAS3_1;
      }
      if (root.swagger && root.swagger === "2.0") {
        return SpecVersion.OAS2;
      }
      if (root.openapi || root.swagger) {
        throw new Error(`Unsupported OpenAPI version: ${root.openapi || root.swagger}`);
      }
      if (typeof root.asyncapi === "string" && root.asyncapi.startsWith("2.")) {
        return SpecVersion.Async2;
      }
      if (typeof root.asyncapi === "string" && root.asyncapi.startsWith("3.")) {
        return SpecVersion.Async3;
      }
      if (root.asyncapi) {
        throw new Error(`Unsupported AsyncAPI version: ${root.asyncapi}`);
      }
      if (typeof root.arazzo === "string" && arazzo_2.VERSION_PATTERN.test(root.arazzo)) {
        return SpecVersion.Arazzo1;
      }
      if (typeof root.overlay === "string" && arazzo_2.VERSION_PATTERN.test(root.overlay)) {
        return SpecVersion.Overlay1;
      }
      throw new Error(`Unsupported specification`);
    }
    function getMajorSpecVersion(version) {
      if (version === SpecVersion.OAS2) {
        return SpecMajorVersion.OAS2;
      } else if (version === SpecVersion.Async2) {
        return SpecMajorVersion.Async2;
      } else if (version === SpecVersion.Async3) {
        return SpecMajorVersion.Async3;
      } else if (version === SpecVersion.Arazzo1) {
        return SpecMajorVersion.Arazzo1;
      } else if (version === SpecVersion.Overlay1) {
        return SpecMajorVersion.Overlay1;
      } else {
        return SpecMajorVersion.OAS3;
      }
    }
    function getTypes(spec) {
      return typesMap[spec];
    }
  }
});

// node_modules/@redocly/openapi-core/lib/config/rules.js
var require_rules = __commonJS({
  "node_modules/@redocly/openapi-core/lib/config/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initRules = initRules;
    var utils_1 = require_utils();
    function initRules(rules, config3, type, oasVersion) {
      return rules.flatMap((ruleset) => Object.keys(ruleset).map((ruleId) => {
        const rule = ruleset[ruleId];
        const ruleSettings = type === "rules" ? config3.getRuleSettings(ruleId, oasVersion) : type === "preprocessors" ? config3.getPreprocessorSettings(ruleId, oasVersion) : config3.getDecoratorSettings(ruleId, oasVersion);
        if (ruleSettings.severity === "off") {
          return void 0;
        }
        const severity = ruleSettings.severity;
        const message = ruleSettings.message;
        const visitors = rule(ruleSettings);
        if (Array.isArray(visitors)) {
          return visitors.map((visitor) => ({
            severity,
            ruleId,
            message,
            visitor
          }));
        }
        return {
          severity,
          message,
          ruleId,
          visitor: visitors
          // note: actually it is only one visitor object
        };
      })).flatMap((visitor) => visitor).filter(utils_1.isDefined);
    }
  }
});

// node_modules/@redocly/openapi-core/lib/rules/no-unresolved-refs.js
var require_no_unresolved_refs = __commonJS({
  "node_modules/@redocly/openapi-core/lib/rules/no-unresolved-refs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoUnresolvedRefs = void 0;
    exports.reportUnresolvedRef = reportUnresolvedRef;
    var resolve_1 = require_resolve();
    var NoUnresolvedRefs = () => {
      return {
        ref: {
          leave(_, { report, location }, resolved) {
            if (resolved.node !== void 0)
              return;
            reportUnresolvedRef(resolved, report, location);
          }
        },
        DiscriminatorMapping(mapping, { report, resolve, location }) {
          for (const mappingName of Object.keys(mapping)) {
            const resolved = resolve({ $ref: mapping[mappingName] });
            if (resolved.node !== void 0)
              return;
            reportUnresolvedRef(resolved, report, location.child(mappingName));
          }
        }
      };
    };
    exports.NoUnresolvedRefs = NoUnresolvedRefs;
    function reportUnresolvedRef(resolved, report, location) {
      var _a2;
      const error = resolved.error;
      if (error instanceof resolve_1.YamlParseError) {
        report({
          message: "Failed to parse: " + error.message,
          location: {
            source: error.source,
            pointer: void 0,
            start: {
              col: error.col,
              line: error.line
            }
          }
        });
      }
      const message = (_a2 = resolved.error) == null ? void 0 : _a2.message;
      report({
        location,
        message: `Can't resolve $ref${message ? ": " + message : ""}`
      });
    }
  }
});

// node_modules/@redocly/openapi-core/lib/redocly/domains.js
var require_domains = __commonJS({
  "node_modules/@redocly/openapi-core/lib/redocly/domains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AVAILABLE_REGIONS = exports.DOMAINS = exports.DEFAULT_REGION = void 0;
    exports.getDomains = getDomains;
    exports.setRedoclyDomain = setRedoclyDomain;
    exports.getRedoclyDomain = getRedoclyDomain;
    exports.isRedoclyRegistryURL = isRedoclyRegistryURL;
    var redoclyDomain = "redocly.com";
    exports.DEFAULT_REGION = "us";
    exports.DOMAINS = getDomains();
    exports.AVAILABLE_REGIONS = Object.keys(exports.DOMAINS);
    function getDomains() {
      const domains = {
        us: "redocly.com",
        eu: "eu.redocly.com"
      };
      const domain2 = redoclyDomain;
      if (domain2 == null ? void 0 : domain2.endsWith(".redocly.host")) {
        domains[domain2.split(".")[0]] = domain2;
      }
      if (domain2 === "redoc.online") {
        domains[domain2] = domain2;
      }
      return domains;
    }
    function setRedoclyDomain(domain2) {
      redoclyDomain = domain2;
    }
    function getRedoclyDomain() {
      return redoclyDomain;
    }
    function isRedoclyRegistryURL(link) {
      const domain2 = getRedoclyDomain() || exports.DOMAINS[exports.DEFAULT_REGION];
      const legacyDomain = domain2 === "redocly.com" ? "redoc.ly" : domain2;
      if (!link.startsWith(`https://api.${domain2}/registry/`) && !link.startsWith(`https://api.${legacyDomain}/registry/`)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@redocly/openapi-core/lib/decorators/oas2/remove-unused-components.js
var require_remove_unused_components = __commonJS({
  "node_modules/@redocly/openapi-core/lib/decorators/oas2/remove-unused-components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoveUnusedComponents = void 0;
    var utils_1 = require_utils();
    var RemoveUnusedComponents = () => {
      const components = /* @__PURE__ */ new Map();
      function registerComponent(location, componentType, name2) {
        var _a2, _b;
        components.set(location.absolutePointer, {
          usedIn: (_b = (_a2 = components.get(location.absolutePointer)) == null ? void 0 : _a2.usedIn) != null ? _b : [],
          componentType,
          name: name2
        });
      }
      function removeUnusedComponents(root, removedPaths) {
        const removedLengthStart = removedPaths.length;
        for (const [path, { usedIn, name: name2, componentType }] of components) {
          const used = usedIn.some((location) => !removedPaths.some((removed) => (
            // Check if the current location's absolute pointer starts with the 'removed' path
            // and either its length matches exactly with 'removed' or the character after the 'removed' path is a '/'
            location.absolutePointer.startsWith(removed) && (location.absolutePointer.length === removed.length || location.absolutePointer[removed.length] === "/")
          )));
          if (!used && componentType) {
            removedPaths.push(path);
            delete root[componentType][name2];
            components.delete(path);
            if ((0, utils_1.isEmptyObject)(root[componentType])) {
              delete root[componentType];
            }
          }
        }
        return removedPaths.length > removedLengthStart ? removeUnusedComponents(root, removedPaths) : removedPaths.length;
      }
      return {
        ref: {
          leave(ref, { location, type, resolve, key: key2 }) {
            if (["Schema", "Parameter", "Response", "SecurityScheme"].includes(type.name)) {
              const resolvedRef = resolve(ref);
              if (!resolvedRef.location)
                return;
              const [fileLocation, localPointer] = resolvedRef.location.absolutePointer.split("#", 2);
              const componentLevelLocalPointer = localPointer.split("/").slice(0, 3).join("/");
              const pointer = `${fileLocation}#${componentLevelLocalPointer}`;
              const registered = components.get(pointer);
              if (registered) {
                registered.usedIn.push(location);
              } else {
                components.set(pointer, {
                  usedIn: [location],
                  name: key2.toString()
                });
              }
            }
          }
        },
        Root: {
          leave(root, ctx) {
            const data = ctx.getVisitorData();
            data.removedCount = removeUnusedComponents(root, []);
          }
        },
        NamedSchemas: {
          Schema(schema, { location, key: key2 }) {
            if (!schema.allOf) {
              registerComponent(location, "definitions", key2.toString());
            }
          }
        },
        NamedParameters: {
          Parameter(_parameter, { location, key: key2 }) {
            registerComponent(location, "parameters", key2.toString());
          }
        },
        NamedResponses: {
          Response(_response, { location, key: key2 }) {
            registerComponent(location, "responses", key2.toString());
          }
        },
        NamedSecuritySchemes: {
          SecurityScheme(_securityScheme, { location, key: key2 }) {
            registerComponent(location, "securityDefinitions", key2.toString());
          }
        }
      };
    };
    exports.RemoveUnusedComponents = RemoveUnusedComponents;
  }
});

// node_modules/@redocly/openapi-core/lib/decorators/oas3/remove-unused-components.js
var require_remove_unused_components2 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/decorators/oas3/remove-unused-components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoveUnusedComponents = void 0;
    var utils_1 = require_utils();
    var RemoveUnusedComponents = () => {
      const components = /* @__PURE__ */ new Map();
      function registerComponent(location, componentType, name2) {
        var _a2, _b;
        components.set(location.absolutePointer, {
          usedIn: (_b = (_a2 = components.get(location.absolutePointer)) == null ? void 0 : _a2.usedIn) != null ? _b : [],
          componentType,
          name: name2
        });
      }
      function removeUnusedComponents(root, removedPaths) {
        const removedLengthStart = removedPaths.length;
        for (const [path, { usedIn, name: name2, componentType }] of components) {
          const used = usedIn.some((location) => !removedPaths.some((removed) => location.absolutePointer.startsWith(removed) && (location.absolutePointer.length === removed.length || location.absolutePointer[removed.length] === "/")));
          if (!used && componentType && root.components) {
            removedPaths.push(path);
            const componentChild = root.components[componentType];
            delete componentChild[name2];
            components.delete(path);
            if ((0, utils_1.isEmptyObject)(componentChild)) {
              delete root.components[componentType];
            }
          }
        }
        return removedPaths.length > removedLengthStart ? removeUnusedComponents(root, removedPaths) : removedPaths.length;
      }
      return {
        ref: {
          leave(ref, { location, type, resolve, key: key2 }) {
            if (["Schema", "Header", "Parameter", "Response", "Example", "RequestBody"].includes(type.name)) {
              const resolvedRef = resolve(ref);
              if (!resolvedRef.location)
                return;
              const [fileLocation, localPointer] = resolvedRef.location.absolutePointer.split("#", 2);
              const componentLevelLocalPointer = localPointer.split("/").slice(0, 4).join("/");
              const pointer = `${fileLocation}#${componentLevelLocalPointer}`;
              const registered = components.get(pointer);
              if (registered) {
                registered.usedIn.push(location);
              } else {
                components.set(pointer, {
                  usedIn: [location],
                  name: key2.toString()
                });
              }
            }
          }
        },
        Root: {
          leave(root, ctx) {
            const data = ctx.getVisitorData();
            data.removedCount = removeUnusedComponents(root, []);
            if ((0, utils_1.isEmptyObject)(root.components)) {
              delete root.components;
            }
          }
        },
        NamedSchemas: {
          Schema(schema, { location, key: key2 }) {
            if (!schema.allOf) {
              registerComponent(location, "schemas", key2.toString());
            }
          }
        },
        NamedParameters: {
          Parameter(_parameter, { location, key: key2 }) {
            registerComponent(location, "parameters", key2.toString());
          }
        },
        NamedResponses: {
          Response(_response, { location, key: key2 }) {
            registerComponent(location, "responses", key2.toString());
          }
        },
        NamedExamples: {
          Example(_example, { location, key: key2 }) {
            registerComponent(location, "examples", key2.toString());
          }
        },
        NamedRequestBodies: {
          RequestBody(_requestBody, { location, key: key2 }) {
            registerComponent(location, "requestBodies", key2.toString());
          }
        },
        NamedHeaders: {
          Header(_header, { location, key: key2 }) {
            registerComponent(location, "headers", key2.toString());
          }
        }
      };
    };
    exports.RemoveUnusedComponents = RemoveUnusedComponents;
  }
});

// node_modules/@redocly/config/lib/feedback-config-schema.js
var require_feedback_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/feedback-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feedbackConfigSchema = exports.optionalEmailSettings = exports.reasonsSettings = void 0;
    var reasonsBaseProperties = {
      hide: {
        type: "boolean",
        default: false
      },
      component: {
        type: "string",
        enum: ["radio", "checkbox"],
        default: "checkbox"
      },
      label: { type: "string" },
      items: { type: "array", items: { type: "string" } }
    };
    exports.reasonsSettings = {
      type: "object",
      properties: reasonsBaseProperties,
      additionalProperties: false
    };
    exports.optionalEmailSettings = {
      type: "object",
      properties: {
        hide: {
          type: "boolean",
          default: false
        },
        label: { type: "string" },
        placeholder: { type: "string" }
      },
      additionalProperties: false
    };
    exports.feedbackConfigSchema = {
      type: "object",
      properties: {
        hide: {
          type: "boolean",
          default: false
        },
        type: {
          type: "string",
          enum: ["rating", "sentiment", "comment", "reasons", "mood", "scale"],
          default: "sentiment"
        },
        settings: {
          type: "object",
          properties: {
            label: { type: "string" },
            submitText: { type: "string" },
            buttonText: { type: "string" },
            component: {
              type: "string",
              enum: ["radio", "checkbox"],
              default: "checkbox"
            },
            items: { type: "array", items: { type: "string" }, minItems: 1 },
            leftScaleLabel: { type: "string" },
            rightScaleLabel: { type: "string" },
            reasons: {
              type: "object",
              properties: Object.assign(Object.assign({}, reasonsBaseProperties), { like: exports.reasonsSettings, dislike: exports.reasonsSettings, satisfied: exports.reasonsSettings, neutral: exports.reasonsSettings, dissatisfied: exports.reasonsSettings }),
              additionalProperties: false
            },
            comment: {
              type: "object",
              properties: {
                hide: {
                  type: "boolean",
                  default: false
                },
                label: { type: "string" },
                likeLabel: { type: "string" },
                dislikeLabel: { type: "string" },
                satisfiedLabel: { type: "string" },
                neutralLabel: { type: "string" },
                dissatisfiedLabel: { type: "string" }
              },
              additionalProperties: false
            },
            optionalEmail: exports.optionalEmailSettings
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/@redocly/config/lib/graphql-config-schema.js
var require_graphql_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/graphql-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.graphqlConfigSchema = void 0;
    var feedback_config_schema_1 = require_feedback_config_schema();
    var typeGroupConfig = {
      type: "object",
      properties: {
        includeByName: {
          type: "array",
          items: {
            type: "string"
          }
        },
        excludeByName: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    };
    var menuGroupConfig = {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        items: typeGroupConfig,
        queries: typeGroupConfig,
        mutations: typeGroupConfig,
        subscriptions: typeGroupConfig,
        types: typeGroupConfig,
        directives: typeGroupConfig
      },
      required: ["name"],
      additionalProperties: false
    };
    var menuGroupingConfig = {
      type: "object",
      properties: {
        requireExactGroups: {
          type: "boolean"
        },
        groups: {
          type: "array",
          items: menuGroupConfig
        },
        otherItemsGroupName: {
          type: "string"
        }
      },
      required: ["requireExactGroups", "groups", "otherItemsGroupName"],
      additionalProperties: false
    };
    exports.graphqlConfigSchema = {
      type: "object",
      properties: {
        hidePaginationButtons: {
          type: "boolean"
        },
        menu: {
          type: "object",
          properties: Object.assign({}, menuGroupingConfig.properties),
          additionalProperties: false
        },
        sidebar: {
          type: "object",
          properties: {
            hide: {
              type: "boolean"
            }
          }
        },
        apiLogo: {
          type: "object",
          properties: {
            imageUrl: {
              type: "string"
            },
            href: {
              type: "string"
            },
            altText: {
              type: "string"
            },
            backgroundColor: {
              type: "string"
            }
          }
        },
        jsonSamplesDepth: {
          type: "number"
        },
        samplesMaxInlineArgs: {
          type: "number"
        },
        licenseKey: {
          type: "string"
        },
        fieldExpandLevel: {
          type: "number"
        },
        baseUrlPath: {
          type: "string"
        },
        feedback: feedback_config_schema_1.feedbackConfigSchema
      },
      additionalProperties: false
    };
  }
});

// node_modules/@redocly/config/lib/redoc-config-schema.js
var require_redoc_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/redoc-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.redocConfigSchema = void 0;
    var feedback_config_schema_1 = require_feedback_config_schema();
    var codeSamplesConfigSchema = {
      type: "object",
      properties: {
        languages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              lang: {
                type: "string",
                enum: [
                  "curl",
                  "JavaScript",
                  "Node.js",
                  "Python",
                  "Java8+Apache",
                  "Java",
                  "C#",
                  "C#+Newtonsoft",
                  "PHP",
                  "Go",
                  "Ruby",
                  "R",
                  "Payload"
                ]
              },
              label: { type: "string" },
              options: {
                type: "object",
                properties: {
                  indent: { type: "string" },
                  withImports: { type: "boolean" },
                  withComments: { type: "boolean" },
                  binary: { type: "boolean" },
                  credentials: {
                    type: "string",
                    enum: ["omit", "same-origin", "include"]
                  }
                },
                additionalProperties: false
              }
            },
            required: ["lang"],
            additionalProperties: false
          }
        },
        skipOptionalParameters: { type: "boolean" },
        withOAuth2Call: { type: "boolean" }
      },
      required: ["languages"],
      additionalProperties: false
    };
    var downloadUrlsSchema = {
      type: "array",
      items: {
        type: "object",
        properties: {
          title: { type: "string" },
          url: { type: "string" }
        },
        required: ["url"],
        additionalProperties: false
      }
    };
    exports.redocConfigSchema = {
      type: "object",
      properties: {
        licenseKey: { type: "string" },
        hideLoading: { type: "boolean" },
        disableRouter: { type: "boolean" },
        hideSidebar: { type: "boolean" },
        feedback: feedback_config_schema_1.feedbackConfigSchema,
        hideReplay: { type: "boolean" },
        oAuth2RedirectURI: { type: "string", nullable: true },
        corsProxyUrl: { type: "string" },
        sortRequiredPropsFirst: { type: "boolean" },
        sanitize: { type: "boolean" },
        hideDownloadButtons: { type: "boolean" },
        downloadUrls: downloadUrlsSchema,
        onlyRequiredInSamples: { type: "boolean" },
        generatedSamplesMaxDepth: { oneOf: [{ type: "number" }, { type: "string" }] },
        showExtensions: {
          oneOf: [
            { type: "boolean" },
            { type: "string" },
            { type: "array", items: { type: "string" } }
          ]
        },
        hideSchemaTitles: { type: "boolean" },
        jsonSamplesExpandLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
        schemasExpansionLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
        mockServer: {
          type: "object",
          properties: {
            url: { type: "string" },
            position: { type: "string", enum: ["first", "last", "replace", "off"] },
            description: { type: "string" }
          }
        },
        maxDisplayedEnumValues: { type: "number" },
        schemaDefinitionsTagName: { type: "string" },
        layout: { type: "string", enum: ["stacked", "three-panel"] },
        hideInfoMetadata: { type: "boolean" },
        events: { type: "object" },
        skipBundle: { type: "boolean" },
        routingBasePath: { type: "string" },
        codeSamples: codeSamplesConfigSchema,
        ignoreNamedSchemas: {
          oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
        },
        hidePropertiesPrefix: { type: "boolean" },
        excludeFromSearch: { type: "boolean" }
      },
      additionalProperties: false
    };
  }
});

// node_modules/@redocly/config/lib/reference-docs-config-schema.js
var require_reference_docs_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/reference-docs-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deprecatedRefDocsSchema = void 0;
    var ConfigLanguage = {
      type: "object",
      properties: {
        label: { type: "string" },
        lang: {
          enum: [
            "curl",
            "C#",
            "Go",
            "Java",
            "Java8+Apache",
            "JavaScript",
            "Node.js",
            "PHP",
            "Python",
            "R",
            "Ruby"
          ]
        }
      },
      required: ["lang"]
    };
    var ConfigLabels = {
      type: "object",
      properties: {
        enum: { type: "string" },
        enumSingleValue: { type: "string" },
        enumArray: { type: "string" },
        default: { type: "string" },
        deprecated: { type: "string" },
        example: { type: "string" },
        examples: { type: "string" },
        nullable: { type: "string" },
        recursive: { type: "string" },
        arrayOf: { type: "string" },
        webhook: { type: "string" },
        authorizations: { type: "string" },
        tryItAuthBasicUsername: { type: "string" },
        tryItAuthBasicPassword: { type: "string" }
      }
    };
    var CommonConfigSidebarLinks = {
      type: "object",
      properties: {
        label: { type: "string" },
        link: { type: "string" },
        target: { type: "string" }
      },
      required: ["label", "link"]
    };
    var ConfigSidebarLinks = {
      type: "object",
      properties: {
        beforeInfo: { type: "array", items: CommonConfigSidebarLinks },
        end: { type: "array", items: CommonConfigSidebarLinks }
      }
    };
    var CommonThemeColors = {
      type: "object",
      properties: {
        main: { type: "string" },
        light: { type: "string" },
        dark: { type: "string" },
        contrastText: { type: "string" }
      }
    };
    var CommonColorProps = {
      type: "object",
      properties: {
        backgroundColor: { type: "string" },
        borderColor: { type: "string" },
        color: { type: "string" },
        tabTextColor: { type: "string" }
      }
    };
    var BorderThemeColors = {
      type: "object",
      properties: pickObjectProps(CommonThemeColors.properties, ["light", "dark"])
    };
    var HttpColors = {
      type: "object",
      properties: {
        basic: { type: "string" },
        delete: { type: "string" },
        get: { type: "string" },
        head: { type: "string" },
        link: { type: "string" },
        options: { type: "string" },
        patch: { type: "string" },
        post: { type: "string" },
        put: { type: "string" }
      }
    };
    var ResponseColors = {
      type: "object",
      properties: {
        error: CommonColorProps,
        info: CommonColorProps,
        redirect: CommonColorProps,
        success: CommonColorProps
      }
    };
    var SecondaryColors = {
      type: "object",
      properties: omitObjectProps(CommonThemeColors.properties, ["dark"])
    };
    var TextThemeColors = {
      type: "object",
      properties: {
        primary: { type: "string" },
        secondary: { type: "string" },
        light: { type: "string" }
      }
    };
    var ThemeColors = {
      type: "object",
      properties: {
        accent: CommonThemeColors,
        border: BorderThemeColors,
        error: CommonThemeColors,
        http: HttpColors,
        primary: CommonThemeColors,
        responses: ResponseColors,
        secondary: SecondaryColors,
        success: CommonThemeColors,
        text: TextThemeColors,
        tonalOffset: { type: "number" },
        warning: CommonThemeColors
      }
    };
    var SizeProps = {
      type: "object",
      properties: {
        fontSize: { type: "string" },
        padding: { type: "string" },
        minWidth: { type: "string" }
      }
    };
    var Sizes = {
      type: "object",
      properties: {
        small: SizeProps,
        medium: SizeProps,
        large: SizeProps,
        xlarge: SizeProps
      }
    };
    var FontConfig = {
      type: "object",
      properties: {
        fontFamily: { type: "string" },
        fontSize: { type: "string" },
        fontWeight: { type: "string" },
        lineHeight: { type: "string" }
      }
    };
    var ButtonsConfig = {
      type: "object",
      properties: Object.assign(Object.assign({}, omitObjectProps(FontConfig.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, hoverStyle: { type: "string" }, boxShadow: { type: "string" }, hoverBoxShadow: { type: "string" }, sizes: Sizes })
    };
    var BadgeFontConfig = {
      type: "object",
      properties: pickObjectProps(FontConfig.properties, ["fontSize", "lineHeight"])
    };
    var BadgeSizes = {
      type: "object",
      properties: {
        medium: BadgeFontConfig,
        small: BadgeFontConfig
      }
    };
    var HttpBadgesConfig = {
      type: "object",
      properties: Object.assign(Object.assign({}, omitObjectProps(FontConfig.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, color: { type: "string" }, sizes: BadgeSizes })
    };
    var LabelControls = {
      type: "object",
      properties: {
        top: { type: "string" },
        width: { type: "string" },
        height: { type: "string" }
      }
    };
    var Panels = {
      type: "object",
      properties: {
        borderRadius: { type: "string" },
        backgroundColor: { type: "string" }
      }
    };
    var TryItButton2 = {
      type: "object",
      properties: {
        fullWidth: { type: "boolean" }
      }
    };
    var ConfigThemeComponents = {
      type: "object",
      properties: {
        buttons: ButtonsConfig,
        httpBadges: HttpBadgesConfig,
        layoutControls: LabelControls,
        panels: Panels,
        tryItButton: TryItButton2,
        tryItSendButton: TryItButton2
      }
    };
    var Breakpoints = {
      type: "object",
      properties: {
        small: { type: "string" },
        medium: { type: "string" },
        large: { type: "string" }
      }
    };
    var StackedConfig = {
      type: "object",
      properties: {
        maxWidth: Breakpoints
      }
    };
    var ThreePanelConfig = {
      type: "object",
      properties: {
        maxWidth: Breakpoints,
        middlePanelMaxWidth: Breakpoints
      }
    };
    var Layout = {
      type: "object",
      properties: {
        showDarkRightPanel: { type: "boolean" },
        stacked: StackedConfig,
        "three-panel": ThreePanelConfig
      }
    };
    var SchemaColorsConfig = {
      type: "object",
      properties: {
        backgroundColor: { type: "string" },
        border: { type: "string" }
      }
    };
    var ConfigThemeSchema = {
      type: "object",
      properties: {
        breakFieldNames: { type: "boolean" },
        caretColor: { type: "string" },
        caretSize: { type: "string" },
        constraints: SchemaColorsConfig,
        defaultDetailsWidth: { type: "string" },
        examples: SchemaColorsConfig,
        labelsTextSize: { type: "string" },
        linesColor: { type: "string" },
        nestedBackground: { type: "string" },
        nestingSpacing: { type: "string" },
        requireLabelColor: { type: "string" },
        typeNameColor: { type: "string" },
        typeTitleColor: { type: "string" }
      }
    };
    var GroupItemsConfig = {
      type: "object",
      properties: {
        subItemsColor: { type: "string" },
        textTransform: { type: "string" },
        fontWeight: { type: "string" }
      }
    };
    var Level1Items = {
      type: "object",
      properties: pickObjectProps(GroupItemsConfig.properties, ["textTransform"])
    };
    var SpacingConfig = {
      type: "object",
      properties: {
        unit: { type: "number" },
        paddingHorizontal: { type: "string" },
        paddingVertical: { type: "string" },
        offsetTop: { type: "string" },
        offsetLeft: { type: "string" },
        offsetNesting: { type: "string" }
      }
    };
    var Sidebar = {
      type: "object",
      properties: Object.assign(Object.assign({}, omitObjectProps(FontConfig.properties, ["fontWeight", "lineHeight"])), { activeBgColor: { type: "string" }, activeTextColor: { type: "string" }, backgroundColor: { type: "string" }, borderRadius: { type: "string" }, breakPath: { type: "boolean" }, caretColor: { type: "string" }, caretSize: { type: "string" }, groupItems: GroupItemsConfig, level1items: Level1Items, rightLineColor: { type: "string" }, separatorLabelColor: { type: "string" }, showAtBreakpoint: { type: "string" }, spacing: SpacingConfig, textColor: { type: "string" }, width: { type: "string" } })
    };
    var Heading = {
      type: "object",
      properties: Object.assign(Object.assign({}, FontConfig.properties), { color: { type: "string" }, transform: { type: "string" } })
    };
    var CodeConfig = {
      type: "object",
      properties: Object.assign(Object.assign({}, FontConfig.properties), { backgroundColor: { type: "string" }, color: { type: "string" }, wordBreak: {
        type: "string",
        enum: [
          "break-all",
          "break-word",
          "keep-all",
          "normal",
          "revert",
          "unset",
          "inherit",
          "initial"
        ]
      }, wrap: { type: "boolean" } })
    };
    var HeadingsConfig = {
      type: "object",
      properties: omitObjectProps(FontConfig.properties, ["fontSize"])
    };
    var LinksConfig = {
      type: "object",
      properties: {
        color: { type: "string" },
        hover: { type: "string" },
        textDecoration: { type: "string" },
        hoverTextDecoration: { type: "string" },
        visited: { type: "string" }
      }
    };
    var Typography = {
      type: "object",
      properties: Object.assign(Object.assign({ code: CodeConfig, fieldName: FontConfig }, pickObjectProps(FontConfig.properties, ["fontSize", "fontFamily"])), { fontWeightBold: { type: "string" }, fontWeightLight: { type: "string" }, fontWeightRegular: { type: "string" }, heading1: Heading, heading2: Heading, heading3: Heading, headings: HeadingsConfig, lineHeight: { type: "string" }, links: LinksConfig, optimizeSpeed: { type: "boolean" }, rightPanelHeading: Heading, smoothing: {
        type: "string",
        enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"]
      } })
    };
    var TokenProps = {
      type: "object",
      properties: Object.assign({ color: { type: "string" } }, omitObjectProps(FontConfig.properties, ["fontWeight"]))
    };
    var CodeBlock = {
      type: "object",
      properties: {
        backgroundColor: { type: "string" },
        borderRadius: { type: "string" },
        tokens: TokenProps
      }
    };
    var ConfigThemeLogo = {
      type: "object",
      properties: {
        gutter: { type: "string" },
        maxHeight: { type: "string" },
        maxWidth: { type: "string" }
      }
    };
    var Fab = {
      type: "object",
      properties: {
        backgroundColor: { type: "string" },
        color: { type: "string" }
      }
    };
    var ButtonOverrides = {
      type: "object",
      properties: {
        custom: { type: "string" }
      }
    };
    var Overrides = {
      type: "object",
      properties: {
        DownloadButton: ButtonOverrides,
        NextSectionButton: ButtonOverrides
      }
    };
    var RightPanel2 = {
      type: "object",
      properties: {
        backgroundColor: { type: "string" },
        panelBackgroundColor: { type: "string" },
        panelControlsBackgroundColor: { type: "string" },
        showAtBreakpoint: { type: "string" },
        textColor: { type: "string" },
        width: { type: "string" }
      }
    };
    var Shape = {
      type: "object",
      properties: { borderRadius: { type: "string" } }
    };
    var ThemeSpacing = {
      type: "object",
      properties: {
        sectionHorizontal: { type: "number" },
        sectionVertical: { type: "number" },
        unit: { type: "number" }
      }
    };
    var ConfigTheme = {
      type: "object",
      properties: {
        breakpoints: Breakpoints,
        codeBlock: CodeBlock,
        colors: ThemeColors,
        components: ConfigThemeComponents,
        layout: Layout,
        logo: ConfigThemeLogo,
        fab: Fab,
        overrides: Overrides,
        rightPanel: RightPanel2,
        schema: ConfigThemeSchema,
        shape: Shape,
        sidebar: Sidebar,
        spacing: ThemeSpacing,
        typography: Typography,
        links: { properties: { color: { type: "string" } } },
        codeSample: { properties: { backgroundColor: { type: "string" } } }
      }
    };
    var GenerateCodeSamples = {
      type: "object",
      properties: {
        skipOptionalParameters: { type: "boolean" },
        languages: { type: "array", items: ConfigLanguage }
      },
      required: ["languages"]
    };
    exports.deprecatedRefDocsSchema = {
      type: "object",
      properties: {
        theme: ConfigTheme,
        ctrlFHijack: { type: "boolean" },
        defaultSampleLanguage: { type: "string" },
        disableDeepLinks: { type: "boolean" },
        disableSearch: { type: "boolean" },
        disableSidebar: { type: "boolean" },
        downloadDefinitionUrl: { type: "string" },
        expandDefaultServerVariables: { type: "boolean" },
        enumSkipQuotes: { type: "boolean" },
        expandDefaultRequest: { type: "boolean" },
        expandDefaultResponse: { type: "boolean" },
        expandResponses: { type: "string" },
        expandSingleSchemaField: { type: "boolean" },
        generateCodeSamples: GenerateCodeSamples,
        generatedPayloadSamplesMaxDepth: { type: "number" },
        hideDownloadButton: { type: "boolean" },
        hideHostname: { type: "boolean" },
        hideInfoSection: { type: "boolean" },
        hideLogo: { type: "boolean" },
        hideRequestPayloadSample: { type: "boolean" },
        hideRightPanel: { type: "boolean" },
        hideSchemaPattern: { type: "boolean" },
        hideSingleRequestSampleTab: { type: "boolean" },
        hideSecuritySection: { type: "boolean" },
        hideTryItPanel: { type: "boolean" },
        hideFab: { type: "boolean" },
        hideOneOfDescription: { type: "boolean" },
        htmlTemplate: { type: "string" },
        jsonSampleExpandLevel: {
          oneOf: [{ type: "number", minimum: 1 }, { type: "string" }]
        },
        labels: ConfigLabels,
        menuToggle: { type: "boolean" },
        nativeScrollbars: { type: "boolean" },
        noAutoAuth: { type: "boolean" },
        onDeepLinkClick: { type: "object" },
        pagination: { enum: ["none", "section", "item"] },
        pathInMiddlePanel: { type: "boolean" },
        payloadSampleIdx: { type: "number", minimum: 0 },
        requestInterceptor: { type: "object" },
        requiredPropsFirst: { type: "boolean" },
        routingStrategy: { type: "string" },
        samplesTabsMaxCount: { type: "number" },
        schemaExpansionLevel: {
          oneOf: [{ type: "number", minimum: 0 }, { type: "string" }]
        },
        minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
        maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
        scrollYOffset: {
          oneOf: [{ type: "number" }, { type: "string" }]
        },
        searchAutoExpand: { type: "boolean" },
        searchFieldLevelBoost: { type: "number", minimum: 0 },
        searchMaxDepth: { type: "number", minimum: 1 },
        searchMode: { type: "string", enum: ["default", "path-only"] },
        searchOperationTitleBoost: { type: "number" },
        searchTagTitleBoost: { type: "number" },
        sendXUserAgentInTryIt: { type: "boolean" },
        showChangeLayoutButton: { type: "boolean" },
        showConsole: { type: "boolean" },
        showNextButton: { type: "boolean" },
        showRightPanelToggle: { type: "boolean" },
        showSecuritySchemeType: { type: "boolean" },
        showWebhookVerb: { type: "boolean" },
        showObjectSchemaExamples: { type: "boolean" },
        disableTryItRequestUrlEncoding: { type: "boolean" },
        sidebarLinks: ConfigSidebarLinks,
        sideNavStyle: { type: "string", enum: ["summary-only", "path-first", "id-only", "path-only"] },
        simpleOneOfTypeLabel: { type: "boolean" },
        sortEnumValuesAlphabetically: { type: "boolean" },
        sortOperationsAlphabetically: { type: "boolean" },
        sortPropsAlphabetically: { type: "boolean" },
        sortTagsAlphabetically: { type: "boolean" },
        suppressWarnings: { type: "boolean" },
        unstable_externalDescription: { type: "boolean" },
        unstable_ignoreMimeParameters: { type: "boolean" },
        untrustedDefinition: { type: "boolean" },
        showAccessMode: { type: "boolean" },
        preserveOriginalExtensionsName: { type: "boolean" },
        markdownHeadingsAnchorLevel: { type: "number" }
      },
      additionalProperties: false
    };
    function pickObjectProps(object, keys2) {
      return Object.fromEntries(keys2.filter((key2) => key2 in object).map((key2) => [key2, object[key2]]));
    }
    function omitObjectProps(object, keys2) {
      return Object.fromEntries(Object.entries(object).filter(([key2]) => !keys2.includes(key2)));
    }
  }
});

// node_modules/@redocly/config/lib/ex-theme-config-schemas.js
var require_ex_theme_config_schemas = __commonJS({
  "node_modules/@redocly/config/lib/ex-theme-config-schemas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scorecardConfigSchema = exports.catalogsConfigSchema = exports.catalogSchema = exports.catalogFilterSchema = exports.breadcrumbsConfigSchema = exports.versionPickerConfigSchema = exports.userMenuConfigSchema = exports.analyticsConfigSchema = exports.googleAnalyticsConfigSchema = exports.productGoogleAnalyticsConfigSchema = exports.gtmAnalyticsConfigSchema = exports.segmentAnalyticsConfigSchema = exports.rudderstackAnalyticsConfigSchema = exports.heapAnalyticsConfigSchema = exports.fullstoryAnalyticsConfigSchema = exports.amplitudeAnalyticsConfigSchema = exports.openapiConfigSchema = exports.markdownConfigSchema = exports.codeSnippetConfigSchema = exports.navigationConfigSchema = exports.colorModeConfigSchema = exports.searchConfigSchema = exports.linksConfigSchema = exports.scriptsConfigSchema = exports.sidebarConfigSchema = exports.footerConfigSchema = exports.productsConfigSchema = exports.navbarConfigSchema = exports.logoConfigSchema = exports.searchFiltersConfigSchema = exports.searchFacetsConfigSchema = exports.aiSearchConfigSchema = exports.productConfigSchema = exports.navItemsSchema = void 0;
    var redoc_config_schema_1 = require_redoc_config_schema();
    var reference_docs_config_schema_1 = require_reference_docs_config_schema();
    var hideConfigSchema = {
      type: "object",
      properties: {
        hide: { type: "boolean" }
      },
      additionalProperties: false
    };
    var scriptConfigSchema = {
      type: "object",
      properties: {
        src: { type: "string" },
        async: { type: "boolean" },
        crossorigin: { type: "string" },
        defer: { type: "boolean" },
        fetchpriority: { type: "string" },
        integrity: { type: "string" },
        module: { type: "boolean" },
        nomodule: { type: "boolean" },
        nonce: { type: "string" },
        referrerpolicy: { type: "string" },
        type: { type: "string" }
      },
      required: ["src"],
      additionalProperties: true
    };
    var navItemSchema = {
      type: "object",
      properties: {
        page: { type: "string" },
        directory: { type: "string" },
        disconnect: { type: "boolean", default: false },
        group: { type: "string" },
        label: { type: "string" },
        href: { type: "string" },
        external: { type: "boolean" },
        labelTranslationKey: { type: "string" },
        groupTranslationKey: { type: "string" },
        icon: {
          oneOf: [
            { type: "string" },
            { type: "object", properties: { srcSet: { type: "string" } }, required: ["srcSet"] }
          ]
        },
        separator: { type: "string" },
        separatorLine: { type: "boolean" },
        linePosition: {
          type: "string",
          enum: ["top", "bottom"],
          default: "top"
        },
        version: { type: "string" },
        menuStyle: { type: "string", enum: ["drilldown"] },
        expanded: { type: "string", const: "always" },
        selectFirstItemOnExpand: { type: "boolean" },
        flatten: { type: "boolean" },
        linkedSidebars: {
          type: "array",
          items: { type: "string" }
        },
        // Allow users to eject the navbar and implement additional levels of nesting
        items: { type: "array", items: { type: "object", additionalProperties: true } },
        rbac: {
          type: "object",
          additionalProperties: { type: "string" }
        }
      }
    };
    exports.navItemsSchema = {
      type: "array",
      items: Object.assign(Object.assign({}, navItemSchema), { properties: Object.assign(Object.assign({}, navItemSchema.properties), { items: { type: "array", items: navItemSchema } }) })
    };
    exports.productConfigSchema = {
      type: "object",
      properties: {
        name: { type: "string" },
        icon: { type: "string" },
        folder: { type: "string" }
      },
      additionalProperties: false,
      required: ["name", "folder"]
    };
    exports.aiSearchConfigSchema = {
      type: "object",
      properties: {
        hide: {
          type: "boolean",
          default: false
        },
        suggestions: {
          default: [],
          type: "array",
          items: {
            type: "string"
          }
        },
        prompt: {
          type: "string"
        }
      },
      additionalProperties: false
    };
    exports.searchFacetsConfigSchema = {
      type: "array",
      items: {
        type: "object",
        required: ["name", "field", "type"],
        properties: {
          name: { type: "string" },
          field: { type: "string" },
          type: {
            type: "string",
            enum: ["multi-select", "select", "tags"]
          }
        },
        additionalProperties: false
      }
    };
    exports.searchFiltersConfigSchema = {
      type: "object",
      properties: Object.assign({ facets: exports.searchFacetsConfigSchema }, hideConfigSchema.properties),
      additionalProperties: false
    };
    var searchSuggestedPageSchema = {
      type: "object",
      properties: {
        page: { type: "string" },
        label: { type: "string" },
        labelTranslationKey: { type: "string" }
      },
      required: ["page"]
    };
    exports.logoConfigSchema = {
      type: "object",
      properties: {
        image: { type: "string" },
        srcSet: { type: "string" },
        altText: { type: "string" },
        link: { type: "string" },
        favicon: { type: "string" }
      },
      additionalProperties: false
    };
    exports.navbarConfigSchema = {
      type: "object",
      properties: Object.assign({ items: exports.navItemsSchema }, hideConfigSchema.properties),
      additionalProperties: false
    };
    exports.productsConfigSchema = {
      type: "object",
      additionalProperties: exports.productConfigSchema
    };
    exports.footerConfigSchema = {
      type: "object",
      properties: Object.assign({ items: exports.navItemsSchema, copyrightText: { type: "string" }, logo: hideConfigSchema }, hideConfigSchema.properties),
      additionalProperties: false
    };
    exports.sidebarConfigSchema = {
      type: "object",
      properties: Object.assign({ separatorLine: { type: "boolean" }, linePosition: {
        type: "string",
        enum: ["top", "bottom"],
        default: "bottom"
      } }, hideConfigSchema.properties),
      additionalProperties: false
    };
    exports.scriptsConfigSchema = {
      type: "object",
      properties: {
        head: { type: "array", items: scriptConfigSchema },
        body: { type: "array", items: scriptConfigSchema }
      },
      additionalProperties: false
    };
    exports.linksConfigSchema = {
      type: "array",
      items: {
        type: "object",
        properties: {
          href: { type: "string" },
          as: { type: "string" },
          crossorigin: { type: "string" },
          fetchpriority: { type: "string" },
          hreflang: { type: "string" },
          imagesizes: { type: "string" },
          imagesrcset: { type: "string" },
          integrity: { type: "string" },
          media: { type: "string" },
          prefetch: { type: "string" },
          referrerpolicy: { type: "string" },
          rel: { type: "string" },
          sizes: { type: "string" },
          title: { type: "string" },
          type: { type: "string" }
        },
        required: ["href"],
        additionalProperties: true
      }
    };
    exports.searchConfigSchema = {
      type: "object",
      properties: Object.assign({ engine: {
        type: "string",
        enum: ["flexsearch", "typesense"],
        default: "flexsearch"
      }, ai: exports.aiSearchConfigSchema, filters: exports.searchFiltersConfigSchema, placement: {
        type: "string",
        default: "navbar"
      }, shortcuts: {
        type: "array",
        items: { type: "string" },
        default: ["/"]
      }, suggestedPages: {
        type: "array",
        items: searchSuggestedPageSchema
      } }, hideConfigSchema.properties),
      additionalProperties: false
    };
    exports.colorModeConfigSchema = {
      type: "object",
      properties: Object.assign({ ignoreDetection: { type: "boolean" }, modes: {
        type: "array",
        items: { type: "string" },
        default: ["light", "dark"]
      } }, hideConfigSchema.properties),
      additionalProperties: false
    };
    exports.navigationConfigSchema = {
      type: "object",
      properties: {
        nextButton: {
          type: "object",
          properties: Object.assign({ text: { type: "string", default: "Next page" } }, hideConfigSchema.properties),
          additionalProperties: false,
          default: {}
        },
        previousButton: {
          type: "object",
          properties: Object.assign({ text: { type: "string", default: "Previous page" } }, hideConfigSchema.properties),
          additionalProperties: false,
          default: {}
        }
      },
      additionalProperties: false
    };
    exports.codeSnippetConfigSchema = {
      type: "object",
      properties: {
        elementFormat: { type: "string", default: "icon" },
        copy: {
          type: "object",
          properties: Object.assign({}, hideConfigSchema.properties),
          additionalProperties: false,
          default: { hide: false }
        },
        report: {
          type: "object",
          properties: Object.assign({ tooltipText: { type: "string" }, buttonText: { type: "string" }, label: { type: "string" } }, hideConfigSchema.properties),
          additionalProperties: false,
          default: { hide: false }
        },
        expand: {
          type: "object",
          properties: Object.assign({}, hideConfigSchema.properties),
          additionalProperties: false,
          default: { hide: false }
        },
        collapse: {
          type: "object",
          properties: Object.assign({}, hideConfigSchema.properties),
          additionalProperties: false,
          default: { hide: false }
        }
      },
      additionalProperties: false
    };
    exports.markdownConfigSchema = {
      type: "object",
      properties: {
        frontMatterKeysToResolve: {
          type: "array",
          items: { type: "string" },
          default: ["image", "links"]
        },
        partialsFolders: {
          type: "array",
          items: { type: "string" },
          default: ["_partials"]
        },
        lastUpdatedBlock: {
          type: "object",
          properties: Object.assign({ format: {
            type: "string",
            enum: ["timeago", "iso", "long", "short"],
            default: "timeago"
          }, locale: { type: "string" } }, hideConfigSchema.properties),
          additionalProperties: false,
          default: {}
        },
        toc: {
          type: "object",
          properties: Object.assign({ header: { type: "string", default: "On this page" }, depth: { type: "integer", default: 3, minimum: 1 } }, hideConfigSchema.properties),
          additionalProperties: false,
          default: {}
        },
        editPage: {
          type: "object",
          properties: Object.assign({ baseUrl: { type: "string" } }, hideConfigSchema.properties),
          additionalProperties: false,
          default: {}
        }
      },
      additionalProperties: false,
      default: {}
    };
    exports.openapiConfigSchema = Object.assign(Object.assign({}, redoc_config_schema_1.redocConfigSchema), { properties: Object.assign(Object.assign({}, redoc_config_schema_1.redocConfigSchema.properties), reference_docs_config_schema_1.deprecatedRefDocsSchema.properties) });
    var adobeAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        scriptUrl: { type: "string" },
        pageViewEventName: { type: "string" }
      },
      additionalProperties: false,
      required: ["scriptUrl"]
    };
    exports.amplitudeAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        apiKey: { type: "string" },
        head: { type: "boolean" },
        respectDNT: { type: "boolean" },
        exclude: { type: "array", items: { type: "string" } },
        outboundClickEventName: { type: "string" },
        pageViewEventName: { type: "string" },
        amplitudeConfig: { type: "object", additionalProperties: true }
      },
      additionalProperties: false,
      required: ["apiKey"]
    };
    exports.fullstoryAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        orgId: { type: "string" }
      },
      additionalProperties: false,
      required: ["orgId"]
    };
    exports.heapAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        appId: { type: "string" }
      },
      additionalProperties: false,
      required: ["appId"]
    };
    exports.rudderstackAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        writeKey: { type: "string", minLength: 10 },
        trackPage: { type: "boolean" },
        dataPlaneUrl: { type: "string" },
        controlPlaneUrl: { type: "string" },
        sdkUrl: { type: "string" },
        loadOptions: { type: "object", additionalProperties: true }
      },
      additionalProperties: false,
      required: ["writeKey"]
    };
    exports.segmentAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        writeKey: { type: "string", minLength: 10 },
        trackPage: { type: "boolean" },
        includeTitleInPageCall: { type: "boolean" },
        host: { type: "string" }
      },
      additionalProperties: false,
      required: ["writeKey"]
    };
    exports.gtmAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        trackingId: { type: "string" },
        gtmAuth: { type: "string" },
        gtmPreview: { type: "string" },
        defaultDataLayer: {},
        dataLayerName: { type: "string" },
        enableWebVitalsTracking: { type: "boolean" },
        selfHostedOrigin: { type: "string" },
        pageViewEventName: { type: "string" }
      },
      additionalProperties: false,
      required: ["trackingId"]
    };
    exports.productGoogleAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        trackingId: { type: "string" },
        conversionId: { type: "string" },
        floodlightId: { type: "string" },
        optimizeId: { type: "string" },
        exclude: { type: "array", items: { type: "string" } }
      },
      additionalProperties: false,
      required: ["trackingId"]
    };
    exports.googleAnalyticsConfigSchema = {
      type: "object",
      properties: {
        includeInDevelopment: { type: "boolean" },
        trackingId: { type: "string" },
        conversionId: { type: "string" },
        floodlightId: { type: "string" },
        head: { type: "boolean" },
        respectDNT: { type: "boolean" },
        exclude: { type: "array", items: { type: "string" } },
        optimizeId: { type: "string" },
        anonymizeIp: { type: "boolean" },
        cookieExpires: { type: "number" },
        // All enabled tracking configs
        trackers: {
          type: "object",
          additionalProperties: exports.productGoogleAnalyticsConfigSchema
        }
      },
      additionalProperties: false,
      required: ["trackingId"]
    };
    exports.analyticsConfigSchema = {
      type: "object",
      properties: {
        adobe: adobeAnalyticsConfigSchema,
        amplitude: exports.amplitudeAnalyticsConfigSchema,
        fullstory: exports.fullstoryAnalyticsConfigSchema,
        heap: exports.heapAnalyticsConfigSchema,
        rudderstack: exports.rudderstackAnalyticsConfigSchema,
        segment: exports.segmentAnalyticsConfigSchema,
        gtm: exports.gtmAnalyticsConfigSchema,
        ga: exports.googleAnalyticsConfigSchema
      }
    };
    exports.userMenuConfigSchema = {
      type: "object",
      properties: Object.assign({ items: {
        type: "array",
        items: {
          type: "object",
          properties: {
            label: { type: "string" },
            external: { type: "boolean" },
            link: { type: "string" },
            separatorLine: { type: "boolean" }
          },
          additionalProperties: true
        },
        default: []
      }, hideLoginButton: { type: "boolean" } }, hideConfigSchema.properties),
      additionalProperties: false
    };
    exports.versionPickerConfigSchema = {
      type: "object",
      properties: {
        hide: { type: "boolean" },
        showForUnversioned: {
          type: "boolean"
        }
      }
    };
    exports.breadcrumbsConfigSchema = {
      type: "object",
      properties: {
        hide: { type: "boolean" },
        prefixItems: {
          type: "array",
          items: {
            type: "object",
            properties: {
              label: { type: "string" },
              labelTranslationKey: { type: "string" },
              page: { type: "string" }
            },
            additionalProperties: false,
            default: {}
          }
        }
      },
      additionalProperties: false
    };
    exports.catalogFilterSchema = {
      type: "object",
      additionalProperties: false,
      required: ["title", "property"],
      properties: {
        type: {
          type: "string",
          enum: ["select", "checkboxes", "date-range"],
          default: "checkboxes"
        },
        title: { type: "string" },
        titleTranslationKey: { type: "string" },
        property: { type: "string" },
        parentFilter: { type: "string" },
        valuesMapping: { type: "object", additionalProperties: { type: "string" } },
        missingCategoryName: { type: "string" },
        missingCategoryNameTranslationKey: { type: "string" },
        options: { type: "array", items: { type: "string" } }
      }
    };
    exports.catalogSchema = {
      type: "object",
      additionalProperties: true,
      required: ["slug", "items"],
      properties: {
        slug: { type: "string" },
        filters: { type: "array", items: exports.catalogFilterSchema },
        groupByFirstFilter: { type: "boolean" },
        filterValuesCasing: {
          type: "string",
          enum: ["sentence", "original", "lowercase", "uppercase"]
        },
        items: exports.navItemsSchema,
        requiredPermission: { type: "string" },
        separateVersions: { type: "boolean" },
        title: { type: "string" },
        titleTranslationKey: { type: "string" },
        description: { type: "string" },
        descriptionTranslationKey: { type: "string" }
      }
    };
    exports.catalogsConfigSchema = {
      type: "object",
      patternProperties: {
        ".*": exports.catalogSchema
      }
    };
    exports.scorecardConfigSchema = {
      type: "object",
      additionalProperties: true,
      required: [],
      properties: {
        /**
         * @deprecated Should use `reunite.ignoreLint` instead
         */
        ignoreNonCompliant: { type: "boolean", default: false },
        teamMetadataProperty: {
          type: "object",
          properties: {
            property: { type: "string" },
            label: { type: "string" },
            default: { type: "string" }
          }
        },
        levels: {
          type: "array",
          items: {
            type: "object",
            required: ["name"],
            properties: {
              name: { type: "string" },
              color: { type: "string" },
              extends: { type: "array", items: { type: "string" } },
              rules: {
                type: "object",
                additionalProperties: {
                  oneOf: [{ type: "string" }, { type: "object" }]
                }
              }
            },
            additionalProperties: false
          }
        },
        targets: {
          type: "array",
          items: {
            type: "object",
            required: ["where"],
            properties: {
              minimumLevel: { type: "string" },
              rules: { type: "object", additionalProperties: true },
              where: {
                type: "object",
                required: ["metadata"],
                properties: {
                  metadata: { type: "object", additionalProperties: { type: "string" } }
                },
                additionalProperties: false
              }
            },
            additionalProperties: false
          }
        },
        ignore: {
          type: "array",
          items: { type: "string" }
        }
      }
    };
  }
});

// node_modules/@redocly/config/lib/default-theme-config-schema.js
var require_default_theme_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/default-theme-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.closedThemeConfigSchema = exports.themeConfigSchema = void 0;
    var graphql_config_schema_1 = require_graphql_config_schema();
    var feedback_config_schema_1 = require_feedback_config_schema();
    var ex_theme_config_schemas_1 = require_ex_theme_config_schemas();
    exports.themeConfigSchema = {
      type: "object",
      properties: {
        /**
         * @deprecated Should use `plugins` instead
         */
        imports: {
          type: "array",
          items: { type: "string" }
        },
        logo: ex_theme_config_schemas_1.logoConfigSchema,
        navbar: ex_theme_config_schemas_1.navbarConfigSchema,
        products: ex_theme_config_schemas_1.productsConfigSchema,
        footer: ex_theme_config_schemas_1.footerConfigSchema,
        sidebar: ex_theme_config_schemas_1.sidebarConfigSchema,
        scripts: ex_theme_config_schemas_1.scriptsConfigSchema,
        links: ex_theme_config_schemas_1.linksConfigSchema,
        feedback: feedback_config_schema_1.feedbackConfigSchema,
        search: ex_theme_config_schemas_1.searchConfigSchema,
        colorMode: ex_theme_config_schemas_1.colorModeConfigSchema,
        navigation: ex_theme_config_schemas_1.navigationConfigSchema,
        codeSnippet: ex_theme_config_schemas_1.codeSnippetConfigSchema,
        markdown: ex_theme_config_schemas_1.markdownConfigSchema,
        openapi: ex_theme_config_schemas_1.openapiConfigSchema,
        graphql: graphql_config_schema_1.graphqlConfigSchema,
        analytics: ex_theme_config_schemas_1.analyticsConfigSchema,
        userMenu: ex_theme_config_schemas_1.userMenuConfigSchema,
        versionPicker: ex_theme_config_schemas_1.versionPickerConfigSchema,
        breadcrumbs: ex_theme_config_schemas_1.breadcrumbsConfigSchema,
        catalog: ex_theme_config_schemas_1.catalogsConfigSchema,
        scorecard: ex_theme_config_schemas_1.scorecardConfigSchema
      },
      additionalProperties: true
    };
    exports.closedThemeConfigSchema = Object.assign(Object.assign({}, exports.themeConfigSchema), { additionalProperties: false });
  }
});

// node_modules/@redocly/config/lib/constants.js
var require_constants = __commonJS({
  "node_modules/@redocly/config/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LayoutVariant = exports.REDOCLY_ROUTE_RBAC = exports.REDOCLY_TEAMS_RBAC = exports.ApigeeDevOnboardingIntegrationAuthType = exports.AuthProviderType = exports.DEFAULT_TEAM_CLAIM_NAME = void 0;
    exports.DEFAULT_TEAM_CLAIM_NAME = "https://redocly.com/sso/teams";
    var AuthProviderType;
    (function(AuthProviderType2) {
      AuthProviderType2["OIDC"] = "OIDC";
      AuthProviderType2["SAML2"] = "SAML2";
    })(AuthProviderType || (exports.AuthProviderType = AuthProviderType = {}));
    var ApigeeDevOnboardingIntegrationAuthType;
    (function(ApigeeDevOnboardingIntegrationAuthType2) {
      ApigeeDevOnboardingIntegrationAuthType2["SERVICE_ACCOUNT"] = "SERVICE_ACCOUNT";
      ApigeeDevOnboardingIntegrationAuthType2["OAUTH2"] = "OAUTH2";
    })(ApigeeDevOnboardingIntegrationAuthType || (exports.ApigeeDevOnboardingIntegrationAuthType = ApigeeDevOnboardingIntegrationAuthType = {}));
    exports.REDOCLY_TEAMS_RBAC = "redocly::teams-rbac";
    exports.REDOCLY_ROUTE_RBAC = "redocly::route-rbac";
    var LayoutVariant;
    (function(LayoutVariant2) {
      LayoutVariant2["STACKED"] = "stacked";
      LayoutVariant2["THREE_PANEL"] = "three-panel";
    })(LayoutVariant || (exports.LayoutVariant = LayoutVariant = {}));
  }
});

// node_modules/@redocly/config/lib/remove-property-recursively.js
var require_remove_property_recursively = __commonJS({
  "node_modules/@redocly/config/lib/remove-property-recursively.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removePropertyRecursively = removePropertyRecursively;
    function removePropertyRecursively(object, propToRemove) {
      return Object.fromEntries(Object.entries(object).map(([key2, value]) => {
        if (key2 === propToRemove) {
          return void 0;
        }
        if (typeof value !== "object" || !value) {
          return [key2, value];
        }
        if (Array.isArray(value)) {
          return [
            key2,
            value.map((arrayItem) => typeof arrayItem === "object" ? removePropertyRecursively(arrayItem, propToRemove) : arrayItem)
          ];
        }
        return [key2, removePropertyRecursively(value, propToRemove)];
      }).filter(Boolean));
    }
  }
});

// node_modules/@redocly/config/lib/reunite-config-schema.js
var require_reunite_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/reunite-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reuniteConfigSchema = void 0;
    var jobInputsSchema = {
      type: "object",
      additionalProperties: { type: "string" }
    };
    var jobServersSchema = {
      type: "object",
      additionalProperties: false,
      patternProperties: {
        "^[a-zA-Z0-9_-]+$": {
          type: "string",
          pattern: "^https?://[^\\s/$.?#].[^\\s]*$"
        }
      }
    };
    var severitySchema = {
      type: "string",
      enum: ["error", "warn", "off"]
    };
    var jobSeveritySchema = {
      type: "object",
      additionalProperties: false,
      properties: {
        schemaCheck: severitySchema,
        statusCodeCheck: severitySchema,
        contentTypeCheck: severitySchema,
        successCriteriaCheck: severitySchema
      }
    };
    var jobTriggerSchema = {
      type: "object",
      additionalProperties: false,
      properties: {
        event: {
          type: "string",
          enum: ["schedule"]
        },
        interval: { type: "string", pattern: "^[1-9]\\d*[mhdw]$" }
      },
      required: ["event"]
    };
    exports.reuniteConfigSchema = {
      type: "object",
      properties: {
        ignoreLint: {
          oneOf: [
            { type: "boolean", default: false },
            {
              type: "object",
              additionalProperties: { type: "boolean" }
            }
          ]
        },
        ignoreLinkChecker: { type: "boolean" },
        ignoreMarkdocErrors: { type: "boolean" },
        jobs: {
          type: "array",
          items: {
            type: "object",
            properties: {
              path: {
                type: "string",
                pattern: "^(?!\\.\\./)(/[a-zA-Z0-9_\\-\\./]+|./[a-zA-Z0-9_\\-\\./]+|[a-zA-Z0-9_\\-\\./]+)$"
              },
              agent: {
                type: "string",
                enum: ["respect"]
              },
              trigger: jobTriggerSchema,
              inputs: jobInputsSchema,
              servers: jobServersSchema,
              severity: jobSeveritySchema
            },
            required: ["path", "trigger", "agent"],
            additionalProperties: false
          }
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/@redocly/config/lib/root-config-schema.js
var require_root_config_schema = __commonJS({
  "node_modules/@redocly/config/lib/root-config-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rootRedoclyConfigSchema = exports.redoclyConfigSchema = exports.l10nConfigSchema = exports.devOnboardingAdapterConfigSchema = exports.apigeeEdgeAdapterConfigSchema = exports.apigeeXAdapterConfigSchema = exports.apigeeAdapterAuthServiceAccountSchema = exports.apigeeAdapterAuthOauth2Schema = exports.graviteeAdapterConfigSchema = exports.graviteeAdapterAuthIdpSchema = exports.graviteeAdapterAuthStaticSchema = exports.rbacConfigSchema = exports.rbacScopeItemsSchema = exports.apiFunctionsConfigSchema = exports.seoConfigSchema = exports.apiConfigSchema = exports.redirectsConfigSchema = exports.redirectConfigSchema = exports.ssoConfigSchema = exports.ssoDirectConfigSchema = exports.authProviderConfigSchema = exports.saml2ProviderConfigSchema = exports.oidcProviderConfigSchema = exports.oidcIssuerMetadataSchema = void 0;
    var constants_1 = require_constants();
    var default_theme_config_schema_1 = require_default_theme_config_schema();
    var feedback_config_schema_1 = require_feedback_config_schema();
    var graphql_config_schema_1 = require_graphql_config_schema();
    var remove_property_recursively_1 = require_remove_property_recursively();
    var reunite_config_schema_1 = require_reunite_config_schema();
    var ex_theme_config_schemas_1 = require_ex_theme_config_schemas();
    exports.oidcIssuerMetadataSchema = {
      type: "object",
      properties: {
        end_session_endpoint: { type: "string" },
        token_endpoint: { type: "string" },
        authorization_endpoint: { type: "string" },
        jwks_uri: { type: "string" }
      },
      required: ["token_endpoint", "authorization_endpoint"],
      additionalProperties: true
    };
    exports.oidcProviderConfigSchema = {
      type: "object",
      properties: {
        type: { type: "string", const: constants_1.AuthProviderType.OIDC },
        title: { type: "string" },
        pkce: { type: "boolean", default: false },
        configurationUrl: { type: "string", minLength: 1 },
        configuration: exports.oidcIssuerMetadataSchema,
        clientId: { type: "string", minLength: 1 },
        clientSecret: { type: "string", minLength: 0 },
        teamsClaimName: { type: "string" },
        teamsClaimMap: { type: "object", additionalProperties: { type: "string" } },
        defaultTeams: { type: "array", items: { type: "string" } },
        scopes: { type: "array", items: { type: "string" } },
        tokenExpirationTime: { type: "number" },
        authorizationRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
        tokenRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
        audience: { type: "array", items: { type: "string" } }
      },
      required: ["type", "clientId"],
      oneOf: [{ required: ["configurationUrl"] }, { required: ["configuration"] }],
      additionalProperties: false
    };
    exports.saml2ProviderConfigSchema = {
      type: "object",
      properties: {
        type: { type: "string", const: constants_1.AuthProviderType.SAML2 },
        title: { type: "string" },
        issuerId: { type: "string" },
        entityId: { type: "string" },
        ssoUrl: { type: "string" },
        x509PublicCert: { type: "string" },
        teamsAttributeName: { type: "string", default: constants_1.DEFAULT_TEAM_CLAIM_NAME },
        teamsAttributeMap: { type: "object", additionalProperties: { type: "string" } },
        defaultTeams: { type: "array", items: { type: "string" } }
      },
      additionalProperties: false,
      required: ["type", "issuerId", "ssoUrl", "x509PublicCert"]
    };
    exports.authProviderConfigSchema = {
      oneOf: [exports.oidcProviderConfigSchema, exports.saml2ProviderConfigSchema],
      discriminator: { propertyName: "type" }
    };
    exports.ssoDirectConfigSchema = {
      type: "object",
      additionalProperties: exports.authProviderConfigSchema
    };
    exports.ssoConfigSchema = {
      oneOf: [
        {
          type: "array",
          items: {
            type: "string",
            enum: ["REDOCLY", "CORPORATE", "GUEST"]
          },
          uniqueItems: true
        },
        {
          type: "string",
          enum: ["REDOCLY", "CORPORATE", "GUEST"]
        }
      ]
    };
    exports.redirectConfigSchema = {
      type: "object",
      properties: {
        to: { type: "string" },
        type: { type: "number", default: 301 }
      },
      additionalProperties: false
    };
    exports.redirectsConfigSchema = {
      type: "object",
      additionalProperties: exports.redirectConfigSchema,
      default: {}
    };
    var rulesSchema = {
      type: "object",
      additionalProperties: {
        oneOf: [{ type: "string" }, { type: "object" }]
      }
    };
    exports.apiConfigSchema = {
      type: "object",
      properties: {
        root: { type: "string" },
        output: { type: "string", pattern: "(.ya?ml|.json)$" },
        rbac: { type: "object", additionalProperties: true },
        openapi: ex_theme_config_schemas_1.openapiConfigSchema,
        graphql: graphql_config_schema_1.graphqlConfigSchema,
        /**
         * @deprecated left for backwards compatibility
         */
        theme: {
          type: "object",
          properties: {
            openapi: ex_theme_config_schemas_1.openapiConfigSchema,
            graphql: graphql_config_schema_1.graphqlConfigSchema
          },
          additionalProperties: false
        },
        title: { type: "string" },
        metadata: { type: "object", additionalProperties: true },
        rules: rulesSchema,
        decorators: { type: "object", additionalProperties: true },
        preprocessors: { type: "object", additionalProperties: true }
      },
      required: ["root"]
    };
    var metadataConfigSchema = {
      type: "object",
      additionalProperties: true
    };
    var metadataGlobsConfigSchema = {
      type: "object",
      additionalProperties: {
        type: "object",
        additionalProperties: true
      }
    };
    exports.seoConfigSchema = {
      type: "object",
      properties: {
        title: { type: "string" },
        description: { type: "string" },
        siteUrl: { type: "string" },
        image: { type: "string" },
        keywords: {
          oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
        },
        lang: { type: "string" },
        jsonLd: { type: "object" },
        meta: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              content: { type: "string" }
            },
            required: ["name", "content"],
            additionalProperties: false
          }
        }
      },
      additionalProperties: false
    };
    exports.apiFunctionsConfigSchema = {
      type: "object",
      properties: {
        folders: { type: "array", items: { type: "string" } }
      },
      additionalProperties: false
    };
    exports.rbacScopeItemsSchema = {
      type: "object",
      additionalProperties: { type: "string" }
    };
    exports.rbacConfigSchema = {
      type: "object",
      properties: {
        teamNamePatterns: { type: "array", items: { type: "string" } },
        teamFolders: { type: "array", items: { type: "string" } },
        teamFoldersBaseRoles: exports.rbacScopeItemsSchema,
        cms: exports.rbacScopeItemsSchema,
        // deprecated in favor of reunite
        reunite: exports.rbacScopeItemsSchema,
        features: {
          type: "object",
          properties: {
            aiSearch: exports.rbacScopeItemsSchema
          },
          additionalProperties: false
        },
        content: {
          type: "object",
          properties: {
            "**": exports.rbacScopeItemsSchema
          },
          additionalProperties: exports.rbacScopeItemsSchema
        }
      },
      additionalProperties: exports.rbacScopeItemsSchema
    };
    exports.graviteeAdapterAuthStaticSchema = {
      type: "object",
      properties: { static: { type: "string" } },
      additionalProperties: false,
      required: ["static"]
    };
    exports.graviteeAdapterAuthIdpSchema = {
      type: "object",
      properties: { idp: { type: "string" } },
      additionalProperties: false,
      required: ["idp"]
    };
    exports.graviteeAdapterConfigSchema = {
      type: "object",
      properties: {
        type: { type: "string", const: "GRAVITEE" },
        apiBaseUrl: { type: "string" },
        env: { type: "string" },
        allowApiProductsOutsideCatalog: { type: "boolean", default: false },
        stage: { type: "string", default: "non-production" },
        auth: {
          oneOf: [exports.graviteeAdapterAuthStaticSchema, exports.graviteeAdapterAuthIdpSchema]
        }
      },
      additionalProperties: false,
      required: ["type", "apiBaseUrl"]
    };
    exports.apigeeAdapterAuthOauth2Schema = {
      type: "object",
      properties: {
        type: { type: "string", const: constants_1.ApigeeDevOnboardingIntegrationAuthType.OAUTH2 },
        tokenEndpoint: { type: "string" },
        clientId: { type: "string" },
        clientSecret: { type: "string" }
      },
      additionalProperties: false,
      required: ["type", "tokenEndpoint", "clientId", "clientSecret"]
    };
    exports.apigeeAdapterAuthServiceAccountSchema = {
      type: "object",
      properties: {
        type: { type: "string", const: constants_1.ApigeeDevOnboardingIntegrationAuthType.SERVICE_ACCOUNT },
        serviceAccountEmail: { type: "string" },
        serviceAccountPrivateKey: { type: "string" }
      },
      additionalProperties: false,
      required: ["type", "serviceAccountEmail", "serviceAccountPrivateKey"]
    };
    exports.apigeeXAdapterConfigSchema = {
      type: "object",
      properties: {
        type: { type: "string", const: "APIGEE_X" },
        apiUrl: { type: "string" },
        stage: { type: "string", default: "non-production" },
        organizationName: { type: "string" },
        ignoreApiProducts: { type: "array", items: { type: "string" } },
        allowApiProductsOutsideCatalog: { type: "boolean", default: false },
        auth: {
          type: "object",
          oneOf: [exports.apigeeAdapterAuthOauth2Schema, exports.apigeeAdapterAuthServiceAccountSchema],
          discriminator: { propertyName: "type" }
        }
      },
      additionalProperties: false,
      required: ["type", "organizationName", "auth"]
    };
    exports.apigeeEdgeAdapterConfigSchema = Object.assign(Object.assign({}, exports.apigeeXAdapterConfigSchema), { properties: Object.assign(Object.assign({}, exports.apigeeXAdapterConfigSchema.properties), { type: { type: "string", const: "APIGEE_EDGE" } }) });
    exports.devOnboardingAdapterConfigSchema = {
      type: "object",
      oneOf: [exports.apigeeXAdapterConfigSchema, exports.apigeeEdgeAdapterConfigSchema, exports.graviteeAdapterConfigSchema],
      discriminator: { propertyName: "type" }
    };
    var devOnboardingConfigSchema = {
      type: "object",
      required: ["adapters"],
      additionalProperties: false,
      properties: {
        adapters: {
          type: "array",
          items: exports.devOnboardingAdapterConfigSchema
        }
      }
    };
    exports.l10nConfigSchema = {
      type: "object",
      properties: {
        defaultLocale: {
          type: "string"
        },
        locales: {
          type: "array",
          items: {
            type: "object",
            properties: {
              code: {
                type: "string"
              },
              name: {
                type: "string"
              }
            },
            required: ["code"]
          }
        }
      },
      additionalProperties: false,
      required: ["defaultLocale"]
    };
    var responseHeaderSchema = {
      type: "object",
      properties: {
        name: { type: "string" },
        value: { type: "string" }
      },
      additionalProperties: false,
      required: ["name", "value"]
    };
    exports.redoclyConfigSchema = {
      type: "object",
      properties: {
        /**
         * @deprecated Should use `plugins` instead
         */
        imports: {
          type: "array",
          items: { type: "string" }
        },
        licenseKey: { type: "string" },
        redirects: exports.redirectsConfigSchema,
        seo: exports.seoConfigSchema,
        rbac: exports.rbacConfigSchema,
        apiFunctions: exports.apiFunctionsConfigSchema,
        requiresLogin: { type: "boolean" },
        responseHeaders: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: responseHeaderSchema
          }
        },
        mockServer: {
          type: "object",
          properties: {
            off: { type: "boolean", default: false },
            position: { type: "string", enum: ["first", "last", "replace", "off"], default: "first" },
            strictExamples: { type: "boolean", default: false },
            errorIfForcedExampleNotFound: { type: "boolean", default: false },
            description: { type: "string" }
          }
        },
        apis: {
          type: "object",
          additionalProperties: exports.apiConfigSchema
        },
        rules: rulesSchema,
        decorators: { type: "object", additionalProperties: true },
        preprocessors: { type: "object", additionalProperties: true },
        ssoDirect: exports.ssoDirectConfigSchema,
        sso: exports.ssoConfigSchema,
        residency: { type: "string" },
        developerOnboarding: devOnboardingConfigSchema,
        removeAttribution: { type: "boolean" },
        i18n: exports.l10nConfigSchema,
        // deprecated
        l10n: exports.l10nConfigSchema,
        metadata: metadataConfigSchema,
        metadataGlobs: metadataGlobsConfigSchema,
        ignore: {
          type: "array",
          items: {
            type: "string"
          }
        },
        /**
         * @deprecated properties moved to the root of the config
         */
        theme: default_theme_config_schema_1.themeConfigSchema,
        reunite: reunite_config_schema_1.reuniteConfigSchema,
        // Ex theme properties
        logo: ex_theme_config_schemas_1.logoConfigSchema,
        navbar: ex_theme_config_schemas_1.navbarConfigSchema,
        products: ex_theme_config_schemas_1.productsConfigSchema,
        footer: ex_theme_config_schemas_1.footerConfigSchema,
        sidebar: ex_theme_config_schemas_1.sidebarConfigSchema,
        scripts: ex_theme_config_schemas_1.scriptsConfigSchema,
        links: ex_theme_config_schemas_1.linksConfigSchema,
        feedback: feedback_config_schema_1.feedbackConfigSchema,
        search: ex_theme_config_schemas_1.searchConfigSchema,
        colorMode: ex_theme_config_schemas_1.colorModeConfigSchema,
        navigation: ex_theme_config_schemas_1.navigationConfigSchema,
        codeSnippet: ex_theme_config_schemas_1.codeSnippetConfigSchema,
        markdown: ex_theme_config_schemas_1.markdownConfigSchema,
        openapi: ex_theme_config_schemas_1.openapiConfigSchema,
        graphql: graphql_config_schema_1.graphqlConfigSchema,
        analytics: ex_theme_config_schemas_1.analyticsConfigSchema,
        userMenu: ex_theme_config_schemas_1.userMenuConfigSchema,
        versionPicker: ex_theme_config_schemas_1.versionPickerConfigSchema,
        breadcrumbs: ex_theme_config_schemas_1.breadcrumbsConfigSchema,
        catalog: ex_theme_config_schemas_1.catalogsConfigSchema,
        scorecard: ex_theme_config_schemas_1.scorecardConfigSchema
      },
      default: { redirects: {} },
      additionalProperties: true
    };
    var environmentSchema = Object.assign(Object.assign({}, (0, remove_property_recursively_1.removePropertyRecursively)(exports.redoclyConfigSchema, "default")), { additionalProperties: false });
    exports.rootRedoclyConfigSchema = Object.assign(Object.assign({ $id: "root-redocly-config" }, exports.redoclyConfigSchema), { properties: Object.assign(Object.assign({ plugins: {
      type: "array",
      items: { type: "string" }
    } }, exports.redoclyConfigSchema.properties), { env: {
      type: "object",
      additionalProperties: environmentSchema
      // TODO: if we want full validation we need to override apis, theme and the root
    } }), default: {}, additionalProperties: false });
  }
});

// node_modules/@redocly/config/lib/product-override-schema.js
var require_product_override_schema = __commonJS({
  "node_modules/@redocly/config/lib/product-override-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.productConfigOverrideSchema = exports.productThemeOverrideSchema = void 0;
    var default_theme_config_schema_1 = require_default_theme_config_schema();
    var ex_theme_config_schemas_1 = require_ex_theme_config_schemas();
    var root_config_schema_1 = require_root_config_schema();
    exports.productThemeOverrideSchema = {
      type: "object",
      properties: {
        logo: default_theme_config_schema_1.themeConfigSchema.properties.logo,
        navbar: default_theme_config_schema_1.themeConfigSchema.properties.navbar,
        footer: default_theme_config_schema_1.themeConfigSchema.properties.footer,
        sidebar: default_theme_config_schema_1.themeConfigSchema.properties.sidebar,
        search: default_theme_config_schema_1.themeConfigSchema.properties.search,
        codeSnippet: default_theme_config_schema_1.themeConfigSchema.properties.codeSnippet,
        breadcrumbs: default_theme_config_schema_1.themeConfigSchema.properties.breadcrumbs,
        openapi: default_theme_config_schema_1.themeConfigSchema.properties.openapi,
        feedback: default_theme_config_schema_1.themeConfigSchema.properties.feedback,
        analytics: {
          type: "object",
          properties: {
            ga: ex_theme_config_schemas_1.productGoogleAnalyticsConfigSchema
          }
        }
      },
      additionalProperties: true,
      default: {}
    };
    exports.productConfigOverrideSchema = {
      $id: "product-config-override",
      type: "object",
      properties: Object.assign(Object.assign({}, exports.productThemeOverrideSchema.properties), {
        apis: {
          type: "object",
          additionalProperties: root_config_schema_1.apiConfigSchema
        },
        /**
         * @deprecated left for backwards compatibility
         */
        theme: exports.productThemeOverrideSchema
      }),
      additionalProperties: false
    };
  }
});

// node_modules/@redocly/config/lib/types/api-functions-types.js
var require_api_functions_types = __commonJS({
  "node_modules/@redocly/config/lib/types/api-functions-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@redocly/config/lib/types/config-types.js
var require_config_types = __commonJS({
  "node_modules/@redocly/config/lib/types/config-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@redocly/config/lib/types/code-walkthrough-types.js
var require_code_walkthrough_types = __commonJS({
  "node_modules/@redocly/config/lib/types/code-walkthrough-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@redocly/config/lib/types/portal-shared-types.js
var require_portal_shared_types = __commonJS({
  "node_modules/@redocly/config/lib/types/portal-shared-types.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_code_walkthrough_types(), exports);
  }
});

// node_modules/@redocly/config/lib/types/index.js
var require_types2 = __commonJS({
  "node_modules/@redocly/config/lib/types/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_api_functions_types(), exports);
    __exportStar(require_config_types(), exports);
    __exportStar(require_portal_shared_types(), exports);
  }
});

// node_modules/@redocly/config/lib/index.js
var require_lib = __commonJS({
  "node_modules/@redocly/config/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.REDOCLY_ROUTE_RBAC = exports.REDOCLY_TEAMS_RBAC = exports.LayoutVariant = exports.DEFAULT_TEAM_CLAIM_NAME = exports.AuthProviderType = exports.ApigeeDevOnboardingIntegrationAuthType = exports.redocConfigSchema = exports.rootRedoclyConfigSchema = exports.rbacConfigSchema = exports.productConfigOverrideSchema = exports.productThemeOverrideSchema = void 0;
    var product_override_schema_1 = require_product_override_schema();
    Object.defineProperty(exports, "productThemeOverrideSchema", { enumerable: true, get: function() {
      return product_override_schema_1.productThemeOverrideSchema;
    } });
    Object.defineProperty(exports, "productConfigOverrideSchema", { enumerable: true, get: function() {
      return product_override_schema_1.productConfigOverrideSchema;
    } });
    var root_config_schema_1 = require_root_config_schema();
    Object.defineProperty(exports, "rbacConfigSchema", { enumerable: true, get: function() {
      return root_config_schema_1.rbacConfigSchema;
    } });
    Object.defineProperty(exports, "rootRedoclyConfigSchema", { enumerable: true, get: function() {
      return root_config_schema_1.rootRedoclyConfigSchema;
    } });
    var redoc_config_schema_1 = require_redoc_config_schema();
    Object.defineProperty(exports, "redocConfigSchema", { enumerable: true, get: function() {
      return redoc_config_schema_1.redocConfigSchema;
    } });
    __exportStar(require_types2(), exports);
    var constants_1 = require_constants();
    Object.defineProperty(exports, "ApigeeDevOnboardingIntegrationAuthType", { enumerable: true, get: function() {
      return constants_1.ApigeeDevOnboardingIntegrationAuthType;
    } });
    Object.defineProperty(exports, "AuthProviderType", { enumerable: true, get: function() {
      return constants_1.AuthProviderType;
    } });
    Object.defineProperty(exports, "DEFAULT_TEAM_CLAIM_NAME", { enumerable: true, get: function() {
      return constants_1.DEFAULT_TEAM_CLAIM_NAME;
    } });
    Object.defineProperty(exports, "LayoutVariant", { enumerable: true, get: function() {
      return constants_1.LayoutVariant;
    } });
    Object.defineProperty(exports, "REDOCLY_TEAMS_RBAC", { enumerable: true, get: function() {
      return constants_1.REDOCLY_TEAMS_RBAC;
    } });
    Object.defineProperty(exports, "REDOCLY_ROUTE_RBAC", { enumerable: true, get: function() {
      return constants_1.REDOCLY_ROUTE_RBAC;
    } });
  }
});

// node_modules/@redocly/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    exports._ = _;
    exports.str = str;
    exports.addCodeArg = addCodeArg;
    exports.strConcat = strConcat;
    exports.stringify = stringify;
    exports.safeStringify = safeStringify;
    exports.getProperty = getProperty;
    exports.getEsmExportName = getEsmExportName;
    exports.regexpCode = regexpCode;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function getProperty(key2) {
      return typeof key2 == "string" && exports.IDENTIFIER.test(key2) ? new _Code(`.${key2}`) : _`[${key2}]`;
    }
    function getEsmExportName(key2) {
      if (typeof key2 == "string" && exports.IDENTIFIER.test(key2)) {
        return new _Code(`${key2}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key2}, use explicit $id name mapping`);
    }
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name2) {
        super(`CodeGen: "code" for ${name2} not defined`);
        this.value = name2.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts2) {
        super(opts2);
        this._values = {};
        this._scope = opts2.scope;
        this.opts = { ...opts2, _n: opts2.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name2 = this.toName(nameOrPrefix);
        const { prefix } = name2;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name2);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name2.setValue(value, { property: prefix, itemIndex });
        return name2;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name2) => {
          if (name2.scopePath === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return (0, code_1._)`${scopeName}${name2.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name2) => {
          if (name2.value === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return name2.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name2) => {
            if (nameSet.has(name2))
              return;
            nameSet.set(name2, UsedValueState.Started);
            let c = valueCode(name2);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name2} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name2);
            }
            nameSet.set(name2, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/@redocly/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    exports.not = not;
    exports.and = and;
    exports.or = or;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node2 = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node2 {
      constructor(varKind, name2, rhs) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label3 = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break2 = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node2 {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts2) {
        return this.nodes.reduce((code, n) => code + n.render(opts2), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts2) {
        return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
      }
    };
    var Root2 = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts2) {
        let code = `if(${this.condition})` + super.render(opts2);
        if (this.else)
          code += "else " + this.else.render(opts2);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts2) {
        return `for(${this.iteration})` + super.render(opts2);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name2, from, to) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.from = from;
        this.to = to;
      }
      render(opts2) {
        const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
        const { name: name2, from, to } = this;
        return `for(${varKind} ${name2}=${from}; ${name2}<${to}; ${name2}++)` + super.render(opts2);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name2, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name2;
        this.iterable = iterable;
      }
      render(opts2) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name2, args, async) {
        super();
        this.name = name2;
        this.args = args;
        this.async = async;
      }
      render(opts2) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts2) {
        return "return " + super.render(opts2);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts2) {
        let code = "try" + super.render(opts2);
        if (this.catch)
          code += this.catch.render(opts2);
        if (this.finally)
          code += this.finally.render(opts2);
        return code;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        super.optimizeNames(names, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts2) {
        return `catch(${this.error})` + super.render(opts2);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts2) {
        return "finally" + super.render(opts2);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts2 = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts2, _n: opts2.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root2()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name2 = this._extScope.value(prefixOrName, value);
        const vs = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
        vs.add(name2);
        return name2;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name2.str] = rhs;
        this._leafNode(new Def(varKind, name2, rhs));
        return name2;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key2, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key2);
          if (key2 !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name2, from, to), () => forBody(name2));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name2, (0, code_1._)`${arr}[${i}]`);
            forBody(name2);
          });
        }
        return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label3(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break2(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name2, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name2, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.mergeEvaluated = void 0;
    exports.toHash = toHash;
    exports.alwaysValidSchema = alwaysValidSchema;
    exports.checkUnknownRules = checkUnknownRules;
    exports.schemaHasRules = schemaHasRules;
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    exports.schemaRefOrVal = schemaRefOrVal;
    exports.unescapeFragment = unescapeFragment;
    exports.escapeFragment = escapeFragment;
    exports.escapeJsonPointer = escapeJsonPointer;
    exports.unescapeJsonPointer = unescapeJsonPointer;
    exports.eachItem = eachItem;
    exports.evaluatedPropsToName = evaluatedPropsToName;
    exports.setEvaluated = setEvaluated;
    exports.useFunc = useFunc;
    exports.getErrorPath = getErrorPath;
    exports.checkStrictMode = checkStrictMode;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    function checkUnknownRules(it, schema = it.schema) {
      const { opts: opts2, self: self2 } = it;
      if (!opts2.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key2 in schema) {
        if (!rules[key2])
          checkStrictMode(it, `unknown keyword: "${key2}"`);
      }
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key2 in schema)
        if (rules[key2])
          return true;
      return false;
    }
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key2 in schema)
        if (key2 !== "$ref" && RULES.all[key2])
          return true;
      return false;
    }
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      isAllOfVariant: new codegen_1.Name("isAllOfVariant"),
      // used to check in runtime if the current function (ref) is called from allOf
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/@redocly/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyword$DataError = exports.keywordError = void 0;
    exports.reportError = reportError;
    exports.reportExtraError = reportExtraError;
    exports.resetErrorsCount = resetErrorsCount;
    exports.extendErrors = extendErrors;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword: keyword2, data, schemaValue, it } = cxt;
      const { opts: opts2, propertyName: propertyName2, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts2.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts2.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName2)
        keyValues.push([E.propertyName, propertyName2]);
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    exports.boolOrEmptySchema = boolOrEmptySchema;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/rules.js
var require_rules2 = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJSONType = isJSONType;
    exports.getRules = getRules;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schemaHasRulesForType = schemaHasRulesForType;
    exports.shouldUseGroup = shouldUseGroup;
    exports.shouldUseRule = shouldUseRule;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataType = void 0;
    exports.getSchemaTypes = getSchemaTypes;
    exports.getJSONTypes = getJSONTypes;
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    exports.checkDataType = checkDataType;
    exports.checkDataTypes = checkDataTypes;
    exports.reportTypeError = reportTypeError;
    var rules_1 = require_rules2();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    function getJSONTypes(ts) {
      const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    function coerceAndCheckDataType(it, types2) {
      const { gen, data, opts: opts2 } = it;
      const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types2, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
      const { gen, data, opts: opts2 } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts2.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t2 of coerceTo) {
        if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
          coerceSpecificType(t2);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t2) {
        switch (t2) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t2 in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t2, data, strictNums, correct));
      return cond;
    }
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = assignDefaults;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key2 in properties) {
          assignDefault(it, key2, properties[key2].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts: opts2 } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts2.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkReportMissingProp = checkReportMissingProp;
    exports.checkMissingProp = checkMissingProp;
    exports.reportMissingProp = reportMissingProp;
    exports.hasPropFunc = hasPropFunc;
    exports.isOwnProperty = isOwnProperty;
    exports.propertyInData = propertyInData;
    exports.noPropertyInData = noPropertyInData;
    exports.allSchemaProperties = allSchemaProperties;
    exports.schemaProperties = schemaProperties;
    exports.callValidateCode = callValidateCode;
    exports.usePattern = usePattern;
    exports.validateArray = validateArray;
    exports.validateUnion = validateUnion;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts2.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
        [names_1.default.isAllOfVariant, it.isAllOfVariant ? 1 : 0]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts: opts2 } }, pattern) {
      const u = opts2.unicodeRegExp ? "u" : "";
      const { regExp } = opts2.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.macroKeywordCode = macroKeywordCode;
    exports.funcKeywordCode = funcKeywordCode;
    exports.validSchemaType = validSchemaType;
    exports.validateKeywordUsage = validateKeywordUsage;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    function funcKeywordCode(cxt, def) {
      var _a2;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword2, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    function validateKeywordUsage({ schema, opts: opts2, self: self2, errSchemaPath }, def, keyword2) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts2.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSubschema = getSubschema;
    exports.extendSubschemaData = extendSubschemaData;
    exports.extendSubschemaMode = extendSubschemaMode;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName: propertyName2 }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts: opts2 } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts2.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName2 !== void 0)
          subschema.propertyName = propertyName2;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key2 = keys2[i];
          if (!equal(a[key2], b[key2])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts2, cb) {
      if (typeof opts2 == "function") {
        cb = opts2;
        opts2 = {};
      }
      cb = opts2.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts2, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts2, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key2 in schema) {
          var sch = schema[key2];
          if (Array.isArray(sch)) {
            if (key2 in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts2, pre, post, sch[i], jsonPtr + "/" + key2 + "/" + i, rootSchema, jsonPtr, key2, schema, i);
            }
          } else if (key2 in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key2 + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key2, schema, prop);
            }
          } else if (key2 in traverse.keywords || opts2.allKeys && !(key2 in traverse.skipKeywords)) {
            _traverse(opts2, pre, post, sch, jsonPtr + "/" + key2, rootSchema, jsonPtr, key2, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inlineRef = inlineRef;
    exports.getFullPath = getFullPath;
    exports._getFullPath = _getFullPath;
    exports.normalizeId = normalizeId;
    exports.resolveUrl = resolveUrl3;
    exports.getSchemaRefs = getSchemaRefs;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key2 in schema) {
        if (REF_KEYWORDS.has(key2))
          return true;
        const sch = schema[key2];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key2 in schema) {
        if (key2 === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key2))
          continue;
        if (typeof schema[key2] == "object") {
          (0, util_1.eachItem)(schema[key2], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl3(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
  }
});

// node_modules/@redocly/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeywordCxt = void 0;
    exports.validateFunctionCode = validateFunctionCode;
    exports.getData = getData;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve2();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    function validateFunction({ gen, validateName, schema, schemaEnv, opts: opts2 }, body) {
      if (opts2.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts2)}`);
          destructureValCxtES5(gen, opts2);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts2)).code(body));
      }
    }
    function destructureValCxt(opts2) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts2.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}, ${names_1.default.isAllOfVariant} = 0}={}`;
    }
    function destructureValCxtES5(gen, opts2) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        gen.var(names_1.default.isAllOfVariant, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.isAllOfVariant}`);
        if (opts2.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        gen.var(names_1.default.isAllOfVariant, (0, codegen_1._)`0`);
        if (opts2.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts: opts2, gen } = it;
      validateFunction(it, () => {
        if (opts2.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts2.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts2) {
      const schId = typeof schema == "object" && schema[opts2.schemaId];
      return schId && (opts2.code.source || opts2.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key2 in schema)
        if (self2.RULES.all[key2])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts: opts2 } = it;
      if (opts2.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
      schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts: opts2, self: self2 } = it;
      if (schema.$ref && opts2.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts: opts2 } = it;
      if (schema.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts: opts2 }) {
      const msg = schema.$comment;
      if (opts2.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts2.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts: opts2 } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts2.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts: opts2, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts2.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts2.jtd)
        checkStrictTypes(it, types2);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts2.strictNumbers));
          iterateKeywords(it, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule) || shouldForceUnevaluatedProperties(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
      function shouldForceUnevaluatedProperties(schema2, rule) {
        return !!(rule.keyword === "unevaluatedProperties" && (schema2.properties || schema2.patternProperties) && !it.isAllOfVariant && it.opts.defaultUnevaluatedProperties === false);
      }
    }
    function checkStrictTypes(it, types2) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types2);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types2);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types2) {
      if (!types2.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types2;
        return;
      }
      types2.forEach((t2) => {
        if (!includesType(it.dataTypes, t2)) {
          strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword2 in rules) {
        const rule = rules[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t2) {
      return ts.includes(t2) || t2 === "integer" && ts.includes("number");
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword2);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword2;
        this.data = it.data;
        this.schema = it.schema[keyword2];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid, isAllOfVariant) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = {
          ...this.it,
          ...subschema,
          items: void 0,
          props: void 0,
          isAllOfVariant
        };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword2, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword2);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
  }
});

// node_modules/@redocly/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/@redocly/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/@redocly/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve2();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/@redocly/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/@redocly/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaEnv = void 0;
    exports.compileSchema = compileSchema;
    exports.resolveRef = resolveRef;
    exports.getCompilingSchema = getCompilingSchema;
    exports.resolveSchema = resolveSchema;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve2();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `const visitedNodesForRef = new WeakMap(); ${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    function resolveRef(root, baseId, origRef) {
      var _a2;
      const ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, origRef);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0 && this.opts.loadSchemaSync) {
        const remoteSchema = this.opts.loadSchemaSync(baseId, origRef, ref);
        if (remoteSchema && !(this.refs[ref] || this.schemas[ref])) {
          this.addSchema(remoteSchema, ref, void 0);
          _sch = resolve.call(this, root, ref);
        }
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/@redocly/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/uri-js-replace/dist/Serialize.js
var require_Serialize = __commonJS({
  "node_modules/uri-js-replace/dist/Serialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialize = void 0;
    function serialize(components) {
      let buildResult = buildStartUrl(components);
      let urlBuilder;
      try {
        urlBuilder = new URL(buildResult.startUrl);
      } catch (error) {
        if (error.message) {
          console.error(error.message + " " + buildResult.startUrl);
        }
        return "";
      }
      if (components.scheme !== void 0 && !buildResult.temporarySchemeAndHostUsed && !buildResult.temporarySchemeUsed) {
        urlBuilder.protocol = components.scheme.toLowerCase();
      } else {
        urlBuilder.protocol = "";
      }
      if (components.host !== void 0 && !buildResult.temporarySchemeAndHostUsed && !buildResult.temporaryHostUsed) {
        urlBuilder.host = components.host;
      } else {
        urlBuilder.host = "";
      }
      if (components.port) {
        urlBuilder.port = String(components.port);
      }
      if (components.path) {
        urlBuilder.pathname = components.path;
      }
      if (components.userinfo) {
        let parts = components.userinfo.split(":");
        if (parts[0]) {
          urlBuilder.username = parts[0];
        }
        if (parts[1]) {
          urlBuilder.password = parts[1];
        }
      }
      if (components.query) {
        urlBuilder.search = components.query;
      }
      if (components.fragment) {
        urlBuilder.hash = components.fragment;
      }
      let result = urlBuilder.toString();
      if (!components.path && result.endsWith("/")) {
        result = result.slice(0, -1);
      }
      if (buildResult.temporarySchemeAndHostUsed) {
        result = result.replace(temporarySchemeAndHost, "");
        if (result.startsWith("/")) {
          result = result.slice(1);
        }
      }
      if (buildResult.temporaryHostUsed) {
        result = result.replace(temporaryHost, "");
      }
      if (buildResult.temporarySchemeUsed) {
        result = result.replace(temporaryScheme, "");
      }
      return result;
    }
    exports.serialize = serialize;
    var temporaryScheme = "https:";
    var temporaryHost = "_remove_me_host_";
    var temporarySchemeAndHost = temporaryScheme + "//" + temporaryHost;
    function buildStartUrl(components) {
      let result = {
        startUrl: "",
        temporaryHostUsed: false,
        temporarySchemeUsed: false,
        temporarySchemeAndHostUsed: false
      };
      if (components.scheme && components.host) {
        result.startUrl = components.scheme + "://" + components.host;
        return result;
      }
      if (components.host) {
        result.temporarySchemeUsed = true;
        result.startUrl = temporaryScheme + components.host;
        return result;
      }
      if (components.scheme) {
        if (components.path) {
          result.startUrl = components.scheme + ":" + components.path;
          return result;
        }
        result.temporaryHostUsed = true;
        result.startUrl = components.scheme + ":" + temporaryHost;
        return result;
      }
      result.temporarySchemeAndHostUsed = true;
      result.startUrl = temporarySchemeAndHost;
      return result;
    }
  }
});

// node_modules/uri-js-replace/dist/Parse.js
var require_Parse = __commonJS({
  "node_modules/uri-js-replace/dist/Parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    function parse(uriString) {
      let result = {
        path: "",
        fragment: void 0,
        host: void 0,
        port: void 0,
        query: void 0,
        reference: void 0,
        scheme: void 0,
        userinfo: void 0
      };
      if (uriString.includes("#")) {
        result.fragment = "";
      }
      let { parsed, addedDefaultScheme, addedTemporaryHost, error } = recognizeUrl(uriString);
      if (error || parsed === void 0) {
        result.error = error;
        return result;
      }
      if (typeof parsed.protocol !== void 0 && parsed.protocol !== "" && !addedDefaultScheme) {
        result.scheme = String(parsed.protocol).replace(":", "");
      }
      if (typeof parsed.username !== void 0 && parsed.username !== "") {
        let userinfo = parsed.username;
        if (parsed.password) {
          userinfo += ":" + parsed.password;
        }
        result.userinfo = userinfo;
      }
      if (typeof parsed.hostname !== void 0 && parsed.hostname !== "" && !addedTemporaryHost) {
        result.host = parsed.hostname;
        if (result.host.startsWith("[")) {
          result.host = result.host.substring(1);
          result.host = result.host.slice(0, -1);
        }
      }
      if (typeof parsed.port !== void 0 && parsed.port !== "") {
        result.port = Number(parsed.port);
      }
      if (typeof parsed.pathname !== void 0 && parsed.pathname !== "/") {
        result.path = parsed.pathname;
        if (addedTemporaryHost && result.path.startsWith("/")) {
          result.path = result.path.substring(1);
        }
      }
      if (typeof parsed.search !== void 0 && parsed.search !== "") {
        result.query = parsed.search.replace("?", "");
      }
      if (typeof parsed.hash !== void 0 && parsed.hash !== "") {
        result.fragment = parsed.hash.replace("#", "");
      }
      if (result.scheme === void 0 && result.userinfo === void 0 && result.host === void 0 && result.port === void 0 && !result.path && result.query === void 0) {
        result.reference = "same-document";
      } else if (result.scheme === void 0) {
        result.reference = "relative";
      } else if (result.fragment === void 0) {
        result.reference = "absolute";
      } else {
        result.reference = "uri";
      }
      return result;
    }
    exports.parse = parse;
    var temporaryHost = "_remove_me_host/";
    function recognizeUrl(uriString) {
      let result = {
        parsed: void 0,
        addedDefaultScheme: false,
        addedTemporaryHost: false,
        error: void 0
      };
      let firstError;
      try {
        result.parsed = new URL(uriString);
        return result;
      } catch (error) {
        firstError = error;
      }
      if (uriString.startsWith("//")) {
        try {
          result.parsed = new URL("https:" + uriString);
          result.addedDefaultScheme = true;
          return result;
        } catch (otherError) {
          result.error = firstError.message;
          return result;
        }
      }
      try {
        result.parsed = new URL("https://" + temporaryHost + uriString);
        result.addedDefaultScheme = true;
        result.addedTemporaryHost = true;
        return result;
      } catch (otherError) {
      }
      result.error = firstError.message;
      return result;
    }
  }
});

// node_modules/uri-js-replace/dist/Resolve.js
var require_Resolve = __commonJS({
  "node_modules/uri-js-replace/dist/Resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveComponents = exports.resolve = void 0;
    var Parse_1 = require_Parse();
    var Serialize_1 = require_Serialize();
    function resolve(baseURI, relativeURI, options2) {
      const schemeLessOptions = Object.assign({ scheme: "null" }, options2);
      const resolved = resolveComponents((0, Parse_1.parse)(baseURI), (0, Parse_1.parse)(relativeURI), schemeLessOptions, true);
      return (0, Serialize_1.serialize)(resolved);
    }
    exports.resolve = resolve;
    function resolveComponents(base2, relative, options2, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base2 = (0, Parse_1.parse)((0, Serialize_1.serialize)(base2));
        relative = (0, Parse_1.parse)((0, Serialize_1.serialize)(relative));
      }
      options2 = options2 || {};
      if (!options2.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    exports.resolveComponents = resolveComponents;
    function removeDotSegments(input) {
      const RDS1 = /^\.\.?\//u;
      const RDS2 = /^\/\.(?:\/|$)/u;
      const RDS3 = /^\/\.\.(?:\/|$)/u;
      const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
  }
});

// node_modules/uri-js-replace/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/uri-js-replace/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = exports.equal = void 0;
    var Serialize_1 = require_Serialize();
    var Parse_1 = require_Parse();
    __exportStar(require_Resolve(), exports);
    __exportStar(require_Serialize(), exports);
    __exportStar(require_Parse(), exports);
    function equal(uriA, uriB) {
      let processedA;
      let processedB;
      if (typeof uriA === "string") {
        processedA = (0, Serialize_1.serialize)((0, Parse_1.parse)(uriA));
      } else {
        processedA = (0, Serialize_1.serialize)(uriA);
      }
      if (typeof uriB === "string") {
        processedB = (0, Serialize_1.serialize)((0, Parse_1.parse)(uriB));
      } else {
        processedB = (0, Serialize_1.serialize)(uriB);
      }
      return processedA.toLowerCase() === processedB.toLowerCase();
    }
    exports.equal = equal;
    function normalize(uri) {
      if (typeof uri === "string") {
        return (0, Serialize_1.serialize)((0, Parse_1.parse)(uri));
      } else {
        return (0, Parse_1.parse)((0, Serialize_1.serialize)(uri));
      }
    }
    exports.normalize = normalize;
  }
});

// node_modules/@redocly/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/@redocly/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_dist3();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/@redocly/ajv/dist/core.js
var require_core2 = __commonJS({
  "node_modules/@redocly/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules2();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve2();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = [
      "removeAdditional",
      "useDefaults",
      "coerceTypes",
      "defaultUnevaluatedProperties",
      "defaultAdditionalProperties"
    ];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts2 = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts2 = this.opts = { ...opts2, ...requiredOptions(opts2) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts2.logger);
        const formatOpt = opts2.validateFormats;
        opts2.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts2.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts2.keywords)
          addInitialKeywords.call(this, opts2.keywords);
        if (typeof opts2.meta == "object")
          this.addMetaSchema(opts2.meta);
        addInitialSchemas.call(this);
        opts2.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta2, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta2 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta2, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta2) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta2);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta2);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key2, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key2 = (0, resolve_1.normalizeId)(key2 || id);
        this._checkUnique(key2);
        this.schemas[key2] = this._addSchema(schema, _meta, key2, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key2, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key2, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name2, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name2] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text2, msg) => text2 + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key2 in rules) {
            const rule = rules[key2];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key2];
            if ($data && schema)
              keywords[key2] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta2, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports.default = Ajv;
    function checkOptions(checkOpts, options2, msg, log = "error") {
      for (const key2 in checkOpts) {
        const opt = key2;
        if (opt in options2)
          this.logger[log](`${msg}: option ${key2}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key2 in optsSchemas)
          this.addSchema(optsSchemas[key2], key2);
    }
    function addInitialFormats() {
      for (const name2 in this.opts.formats) {
        const format = this.opts.formats[name2];
        if (format)
          this.addFormat(name2, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getValidate = getValidate;
    exports.callRef = callRef;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts: opts2, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema(
            {
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref
            },
            valid,
            it.isAllOfVariant
            // pass isAllOfVariant into inlined $ref
          );
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts: opts2 } = it;
      const passCxt = opts2.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        const visitedNodes = gen.name("visitedNodes");
        gen.code((0, codegen_1._)`const ${visitedNodes} = (typeof visitedNodesForRef !== 'undefined') && visitedNodesForRef.get(${v}) || new Set()`);
        gen.if((0, codegen_1._)`!${visitedNodes}.has(${cxt.data})`, () => {
          gen.code((0, codegen_1._)`if (typeof visitedNodesForRef !== 'undefined') visitedNodesForRef.set(${v}, ${visitedNodes})`);
          gen.code((0, codegen_1._)`const dataNode = ${cxt.data}`);
          gen.code((0, codegen_1._)`if (typeof dataNode === "object" && dataNode !== null) ${visitedNodes}.add(dataNode)`);
          const res = cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
          gen.code((0, codegen_1._)`${visitedNodes}.delete(dataNode)`);
          return res;
        });
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/core/index.js
var require_core3 = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec2 = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid2 = prec2 ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec2}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid2}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/@redocly/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = ucs2length;
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts: opts2 } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts2.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts2.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts2.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts2.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/@redocly/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = validateAdditionalItems;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword: keyword2, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = validateTuple;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts: opts2, errSchemaPath } = it;
        const l2 = schArr.length;
        const fullTuple = l2 === sch.minItems && (l2 === sch.maxItems || sch[extraItems] === false);
        if (opts2.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l2}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts2.strictTuples);
        }
      }
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block2) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block2();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.error = void 0;
    exports.validatePropertyDeps = validatePropertyDeps;
    exports.validateSchemaDeps = validateSchemaDeps;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key2 in schema) {
        if (key2 === "__proto__")
          continue;
        const deps = Array.isArray(schema[key2]) ? propertyDeps : schemaDeps;
        deps[key2] = schema[key2];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key2) => {
          cxt.setParams({ propertyName: key2 });
          cxt.subschema({
            keyword: "propertyNames",
            data: key2,
            dataTypes: ["string"],
            propertyName: key2,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, data, errsCount, it } = cxt;
        const { schema = it.opts.defaultAdditionalProperties } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts: opts2 } = it;
        it.props = true;
        if (opts2.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key2) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key2);
            else
              gen.if(isAdditional(key2), () => additionalPropertyCode(key2));
          });
        }
        function isAdditional(key2) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key2);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key2} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key2})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key2) {
          gen.code((0, codegen_1._)`delete ${data}[${key2}]`);
        }
        function additionalPropertyCode(key2) {
          if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema === false) {
            deleteAdditional(key2);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key2 });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts2.removeAdditional === "failing") {
              applyAdditionalSchema(key2, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key2);
              });
            } else {
              applyAdditionalSchema(key2, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key2, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key2,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0 || it.opts.defaultAdditionalProperties === false) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts: opts2 } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key2) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key2})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key2,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key2}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid, true);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it, keyword2) {
      const schema = it.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = getApplicator;
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/dynamic/dynamicAnchor.js
var require_dynamicAnchor = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/dynamic/dynamicAnchor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dynamicAnchor = dynamicAnchor;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var ref_1 = require_ref();
    var def = {
      keyword: "$dynamicAnchor",
      schemaType: "string",
      code: (cxt) => dynamicAnchor(cxt, cxt.schema)
    };
    function dynamicAnchor(cxt, anchor) {
      const { gen, it } = cxt;
      it.schemaEnv.root.dynamicAnchors[anchor] = true;
      const v = (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;
      const validate = it.errSchemaPath === "#" ? it.validateName : _getValidate(cxt);
      gen.if((0, codegen_1._)`!${v}`, () => gen.assign(v, validate));
    }
    function _getValidate(cxt) {
      const { schemaEnv, schema, self: self2 } = cxt.it;
      const { root, baseId, localRefs, meta: meta2 } = schemaEnv.root;
      const { schemaId } = self2.opts;
      const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta: meta2 });
      compile_1.compileSchema.call(self2, sch);
      return (0, ref_1.getValidate)(cxt, sch);
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/dynamic/dynamicRef.js
var require_dynamicRef = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/dynamic/dynamicRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dynamicRef = dynamicRef;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var ref_1 = require_ref();
    var def = {
      keyword: "$dynamicRef",
      schemaType: "string",
      code: (cxt) => dynamicRef(cxt, cxt.schema)
    };
    function dynamicRef(cxt, ref) {
      const { gen, keyword: keyword2, it } = cxt;
      if (ref[0] !== "#")
        throw new Error(`"${keyword2}" only supports hash fragment reference`);
      const anchor = ref.slice(1);
      if (it.allErrors) {
        _dynamicRef();
      } else {
        const valid = gen.let("valid", false);
        _dynamicRef(valid);
        cxt.ok(valid);
      }
      function _dynamicRef(valid) {
        if (it.schemaEnv.root.dynamicAnchors[anchor]) {
          const v = gen.let("_v", (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);
          gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
        } else {
          _callRef(it.validateName, valid)();
        }
      }
      function _callRef(validate, valid) {
        return valid ? () => gen.block(() => {
          (0, ref_1.callRef)(cxt, validate);
          gen.let(valid, true);
        }) : () => (0, ref_1.callRef)(cxt, validate);
      }
    }
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/dynamic/recursiveAnchor.js
var require_recursiveAnchor = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/dynamic/recursiveAnchor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dynamicAnchor_1 = require_dynamicAnchor();
    var util_1 = require_util();
    var def = {
      keyword: "$recursiveAnchor",
      schemaType: "boolean",
      code(cxt) {
        if (cxt.schema)
          (0, dynamicAnchor_1.dynamicAnchor)(cxt, "");
        else
          (0, util_1.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/dynamic/recursiveRef.js
var require_recursiveRef = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/dynamic/recursiveRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dynamicRef_1 = require_dynamicRef();
    var def = {
      keyword: "$recursiveRef",
      schemaType: "string",
      code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema)
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/dynamic/index.js
var require_dynamic = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/dynamic/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dynamicAnchor_1 = require_dynamicAnchor();
    var dynamicRef_1 = require_dynamicRef();
    var recursiveAnchor_1 = require_recursiveAnchor();
    var recursiveRef_1 = require_recursiveRef();
    var dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
    exports.default = dynamic;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/dependentRequired.js
var require_dependentRequired = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/dependentRequired.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dependencies_1 = require_dependencies();
    var def = {
      keyword: "dependentRequired",
      type: "object",
      schemaType: "object",
      error: dependencies_1.error,
      code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt)
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/applicator/dependentSchemas.js
var require_dependentSchemas = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/applicator/dependentSchemas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dependencies_1 = require_dependencies();
    var def = {
      keyword: "dependentSchemas",
      type: "object",
      schemaType: "object",
      code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/validation/limitContains.js
var require_limitContains = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/validation/limitContains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["maxContains", "minContains"],
      type: "array",
      schemaType: "number",
      code({ keyword: keyword2, parentSchema, it }) {
        if (parentSchema.contains === void 0) {
          (0, util_1.checkStrictMode)(it, `"${keyword2}" without "contains" is ignored`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/next.js
var require_next = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/next.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dependentRequired_1 = require_dependentRequired();
    var dependentSchemas_1 = require_dependentSchemas();
    var limitContains_1 = require_limitContains();
    var next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
    exports.default = next;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js
var require_unevaluatedProperties = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var error = {
      message: "must NOT have unevaluated properties",
      params: ({ params }) => (0, codegen_1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
    };
    var def = {
      keyword: "unevaluatedProperties",
      type: "object",
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema = cxt.it.opts.defaultUnevaluatedProperties, data, errsCount, it } = cxt;
        const isForced = cxt.schema === void 0 && cxt.it.opts.defaultUnevaluatedProperties === false;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, props } = it;
        if (props instanceof codegen_1.Name) {
          gen.if((0, codegen_1._)`${props} !== true`, () => gen.forIn("key", data, (key2) => gen.if(unevaluatedDynamic(props, key2), () => unevaluatedPropCode(key2))));
        } else if (props !== true) {
          const staticCheck = () => gen.forIn("key", data, (key2) => props === void 0 ? unevaluatedPropCode(key2) : gen.if(unevaluatedStatic(props, key2), () => unevaluatedPropCode(key2)));
          if (isForced && it.errorPath.emptyStr()) {
            gen.if((0, codegen_1._)`${names_1.default.isAllOfVariant} === 0`, staticCheck);
          } else {
            staticCheck();
          }
        }
        if (!isForced) {
          it.props = true;
        }
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function unevaluatedPropCode(key2) {
          if (schema === false) {
            cxt.setParams({ unevaluatedProperty: key2 });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (!(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            cxt.subschema({
              keyword: "unevaluatedProperties",
              dataProp: key2,
              dataPropType: util_1.Type.Str
            }, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
        function unevaluatedDynamic(evaluatedProps, key2) {
          return (0, codegen_1._)`!${evaluatedProps} || !${evaluatedProps}[${key2}]`;
        }
        function unevaluatedStatic(evaluatedProps, key2) {
          const ps = [];
          for (const p in evaluatedProps) {
            if (evaluatedProps[p] === true)
              ps.push((0, codegen_1._)`${key2} !== ${p}`);
          }
          return (0, codegen_1.and)(...ps);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js
var require_unevaluatedItems = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "unevaluatedItems",
      type: "array",
      schemaType: ["boolean", "object"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        const items = it.items || 0;
        if (items === true)
          return;
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (schema === false) {
          cxt.setParams({ len: items });
          cxt.fail((0, codegen_1._)`${len} > ${items}`);
        } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items}`);
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));
          cxt.ok(valid);
        }
        it.items = true;
        function validateItems(valid, from) {
          gen.forRange("i", from, len, (i) => {
            cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/unevaluated/index.js
var require_unevaluated = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/unevaluated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var unevaluatedProperties_1 = require_unevaluatedProperties();
    var unevaluatedItems_1 = require_unevaluatedItems();
    var unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
    exports.default = unevaluated;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts2.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts2.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts2.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts2.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts2.code.formats ? (0, codegen_1._)`${opts2.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/draft2020.js
var require_draft2020 = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/draft2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core3();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var dynamic_1 = require_dynamic();
    var next_1 = require_next();
    var unevaluated_1 = require_unevaluated();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft2020Vocabularies = [
      dynamic_1.default,
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(true),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary,
      next_1.default,
      unevaluated_1.default
    ];
    exports.default = draft2020Vocabularies;
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/discriminator/types.js
var require_types3 = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/@redocly/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/@redocly/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types3();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf or anyOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const keyword2 = parentSchema.oneOf ? "oneOf" : parentSchema.anyOf ? "anyOf" : void 0;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (!keyword2)
          throw new Error("discriminator: requires oneOf or anyOf composite keyword");
        const parentSchemaVariants = parentSchema[keyword2];
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const discriminatorMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < parentSchemaVariants.length; i++) {
            let sch = parentSchemaVariants[i];
            const schRef = sch === null || sch === void 0 ? void 0 : sch.$ref;
            if (schRef && schema.mapping) {
              const { mapping } = schema;
              const matchedKeys = Object.keys(mapping).filter((key2) => mapping[key2] === sch.$ref);
              if (matchedKeys.length) {
                for (const key2 of matchedKeys) {
                  addMapping(key2, i);
                }
                continue;
              }
            }
            if (schRef && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, schRef);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: ${keyword2} subschemas (or referenced schemas) must have "properties/${tagName}" or match mapping`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return discriminatorMapping;
          function hasRequired({ required: required3 }) {
            return Array.isArray(required3) && required3.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in discriminatorMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            discriminatorMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/schema.json
var require_schema2 = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/schema.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/schema",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/core": true,
        "https://json-schema.org/draft/2020-12/vocab/applicator": true,
        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
        "https://json-schema.org/draft/2020-12/vocab/validation": true,
        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,
        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
        "https://json-schema.org/draft/2020-12/vocab/content": true
      },
      $dynamicAnchor: "meta",
      title: "Core and Validation specifications meta-schema",
      allOf: [
        { $ref: "meta/core" },
        { $ref: "meta/applicator" },
        { $ref: "meta/unevaluated" },
        { $ref: "meta/validation" },
        { $ref: "meta/meta-data" },
        { $ref: "meta/format-annotation" },
        { $ref: "meta/content" }
      ],
      type: ["object", "boolean"],
      $comment: "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.",
      properties: {
        definitions: {
          $comment: '"definitions" has been replaced by "$defs".',
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          deprecated: true,
          default: {}
        },
        dependencies: {
          $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
          type: "object",
          additionalProperties: {
            anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }]
          },
          deprecated: true,
          default: {}
        },
        $recursiveAnchor: {
          $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
          $ref: "meta/core#/$defs/anchorString",
          deprecated: true
        },
        $recursiveRef: {
          $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
          $ref: "meta/core#/$defs/uriReferenceString",
          deprecated: true
        }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/applicator.json
var require_applicator2 = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/applicator.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/applicator",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/applicator": true
      },
      $dynamicAnchor: "meta",
      title: "Applicator vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        prefixItems: { $ref: "#/$defs/schemaArray" },
        items: { $dynamicRef: "#meta" },
        contains: { $dynamicRef: "#meta" },
        additionalProperties: { $dynamicRef: "#meta" },
        properties: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependentSchemas: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" },
          default: {}
        },
        propertyNames: { $dynamicRef: "#meta" },
        if: { $dynamicRef: "#meta" },
        then: { $dynamicRef: "#meta" },
        else: { $dynamicRef: "#meta" },
        allOf: { $ref: "#/$defs/schemaArray" },
        anyOf: { $ref: "#/$defs/schemaArray" },
        oneOf: { $ref: "#/$defs/schemaArray" },
        not: { $dynamicRef: "#meta" }
      },
      $defs: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $dynamicRef: "#meta" }
        }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json
var require_unevaluated2 = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true
      },
      $dynamicAnchor: "meta",
      title: "Unevaluated applicator vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        unevaluatedItems: { $dynamicRef: "#meta" },
        unevaluatedProperties: { $dynamicRef: "#meta" }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/content.json
var require_content = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/content.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/content",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/content": true
      },
      $dynamicAnchor: "meta",
      title: "Content vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        contentSchema: { $dynamicRef: "#meta" }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/core.json
var require_core4 = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/core.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/core",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/core": true
      },
      $dynamicAnchor: "meta",
      title: "Core vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        $id: {
          $ref: "#/$defs/uriReferenceString",
          $comment: "Non-empty fragments not allowed.",
          pattern: "^[^#]*#?$"
        },
        $schema: { $ref: "#/$defs/uriString" },
        $ref: { $ref: "#/$defs/uriReferenceString" },
        $anchor: { $ref: "#/$defs/anchorString" },
        $dynamicRef: { $ref: "#/$defs/uriReferenceString" },
        $dynamicAnchor: { $ref: "#/$defs/anchorString" },
        $vocabulary: {
          type: "object",
          propertyNames: { $ref: "#/$defs/uriString" },
          additionalProperties: {
            type: "boolean"
          }
        },
        $comment: {
          type: "string"
        },
        $defs: {
          type: "object",
          additionalProperties: { $dynamicRef: "#meta" }
        }
      },
      $defs: {
        anchorString: {
          type: "string",
          pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
        },
        uriString: {
          type: "string",
          format: "uri"
        },
        uriReferenceString: {
          type: "string",
          format: "uri-reference"
        }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json
var require_format_annotation = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true
      },
      $dynamicAnchor: "meta",
      title: "Format vocabulary meta-schema for annotation results",
      type: ["object", "boolean"],
      properties: {
        format: { type: "string" }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json
var require_meta_data = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/meta-data": true
      },
      $dynamicAnchor: "meta",
      title: "Meta-data vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        deprecated: {
          type: "boolean",
          default: false
        },
        readOnly: {
          type: "boolean",
          default: false
        },
        writeOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/validation.json
var require_validation2 = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/meta/validation.json"(exports, module) {
    module.exports = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      $id: "https://json-schema.org/draft/2020-12/meta/validation",
      $vocabulary: {
        "https://json-schema.org/draft/2020-12/vocab/validation": true
      },
      $dynamicAnchor: "meta",
      title: "Validation vocabulary meta-schema",
      type: ["object", "boolean"],
      properties: {
        type: {
          anyOf: [
            { $ref: "#/$defs/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/$defs/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        const: true,
        enum: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/$defs/nonNegativeInteger" },
        minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        maxItems: { $ref: "#/$defs/nonNegativeInteger" },
        minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        maxContains: { $ref: "#/$defs/nonNegativeInteger" },
        minContains: {
          $ref: "#/$defs/nonNegativeInteger",
          default: 1
        },
        maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
        minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
        required: { $ref: "#/$defs/stringArray" },
        dependentRequired: {
          type: "object",
          additionalProperties: {
            $ref: "#/$defs/stringArray"
          }
        }
      },
      $defs: {
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          $ref: "#/$defs/nonNegativeInteger",
          default: 0
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      }
    };
  }
});

// node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/index.js
var require_json_schema_2020_12 = __commonJS({
  "node_modules/@redocly/ajv/dist/refs/json-schema-2020-12/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = addMetaSchema2020;
    var metaSchema = require_schema2();
    var applicator = require_applicator2();
    var unevaluated = require_unevaluated2();
    var content2 = require_content();
    var core = require_core4();
    var format = require_format_annotation();
    var metadata = require_meta_data();
    var validation = require_validation2();
    var META_SUPPORT_DATA = ["/properties"];
    function addMetaSchema2020($data) {
      ;
      [
        metaSchema,
        applicator,
        unevaluated,
        content2,
        core,
        with$data(this, format),
        metadata,
        with$data(this, validation)
      ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
      return this;
      function with$data(ajv, sch) {
        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
      }
    }
  }
});

// node_modules/@redocly/ajv/dist/2020.js
var require__ = __commonJS({
  "node_modules/@redocly/ajv/dist/2020.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core2();
    var draft2020_1 = require_draft2020();
    var discriminator_1 = require_discriminator();
    var json_schema_2020_12_1 = require_json_schema_2020_12();
    var META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
    var Ajv2020 = class extends core_1.default {
      constructor(opts2 = {}) {
        super({
          ...opts2,
          dynamicRef: true,
          next: true,
          unevaluated: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        draft2020_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data, meta: meta2 } = this.opts;
        if (!meta2)
          return;
        json_schema_2020_12_1.default.call(this, $data);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module.exports = exports = Ajv2020;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2020;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
  }
});

// node_modules/@redocly/openapi-core/lib/types/json-schema-adapter.js
var require_json_schema_adapter = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/json-schema-adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNodeTypesFromJSONSchema = getNodeTypesFromJSONSchema;
    var _2020_1 = require__();
    var utils_1 = require_utils();
    var ajv = new _2020_1.default({
      strictSchema: false,
      allowUnionTypes: true,
      useDefaults: true,
      allErrors: true,
      discriminator: true,
      strictTypes: false,
      verbose: true
    });
    function findOneOf(schemaOneOf, oneOfs) {
      if (oneOfs.some((option) => typeof option === "function")) {
        throw new Error("Unexpected oneOf inside oneOf.");
      }
      return (value) => {
        let index2 = schemaOneOf.findIndex((option) => ajv.validate(option, value));
        if (index2 === -1) {
          index2 = 0;
        }
        return oneOfs[index2];
      };
    }
    function transformJSONSchemaToNodeType(propertyName2, schema, ctx) {
      var _a2;
      if (!schema || typeof schema === "boolean") {
        throw new Error(`Unexpected schema in ${propertyName2}.`);
      }
      if (schema instanceof Array) {
        throw new Error(`Unexpected array schema in ${propertyName2}. Try using oneOf instead.`);
      }
      if (schema.type === "null") {
        throw new Error(`Unexpected null schema type in ${propertyName2} schema.`);
      }
      if (schema.type instanceof Array) {
        throw new Error(`Unexpected array schema type in ${propertyName2} schema. Try using oneOf instead.`);
      }
      if (schema.type === "string" || schema.type === "number" || schema.type === "integer" || schema.type === "boolean") {
        const { default: _, format: _format, ...rest } = schema;
        return rest;
      }
      if (schema.type === "object" && !schema.properties && !schema.oneOf) {
        if (schema.additionalProperties === void 0 || schema.additionalProperties === true) {
          return { type: "object" };
        } else if (schema.additionalProperties === false) {
          return { type: "object", properties: {} };
        }
      }
      if (schema.allOf) {
        throw new Error(`Unexpected allOf in ${propertyName2}.`);
      }
      if (schema.anyOf) {
        throw new Error(`Unexpected anyOf in ${propertyName2}.`);
      }
      if ((0, utils_1.isPlainObject)(schema.properties) || (0, utils_1.isPlainObject)(schema.additionalProperties) || (0, utils_1.isPlainObject)(schema.items) && ((0, utils_1.isPlainObject)(schema.items.properties) || (0, utils_1.isPlainObject)(schema.items.additionalProperties) || schema.items.oneOf)) {
        return extractNodeToContext(propertyName2, schema, ctx);
      }
      if (schema.oneOf) {
        if (schema.discriminator) {
          const discriminatedPropertyName = (_a2 = schema.discriminator) == null ? void 0 : _a2.propertyName;
          if (!discriminatedPropertyName) {
            throw new Error(`Unexpected discriminator without a propertyName in ${propertyName2}.`);
          }
          const oneOfs = schema.oneOf.map((option, i) => {
            var _a3;
            if (typeof option === "boolean") {
              throw new Error(`Unexpected boolean schema in ${propertyName2} at position ${i} in oneOf.`);
            }
            const discriminatedProperty = (_a3 = option == null ? void 0 : option.properties) == null ? void 0 : _a3[discriminatedPropertyName];
            if (!discriminatedProperty || typeof discriminatedProperty === "boolean") {
              throw new Error(`Unexpected property '${discriminatedProperty}' schema in ${propertyName2} at position ${i} in oneOf.`);
            }
            const name2 = discriminatedProperty.const;
            return transformJSONSchemaToNodeType(name2, option, ctx);
          });
          return (value, key2) => {
            if ((0, utils_1.isPlainObject)(value)) {
              const discriminatedTypeName = value[discriminatedPropertyName];
              if (typeof discriminatedTypeName === "string" && ctx[discriminatedTypeName]) {
                return discriminatedTypeName;
              }
            }
            return findOneOf(schema.oneOf, oneOfs)(value, key2);
          };
        } else {
          const oneOfs = schema.oneOf.map((option, i) => transformJSONSchemaToNodeType(propertyName2 + "_" + i, option, ctx));
          return findOneOf(schema.oneOf, oneOfs);
        }
      }
      return schema;
    }
    function extractNodeToContext(propertyName2, schema, ctx) {
      if (!schema || typeof schema === "boolean") {
        throw new Error(`Unexpected schema in ${propertyName2}.`);
      }
      if (schema instanceof Array) {
        throw new Error(`Unexpected array schema in ${propertyName2}. Try using oneOf instead.`);
      }
      if (schema.type === "null") {
        throw new Error(`Unexpected null schema type in ${propertyName2} schema.`);
      }
      if (schema.type instanceof Array) {
        throw new Error(`Unexpected array schema type in ${propertyName2} schema. Try using oneOf instead.`);
      }
      const properties = {};
      for (const [name2, property] of Object.entries(schema.properties || {})) {
        properties[name2] = transformJSONSchemaToNodeType(propertyName2 + "." + name2, property, ctx);
      }
      let additionalProperties;
      if ((0, utils_1.isPlainObject)(schema.additionalProperties)) {
        additionalProperties = transformJSONSchemaToNodeType(propertyName2 + "_additionalProperties", schema.additionalProperties, ctx);
      }
      if (schema.additionalProperties === true) {
        additionalProperties = {};
      }
      let items;
      if ((0, utils_1.isPlainObject)(schema.items) && ((0, utils_1.isPlainObject)(schema.items.properties) || (0, utils_1.isPlainObject)(schema.items.additionalProperties) || schema.items.oneOf)) {
        items = transformJSONSchemaToNodeType(propertyName2 + "_items", schema.items, ctx);
      }
      let required3 = schema.required;
      if (schema.oneOf && schema.oneOf.every((option) => !!option.required)) {
        required3 = (value) => {
          const requiredList = schema.oneOf.map((option) => [
            ...schema.required || [],
            ...option.required
          ]);
          let index2 = requiredList.findIndex((r) => r.every((requiredProp) => value[requiredProp] !== void 0));
          if (index2 === -1) {
            index2 = 0;
          }
          return requiredList[index2];
        };
      }
      ctx[propertyName2] = { properties, additionalProperties, items, required: required3 };
      return propertyName2;
    }
    function getNodeTypesFromJSONSchema(schemaName, entrySchema) {
      const ctx = {};
      transformJSONSchemaToNodeType(schemaName, entrySchema, ctx);
      return ctx;
    }
  }
});

// node_modules/@redocly/openapi-core/lib/types/redocly-yaml.js
var require_redocly_yaml = __commonJS({
  "node_modules/@redocly/openapi-core/lib/types/redocly-yaml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NormalizedConfigTypes = exports.ConfigTypes = void 0;
    exports.createConfigTypes = createConfigTypes;
    var config_1 = require_lib();
    var _1 = require_types();
    var oas_types_1 = require_oas_types();
    var utils_1 = require_utils();
    var json_schema_adapter_1 = require_json_schema_adapter();
    var types_1 = require_types();
    var builtInOAS2Rules = [
      "info-contact",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "info-license-url",
      "info-license-strict",
      "info-license",
      "no-ambiguous-paths",
      "no-enum-type-mismatch",
      "no-http-verbs-in-paths",
      "no-identical-paths",
      "no-invalid-parameter-examples",
      "no-invalid-schema-examples",
      "no-path-trailing-slash",
      "operation-2xx-response",
      "operation-4xx-response",
      "operation-description",
      "operation-operationId-unique",
      "operation-operationId-url-safe",
      "operation-parameters-unique",
      "operation-singular-tag",
      "operation-summary",
      "operation-tag-defined",
      "parameter-description",
      "path-declaration-must-exist",
      "path-excludes-patterns",
      "path-http-verbs-order",
      "path-not-include-query",
      "path-params-defined",
      "path-parameters-defined",
      "path-segment-plural",
      "paths-kebab-case",
      "required-string-property-missing-min-length",
      "response-contains-header",
      "scalar-property-missing-example",
      "security-defined",
      "spec-strict-refs",
      "no-unresolved-refs",
      "no-required-schema-properties-undefined",
      "no-schema-type-mismatch",
      "boolean-parameter-prefixes",
      "request-mime-type",
      "response-contains-property",
      "response-mime-type"
    ];
    var builtInOAS3Rules = [
      "info-contact",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "info-license-url",
      "info-license-strict",
      "info-license",
      "no-ambiguous-paths",
      "no-enum-type-mismatch",
      "no-http-verbs-in-paths",
      "no-identical-paths",
      "no-invalid-parameter-examples",
      "no-invalid-schema-examples",
      "no-path-trailing-slash",
      "operation-2xx-response",
      "operation-4xx-response",
      "operation-description",
      "operation-operationId-unique",
      "operation-operationId-url-safe",
      "operation-parameters-unique",
      "operation-singular-tag",
      "operation-summary",
      "operation-tag-defined",
      "parameter-description",
      "path-declaration-must-exist",
      "path-excludes-patterns",
      "path-http-verbs-order",
      "path-not-include-query",
      "path-params-defined",
      "path-parameters-defined",
      "path-segment-plural",
      "paths-kebab-case",
      "required-string-property-missing-min-length",
      "response-contains-header",
      "scalar-property-missing-example",
      "security-defined",
      "spec-strict-refs",
      "no-unresolved-refs",
      "no-required-schema-properties-undefined",
      "no-schema-type-mismatch",
      "boolean-parameter-prefixes",
      "component-name-unique",
      "no-empty-servers",
      "no-example-value-and-externalValue",
      "no-invalid-media-type-examples",
      "no-server-example.com",
      "no-server-trailing-slash",
      "no-server-variables-empty-enum",
      "no-undefined-server-variable",
      "no-unused-components",
      "operation-4xx-problem-details-rfc7807",
      "request-mime-type",
      "response-contains-property",
      "response-mime-type",
      "spec-components-invalid-map-name",
      "array-parameter-serialization"
    ];
    var builtInAsync2Rules = [
      "info-contact",
      "info-license-strict",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "channels-kebab-case",
      "no-channel-trailing-slash"
    ];
    var builtInAsync3Rules = [
      "info-contact",
      "info-license-strict",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "channels-kebab-case",
      "no-channel-trailing-slash"
    ];
    var builtInArazzo1Rules = [
      "sourceDescription-type",
      "workflowId-unique",
      "stepId-unique",
      "sourceDescription-name-unique",
      "sourceDescriptions-not-empty",
      "workflow-dependsOn",
      "parameters-unique",
      "step-onSuccess-unique",
      "step-onFailure-unique",
      "respect-supported-versions",
      "requestBody-replacements-unique",
      "no-criteria-xpath",
      "criteria-unique"
    ];
    var builtInOverlay1Rules = ["info-contact"];
    var builtInRules = [
      ...builtInOAS2Rules,
      ...builtInOAS3Rules,
      ...builtInAsync2Rules,
      ...builtInAsync3Rules,
      ...builtInArazzo1Rules,
      ...builtInOverlay1Rules,
      "spec",
      // TODO: depricated in favor of struct
      "struct"
    ];
    var ConfigStyleguide = {
      properties: {
        extends: {
          type: "array",
          items: {
            type: "string"
          }
        },
        rules: "Rules",
        oas2Rules: "Rules",
        oas3_0Rules: "Rules",
        oas3_1Rules: "Rules",
        async2Rules: "Rules",
        arazzo1Rules: "Rules",
        preprocessors: { type: "object" },
        oas2Preprocessors: { type: "object" },
        oas3_0Preprocessors: { type: "object" },
        oas3_1Preprocessors: { type: "object" },
        async2Preprocessors: { type: "object" },
        arazzoPreprocessors: { type: "object" },
        decorators: { type: "object" },
        oas2Decorators: { type: "object" },
        oas3_0Decorators: { type: "object" },
        oas3_1Decorators: { type: "object" },
        async2Decorators: { type: "object" },
        arazzo1Decorators: { type: "object" }
      }
    };
    var createConfigRoot = (nodeTypes) => ({
      ...nodeTypes.rootRedoclyConfigSchema,
      properties: {
        ...nodeTypes.rootRedoclyConfigSchema.properties,
        ...ConfigStyleguide.properties,
        apis: "ConfigApis",
        // Override apis with internal format
        "features.openapi": "ConfigReferenceDocs",
        // deprecated
        "features.mockServer": "ConfigMockServer",
        // deprecated
        organization: { type: "string" },
        region: { enum: ["us", "eu"] },
        telemetry: { enum: ["on", "off"] },
        resolve: {
          properties: {
            http: "ConfigHTTP",
            doNotResolveExamples: { type: "boolean" }
          }
        },
        files: {
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    });
    var ConfigApis = {
      properties: {},
      additionalProperties: "ConfigApisProperties"
    };
    var createConfigApisProperties = (nodeTypes) => {
      var _a2;
      return {
        ...nodeTypes["rootRedoclyConfigSchema.apis_additionalProperties"],
        properties: {
          ...(_a2 = nodeTypes["rootRedoclyConfigSchema.apis_additionalProperties"]) == null ? void 0 : _a2.properties,
          labels: {
            type: "array",
            items: {
              type: "string"
            }
          },
          ...ConfigStyleguide.properties,
          "features.openapi": "ConfigReferenceDocs",
          // deprecated
          "features.mockServer": "ConfigMockServer",
          // deprecated
          files: {
            type: "array",
            items: {
              type: "string"
            }
          }
        }
      };
    };
    var ConfigHTTP = {
      properties: {
        headers: {
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    };
    var Rules = {
      properties: {},
      additionalProperties: (value, key2) => {
        if (key2.startsWith("rule/")) {
          if (typeof value === "string") {
            return { enum: ["error", "warn", "off"] };
          } else {
            return "Assert";
          }
        } else if (key2.startsWith("assert/")) {
          if (typeof value === "string") {
            return { enum: ["error", "warn", "off"] };
          } else {
            return "Assert";
          }
        } else if (builtInRules.includes(key2) || (0, utils_1.isCustomRuleId)(key2)) {
          if (typeof value === "string") {
            return { enum: ["error", "warn", "off"] };
          } else {
            return "ObjectRule";
          }
        } else if (key2 === "metadata-schema" || key2 === "custom-fields-schema") {
          return "Schema";
        }
        return;
      }
    };
    var ObjectRule = {
      properties: {
        severity: { enum: ["error", "warn", "off"] }
      },
      additionalProperties: {},
      required: ["severity"]
    };
    var Schema2 = {
      properties: {},
      additionalProperties: {}
    };
    function createAssertionDefinitionSubject(nodeNames) {
      return {
        properties: {
          type: {
            enum: [.../* @__PURE__ */ new Set(["any", ...nodeNames, "SpecExtension"])]
          },
          property: (value) => {
            if (Array.isArray(value)) {
              return { type: "array", items: { type: "string" } };
            } else if (value === null) {
              return null;
            } else {
              return { type: "string" };
            }
          },
          filterInParentKeys: { type: "array", items: { type: "string" } },
          filterOutParentKeys: { type: "array", items: { type: "string" } },
          matchParentKeys: { type: "string" }
        },
        required: ["type"]
      };
    }
    var AssertionDefinitionAssertions = {
      properties: {
        enum: { type: "array", items: { type: "string" } },
        pattern: { type: "string" },
        notPattern: { type: "string" },
        casing: {
          enum: [
            "camelCase",
            "kebab-case",
            "snake_case",
            "PascalCase",
            "MACRO_CASE",
            "COBOL-CASE",
            "flatcase"
          ]
        },
        mutuallyExclusive: { type: "array", items: { type: "string" } },
        mutuallyRequired: { type: "array", items: { type: "string" } },
        required: { type: "array", items: { type: "string" } },
        requireAny: { type: "array", items: { type: "string" } },
        disallowed: { type: "array", items: { type: "string" } },
        defined: { type: "boolean" },
        // undefined: { type: 'boolean' }, // TODO: Remove `undefined` assertion from codebase overall
        nonEmpty: { type: "boolean" },
        minLength: { type: "integer" },
        maxLength: { type: "integer" },
        ref: (value) => typeof value === "string" ? { type: "string" } : { type: "boolean" },
        const: (value) => {
          if (typeof value === "string") {
            return { type: "string" };
          }
          if (typeof value === "number") {
            return { type: "number" };
          }
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return;
          }
        }
      },
      additionalProperties: (_value, key2) => {
        if (/^\w+\/\w+$/.test(key2))
          return { type: "object" };
        return;
      }
    };
    var AssertDefinition = {
      properties: {
        subject: "AssertionDefinitionSubject",
        assertions: "AssertionDefinitionAssertions"
      },
      required: ["subject", "assertions"]
    };
    var Assert = {
      properties: {
        subject: "AssertionDefinitionSubject",
        assertions: "AssertionDefinitionAssertions",
        where: (0, _1.listOf)("AssertDefinition"),
        message: { type: "string" },
        suggest: { type: "array", items: { type: "string" } },
        severity: { enum: ["error", "warn", "off"] }
      },
      required: ["subject", "assertions"]
    };
    var ConfigLanguage = {
      properties: {
        label: { type: "string" },
        lang: {
          enum: [
            "curl",
            "C#",
            "Go",
            "Java",
            "Java8+Apache",
            "JavaScript",
            "Node.js",
            "PHP",
            "Python",
            "R",
            "Ruby"
          ]
        }
      },
      required: ["lang"]
    };
    var ConfigLabels = {
      properties: {
        enum: { type: "string" },
        enumSingleValue: { type: "string" },
        enumArray: { type: "string" },
        default: { type: "string" },
        deprecated: { type: "string" },
        example: { type: "string" },
        examples: { type: "string" },
        nullable: { type: "string" },
        recursive: { type: "string" },
        arrayOf: { type: "string" },
        webhook: { type: "string" },
        authorizations: { type: "string" },
        tryItAuthBasicUsername: { type: "string" },
        tryItAuthBasicPassword: { type: "string" }
      }
    };
    var ConfigSidebarLinks = {
      properties: {
        beforeInfo: (0, _1.listOf)("CommonConfigSidebarLinks"),
        end: (0, _1.listOf)("CommonConfigSidebarLinks")
      }
    };
    var CommonConfigSidebarLinks = {
      properties: {
        label: { type: "string" },
        link: { type: "string" },
        target: { type: "string" }
      },
      required: ["label", "link"]
    };
    var CommonThemeColors = {
      properties: {
        main: { type: "string" },
        light: { type: "string" },
        dark: { type: "string" },
        contrastText: { type: "string" }
      }
    };
    var CommonColorProps = {
      properties: {
        backgroundColor: { type: "string" },
        borderColor: { type: "string" },
        color: { type: "string" },
        tabTextColor: { type: "string" }
      }
    };
    var BorderThemeColors = {
      properties: (0, utils_1.pickObjectProps)(CommonThemeColors.properties, ["light", "dark"])
    };
    var HttpColors = {
      properties: {
        basic: { type: "string" },
        delete: { type: "string" },
        get: { type: "string" },
        head: { type: "string" },
        link: { type: "string" },
        options: { type: "string" },
        patch: { type: "string" },
        post: { type: "string" },
        put: { type: "string" }
      }
    };
    var ResponseColors = {
      properties: {
        error: "CommonColorProps",
        info: "CommonColorProps",
        redirect: "CommonColorProps",
        success: "CommonColorProps"
      }
    };
    var SecondaryColors = {
      properties: (0, utils_1.omitObjectProps)(CommonThemeColors.properties, ["dark"])
    };
    var TextThemeColors = {
      properties: {
        primary: { type: "string" },
        secondary: { type: "string" },
        light: { type: "string" }
      }
    };
    var ThemeColors = {
      properties: {
        accent: "CommonThemeColors",
        border: "BorderThemeColors",
        error: "CommonThemeColors",
        http: "HttpColors",
        primary: "CommonThemeColors",
        responses: "ResponseColors",
        secondary: "SecondaryColors",
        success: "CommonThemeColors",
        text: "TextThemeColors",
        tonalOffset: { type: "number" },
        warning: "CommonThemeColors"
      }
    };
    var SizeProps = {
      properties: {
        fontSize: { type: "string" },
        padding: { type: "string" },
        minWidth: { type: "string" }
      }
    };
    var Sizes = {
      properties: {
        small: "SizeProps",
        medium: "SizeProps",
        large: "SizeProps",
        xlarge: "SizeProps"
      }
    };
    var FontConfig = {
      properties: {
        fontFamily: { type: "string" },
        fontSize: { type: "string" },
        fontWeight: { type: "string" },
        lineHeight: { type: "string" }
      }
    };
    var ButtonsConfig = {
      properties: {
        ...(0, utils_1.omitObjectProps)(FontConfig.properties, ["fontSize", "lineHeight"]),
        borderRadius: { type: "string" },
        hoverStyle: { type: "string" },
        boxShadow: { type: "string" },
        hoverBoxShadow: { type: "string" },
        sizes: "Sizes"
      }
    };
    var BadgeFontConfig = {
      properties: (0, utils_1.pickObjectProps)(FontConfig.properties, ["fontSize", "lineHeight"])
    };
    var BadgeSizes = {
      properties: {
        medium: "BadgeFontConfig",
        small: "BadgeFontConfig"
      }
    };
    var HttpBadgesConfig = {
      properties: {
        ...(0, utils_1.omitObjectProps)(FontConfig.properties, ["fontSize", "lineHeight"]),
        borderRadius: { type: "string" },
        color: { type: "string" },
        sizes: "BadgeSizes"
      }
    };
    var LabelControls = {
      properties: {
        top: { type: "string" },
        width: { type: "string" },
        height: { type: "string" }
      }
    };
    var Panels = {
      properties: {
        borderRadius: { type: "string" },
        backgroundColor: { type: "string" }
      }
    };
    var TryItButton2 = {
      properties: {
        fullWidth: { type: "boolean" }
      }
    };
    var ConfigThemeComponents = {
      properties: {
        buttons: "ButtonsConfig",
        httpBadges: "HttpBadgesConfig",
        layoutControls: "LabelControls",
        panels: "Panels",
        tryItButton: "TryItButton",
        tryItSendButton: "TryItButton"
      }
    };
    var Breakpoints = {
      properties: {
        small: { type: "string" },
        medium: { type: "string" },
        large: { type: "string" }
      }
    };
    var StackedConfig = {
      properties: {
        maxWidth: "Breakpoints"
      }
    };
    var ThreePanelConfig = {
      properties: {
        maxWidth: "Breakpoints",
        middlePanelMaxWidth: "Breakpoints"
      }
    };
    var Layout = {
      properties: {
        showDarkRightPanel: { type: "boolean" },
        stacked: "StackedConfig",
        "three-panel": "ThreePanelConfig"
      }
    };
    var SchemaColorsConfig = {
      properties: {
        backgroundColor: { type: "string" },
        border: { type: "string" }
      }
    };
    var ConfigThemeSchema = {
      properties: {
        breakFieldNames: { type: "boolean" },
        caretColor: { type: "string" },
        caretSize: { type: "string" },
        constraints: "SchemaColorsConfig",
        defaultDetailsWidth: { type: "string" },
        examples: "SchemaColorsConfig",
        labelsTextSize: { type: "string" },
        linesColor: { type: "string" },
        nestedBackground: { type: "string" },
        nestingSpacing: { type: "string" },
        requireLabelColor: { type: "string" },
        typeNameColor: { type: "string" },
        typeTitleColor: { type: "string" }
      }
    };
    var GroupItemsConfig = {
      properties: {
        subItemsColor: { type: "string" },
        textTransform: { type: "string" },
        fontWeight: { type: "string" }
      }
    };
    var Level1Items = {
      properties: (0, utils_1.pickObjectProps)(GroupItemsConfig.properties, ["textTransform"])
    };
    var SpacingConfig = {
      properties: {
        unit: { type: "number" },
        paddingHorizontal: { type: "string" },
        paddingVertical: { type: "string" },
        offsetTop: { type: "string" },
        offsetLeft: { type: "string" },
        offsetNesting: { type: "string" }
      }
    };
    var Sidebar = {
      properties: {
        ...(0, utils_1.omitObjectProps)(FontConfig.properties, ["fontWeight", "lineHeight"]),
        activeBgColor: { type: "string" },
        activeTextColor: { type: "string" },
        backgroundColor: { type: "string" },
        borderRadius: { type: "string" },
        breakPath: { type: "boolean" },
        caretColor: { type: "string" },
        caretSize: { type: "string" },
        groupItems: "GroupItemsConfig",
        level1items: "Level1Items",
        rightLineColor: { type: "string" },
        separatorLabelColor: { type: "string" },
        showAtBreakpoint: { type: "string" },
        spacing: "SpacingConfig",
        textColor: { type: "string" },
        width: { type: "string" }
      }
    };
    var Heading = {
      properties: {
        ...FontConfig.properties,
        color: { type: "string" },
        transform: { type: "string" }
      }
    };
    var CodeConfig = {
      properties: {
        ...FontConfig.properties,
        backgroundColor: { type: "string" },
        color: { type: "string" },
        wordBreak: {
          enum: [
            "break-all",
            "break-word",
            "keep-all",
            "normal",
            "revert",
            "unset",
            "inherit",
            "initial"
          ]
        },
        wrap: { type: "boolean" }
      }
    };
    var HeadingsConfig = {
      properties: (0, utils_1.omitObjectProps)(FontConfig.properties, ["fontSize"])
    };
    var LinksConfig = {
      properties: {
        color: { type: "string" },
        hover: { type: "string" },
        textDecoration: { type: "string" },
        hoverTextDecoration: { type: "string" },
        visited: { type: "string" }
      }
    };
    var Typography = {
      properties: {
        code: "CodeConfig",
        fieldName: "FontConfig",
        ...(0, utils_1.pickObjectProps)(FontConfig.properties, ["fontSize", "fontFamily"]),
        fontWeightBold: { type: "string" },
        fontWeightLight: { type: "string" },
        fontWeightRegular: { type: "string" },
        heading1: "Heading",
        heading2: "Heading",
        heading3: "Heading",
        headings: "HeadingsConfig",
        lineHeight: { type: "string" },
        links: "LinksConfig",
        optimizeSpeed: { type: "boolean" },
        rightPanelHeading: "Heading",
        smoothing: { enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"] }
      }
    };
    var TokenProps = {
      properties: {
        color: { type: "string" },
        ...(0, utils_1.omitObjectProps)(FontConfig.properties, ["fontWeight"])
      }
    };
    var CodeBlock = {
      properties: {
        backgroundColor: { type: "string" },
        borderRadius: { type: "string" },
        tokens: "TokenProps"
      }
    };
    var ConfigThemeLogo = {
      properties: {
        gutter: { type: "string" },
        maxHeight: { type: "string" },
        maxWidth: { type: "string" }
      }
    };
    var Fab = {
      properties: {
        backgroundColor: { type: "string" },
        color: { type: "string" }
      }
    };
    var ButtonOverrides = {
      properties: {
        custom: { type: "string" }
      }
    };
    var Overrides = {
      properties: {
        DownloadButton: "ButtonOverrides",
        NextSectionButton: "ButtonOverrides"
      }
    };
    var RightPanel2 = {
      properties: {
        backgroundColor: { type: "string" },
        panelBackgroundColor: { type: "string" },
        panelControlsBackgroundColor: { type: "string" },
        showAtBreakpoint: { type: "string" },
        textColor: { type: "string" },
        width: { type: "string" }
      }
    };
    var Shape = {
      properties: { borderRadius: { type: "string" } }
    };
    var ThemeSpacing = {
      properties: {
        sectionHorizontal: { type: "number" },
        sectionVertical: { type: "number" },
        unit: { type: "number" }
      }
    };
    var ConfigTheme = {
      properties: {
        breakpoints: "Breakpoints",
        codeBlock: "CodeBlock",
        colors: "ThemeColors",
        components: "ConfigThemeComponents",
        layout: "Layout",
        logo: "ConfigThemeLogo",
        fab: "Fab",
        overrides: "Overrides",
        rightPanel: "RightPanel",
        schema: "ConfigThemeSchema",
        shape: "Shape",
        sidebar: "Sidebar",
        spacing: "ThemeSpacing",
        typography: "Typography",
        links: { properties: { color: { type: "string" } } },
        // deprecated
        codeSample: { properties: { backgroundColor: { type: "string" } } }
        // deprecated
      }
    };
    var GenerateCodeSamples = {
      properties: {
        skipOptionalParameters: { type: "boolean" },
        languages: (0, _1.listOf)("ConfigLanguage")
      },
      required: ["languages"]
    };
    var ConfigReferenceDocs = {
      properties: {
        theme: "ConfigTheme",
        corsProxyUrl: { type: "string" },
        ctrlFHijack: { type: "boolean" },
        defaultSampleLanguage: { type: "string" },
        disableDeepLinks: { type: "boolean" },
        disableSearch: { type: "boolean" },
        disableSidebar: { type: "boolean" },
        downloadDefinitionUrl: { type: "string" },
        expandDefaultServerVariables: { type: "boolean" },
        enumSkipQuotes: { type: "boolean" },
        expandDefaultRequest: { type: "boolean" },
        expandDefaultResponse: { type: "boolean" },
        expandResponses: { type: "string" },
        expandSingleSchemaField: { type: "boolean" },
        generateCodeSamples: "GenerateCodeSamples",
        generatedPayloadSamplesMaxDepth: { type: "number" },
        hideDownloadButton: { type: "boolean" },
        hideHostname: { type: "boolean" },
        hideInfoSection: { type: "boolean" },
        hideLoading: { type: "boolean" },
        hideLogo: { type: "boolean" },
        hideRequestPayloadSample: { type: "boolean" },
        hideRightPanel: { type: "boolean" },
        hideSchemaPattern: { type: "boolean" },
        hideSchemaTitles: { type: "boolean" },
        hideSingleRequestSampleTab: { type: "boolean" },
        hideSecuritySection: { type: "boolean" },
        hideTryItPanel: { type: "boolean" },
        hideFab: { type: "boolean" },
        hideOneOfDescription: { type: "boolean" },
        htmlTemplate: { type: "string" },
        jsonSampleExpandLevel: (value) => {
          if (typeof value === "number") {
            return { type: "number", minimum: 1 };
          } else {
            return { type: "string" };
          }
        },
        labels: "ConfigLabels",
        layout: { enum: ["stacked", "three-panel"] },
        maxDisplayedEnumValues: { type: "number" },
        menuToggle: { type: "boolean" },
        nativeScrollbars: { type: "boolean" },
        noAutoAuth: { type: "boolean" },
        // deprecated
        oAuth2RedirectURI: { type: "string" },
        onDeepLinkClick: { type: "object" },
        onlyRequiredInSamples: { type: "boolean" },
        pagination: { enum: ["none", "section", "item"] },
        pathInMiddlePanel: { type: "boolean" },
        payloadSampleIdx: { type: "number", minimum: 0 },
        requestInterceptor: { type: "object" },
        requiredPropsFirst: { type: "boolean" },
        routingBasePath: { type: "string" },
        routingStrategy: { type: "string" },
        // deprecated
        samplesTabsMaxCount: { type: "number" },
        schemaExpansionLevel: (value) => {
          if (typeof value === "number") {
            return { type: "number", minimum: 0 };
          } else {
            return { type: "string" };
          }
        },
        schemaDefinitionsTagName: { type: "string" },
        minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
        maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
        scrollYOffset: (value) => {
          if (typeof value === "number") {
            return { type: "number" };
          } else {
            return { type: "string" };
          }
        },
        searchAutoExpand: { type: "boolean" },
        searchFieldLevelBoost: { type: "number", minimum: 0 },
        searchMaxDepth: { type: "number", minimum: 1 },
        searchMode: { enum: ["default", "path-only"] },
        searchOperationTitleBoost: { type: "number" },
        searchTagTitleBoost: { type: "number" },
        sendXUserAgentInTryIt: { type: "boolean" },
        showChangeLayoutButton: { type: "boolean" },
        showConsole: { type: "boolean" },
        // deprecated
        showExtensions: (value) => {
          if (typeof value === "boolean") {
            return { type: "boolean" };
          } else {
            return {
              type: "array",
              items: {
                type: "string"
              }
            };
          }
        },
        showNextButton: { type: "boolean" },
        showRightPanelToggle: { type: "boolean" },
        showSecuritySchemeType: { type: "boolean" },
        showWebhookVerb: { type: "boolean" },
        showObjectSchemaExamples: { type: "boolean" },
        disableTryItRequestUrlEncoding: { type: "boolean" },
        sidebarLinks: "ConfigSidebarLinks",
        sideNavStyle: { enum: ["summary-only", "path-first", "id-only", "path-only"] },
        simpleOneOfTypeLabel: { type: "boolean" },
        sortEnumValuesAlphabetically: { type: "boolean" },
        sortOperationsAlphabetically: { type: "boolean" },
        sortPropsAlphabetically: { type: "boolean" },
        sortTagsAlphabetically: { type: "boolean" },
        suppressWarnings: { type: "boolean" },
        // deprecated
        unstable_externalDescription: { type: "boolean" },
        // deprecated
        unstable_ignoreMimeParameters: { type: "boolean" },
        untrustedDefinition: { type: "boolean" },
        mockServer: {
          properties: {
            url: { type: "string" },
            position: { enum: ["first", "last", "replace", "off"] },
            description: { type: "string" }
          }
        },
        showAccessMode: { type: "boolean" },
        preserveOriginalExtensionsName: { type: "boolean" },
        markdownHeadingsAnchorLevel: { type: "number" }
      },
      additionalProperties: {}
    };
    var ConfigMockServer = {
      properties: {
        strictExamples: { type: "boolean" },
        errorIfForcedExampleNotFound: { type: "boolean" }
      }
    };
    function createConfigTypes(extraSchemas, config3) {
      const nodeNames = Object.values(oas_types_1.SpecVersion).flatMap((version) => {
        const types2 = (config3 == null ? void 0 : config3.styleguide) ? config3.styleguide.extendTypes((0, oas_types_1.getTypes)(version), version) : (0, oas_types_1.getTypes)(version);
        return Object.keys(types2);
      });
      const nodeTypes = (0, json_schema_adapter_1.getNodeTypesFromJSONSchema)("rootRedoclyConfigSchema", extraSchemas);
      return {
        ...CoreConfigTypes,
        ConfigRoot: createConfigRoot(nodeTypes),
        // This is the REAL config root type
        ConfigApisProperties: createConfigApisProperties(nodeTypes),
        AssertionDefinitionSubject: createAssertionDefinitionSubject(nodeNames),
        ...nodeTypes
      };
    }
    var CoreConfigTypes = {
      Assert,
      ConfigApis,
      ConfigStyleguide,
      ConfigReferenceDocs,
      ConfigMockServer,
      ConfigHTTP,
      ConfigLanguage,
      ConfigLabels,
      ConfigSidebarLinks,
      CommonConfigSidebarLinks,
      ConfigTheme,
      AssertDefinition,
      ThemeColors,
      CommonThemeColors,
      BorderThemeColors,
      HttpColors,
      ResponseColors,
      SecondaryColors,
      TextThemeColors,
      Sizes,
      ButtonsConfig,
      CommonColorProps,
      BadgeFontConfig,
      BadgeSizes,
      HttpBadgesConfig,
      LabelControls,
      Panels,
      TryItButton: TryItButton2,
      Breakpoints,
      StackedConfig,
      ThreePanelConfig,
      SchemaColorsConfig,
      SizeProps,
      Level1Items,
      SpacingConfig,
      FontConfig,
      CodeConfig,
      HeadingsConfig,
      LinksConfig,
      TokenProps,
      CodeBlock,
      ConfigThemeLogo,
      Fab,
      ButtonOverrides,
      Overrides,
      ObjectRule,
      Schema: Schema2,
      RightPanel: RightPanel2,
      Rules,
      Shape,
      ThemeSpacing,
      GenerateCodeSamples,
      GroupItemsConfig,
      ConfigThemeComponents,
      Layout,
      ConfigThemeSchema,
      Sidebar,
      Heading,
      Typography,
      AssertionDefinitionAssertions
    };
    exports.ConfigTypes = createConfigTypes(config_1.rootRedoclyConfigSchema);
    exports.NormalizedConfigTypes = (0, types_1.normalizeTypes)(exports.ConfigTypes);
  }
});

// node_modules/@redocly/openapi-core/lib/bundle.js
var require_bundle = __commonJS({
  "node_modules/@redocly/openapi-core/lib/bundle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OasVersion = void 0;
    exports.bundleConfig = bundleConfig;
    exports.bundle = bundle2;
    exports.bundleFromString = bundleFromString;
    exports.bundleDocument = bundleDocument;
    exports.mapTypeToComponent = mapTypeToComponent;
    var resolve_1 = require_resolve();
    var visitors_1 = require_visitors();
    var types_1 = require_types();
    var walk_1 = require_walk();
    var oas_types_1 = require_oas_types();
    var ref_utils_1 = require_ref_utils();
    var rules_1 = require_rules();
    var no_unresolved_refs_1 = require_no_unresolved_refs();
    var utils_1 = require_utils();
    var domains_1 = require_domains();
    var remove_unused_components_1 = require_remove_unused_components();
    var remove_unused_components_2 = require_remove_unused_components2();
    var redocly_yaml_1 = require_redocly_yaml();
    var OasVersion;
    (function(OasVersion2) {
      OasVersion2["Version2"] = "oas2";
      OasVersion2["Version3_0"] = "oas3_0";
      OasVersion2["Version3_1"] = "oas3_1";
    })(OasVersion || (exports.OasVersion = OasVersion = {}));
    var bundleVisitor = (0, visitors_1.normalizeVisitors)([
      {
        severity: "error",
        ruleId: "configBundler",
        visitor: {
          ref: {
            leave(node, ctx, resolved) {
              replaceRef(node, resolved, ctx);
            }
          }
        }
      }
    ], redocly_yaml_1.NormalizedConfigTypes);
    async function bundleConfig(document2, resolvedRefMap) {
      var _a2;
      const ctx = {
        problems: [],
        oasVersion: oas_types_1.SpecVersion.OAS3_0,
        refTypes: /* @__PURE__ */ new Map(),
        visitorsData: {}
      };
      (0, walk_1.walkDocument)({
        document: document2,
        rootType: redocly_yaml_1.NormalizedConfigTypes.ConfigRoot,
        normalizedVisitors: bundleVisitor,
        resolvedRefMap,
        ctx
      });
      return (_a2 = document2.parsed) != null ? _a2 : {};
    }
    async function bundle2(opts2) {
      var _a2;
      const { ref, doc: doc2, externalRefResolver = new resolve_1.BaseResolver(opts2.config.resolve), base: base2 = null } = opts2;
      if (!(ref || doc2)) {
        throw new Error("Document or reference is required.\n");
      }
      const document2 = doc2 === void 0 ? await externalRefResolver.resolveDocument(base2, ref, true) : doc2;
      if (document2 instanceof Error) {
        throw document2;
      }
      (_a2 = opts2.collectSpecData) == null ? void 0 : _a2.call(opts2, document2.parsed);
      return bundleDocument({
        document: document2,
        ...opts2,
        config: opts2.config.styleguide,
        externalRefResolver
      });
    }
    async function bundleFromString(opts2) {
      const { source, absoluteRef, externalRefResolver = new resolve_1.BaseResolver(opts2.config.resolve) } = opts2;
      const document2 = (0, resolve_1.makeDocumentFromString)(source, absoluteRef || "/");
      return bundleDocument({
        document: document2,
        ...opts2,
        externalRefResolver,
        config: opts2.config.styleguide
      });
    }
    async function bundleDocument(opts2) {
      const { document: document2, config: config3, customTypes, externalRefResolver, dereference = false, skipRedoclyRegistryRefs = false, removeUnusedComponents = false, keepUrlRefs = false } = opts2;
      const specVersion = (0, oas_types_1.detectSpec)(document2.parsed);
      const specMajorVersion = (0, oas_types_1.getMajorSpecVersion)(specVersion);
      const rules = config3.getRulesForSpecVersion(specMajorVersion);
      const types2 = (0, types_1.normalizeTypes)(config3.extendTypes(customTypes != null ? customTypes : (0, oas_types_1.getTypes)(specVersion), specVersion), config3);
      const preprocessors = (0, rules_1.initRules)(rules, config3, "preprocessors", specVersion);
      const decorators = (0, rules_1.initRules)(rules, config3, "decorators", specVersion);
      const ctx = {
        problems: [],
        oasVersion: specVersion,
        refTypes: /* @__PURE__ */ new Map(),
        visitorsData: {}
      };
      if (removeUnusedComponents) {
        decorators.push({
          severity: "error",
          ruleId: "remove-unused-components",
          visitor: specMajorVersion === oas_types_1.SpecMajorVersion.OAS2 ? (0, remove_unused_components_1.RemoveUnusedComponents)({}) : (0, remove_unused_components_2.RemoveUnusedComponents)({})
        });
      }
      let resolvedRefMap = await (0, resolve_1.resolveDocument)({
        rootDocument: document2,
        rootType: types2.Root,
        externalRefResolver
      });
      if (preprocessors.length > 0) {
        (0, walk_1.walkDocument)({
          document: document2,
          rootType: types2.Root,
          normalizedVisitors: (0, visitors_1.normalizeVisitors)(preprocessors, types2),
          resolvedRefMap,
          ctx
        });
        resolvedRefMap = await (0, resolve_1.resolveDocument)({
          rootDocument: document2,
          rootType: types2.Root,
          externalRefResolver
        });
      }
      const bundleVisitor2 = (0, visitors_1.normalizeVisitors)([
        {
          severity: "error",
          ruleId: "bundler",
          visitor: makeBundleVisitor(specMajorVersion, dereference, skipRedoclyRegistryRefs, document2, resolvedRefMap, keepUrlRefs)
        },
        ...decorators
      ], types2);
      (0, walk_1.walkDocument)({
        document: document2,
        rootType: types2.Root,
        normalizedVisitors: bundleVisitor2,
        resolvedRefMap,
        ctx
      });
      return {
        bundle: document2,
        problems: ctx.problems.map((problem) => config3.addProblemToIgnore(problem)),
        fileDependencies: externalRefResolver.getFiles(),
        rootType: types2.Root,
        refTypes: ctx.refTypes,
        visitorsData: ctx.visitorsData
      };
    }
    function mapTypeToComponent(typeName2, version) {
      switch (version) {
        case oas_types_1.SpecMajorVersion.OAS3:
          switch (typeName2) {
            case "Schema":
              return "schemas";
            case "Parameter":
              return "parameters";
            case "Response":
              return "responses";
            case "Example":
              return "examples";
            case "RequestBody":
              return "requestBodies";
            case "Header":
              return "headers";
            case "SecuritySchema":
              return "securitySchemes";
            case "Link":
              return "links";
            case "Callback":
              return "callbacks";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.OAS2:
          switch (typeName2) {
            case "Schema":
              return "definitions";
            case "Parameter":
              return "parameters";
            case "Response":
              return "responses";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.Async2:
          switch (typeName2) {
            case "Schema":
              return "schemas";
            case "Parameter":
              return "parameters";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.Async3:
          switch (typeName2) {
            case "Schema":
              return "schemas";
            case "Parameter":
              return "parameters";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.Arazzo1:
          switch (typeName2) {
            case "Root.workflows_items.parameters_items":
            case "Root.workflows_items.steps_items.parameters_items":
              return "parameters";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.Overlay1:
          switch (typeName2) {
            default:
              return null;
          }
      }
    }
    function replaceRef(ref, resolved, ctx) {
      if (!(0, utils_1.isPlainObject)(resolved.node)) {
        ctx.parent[ctx.key] = resolved.node;
      } else {
        delete ref.$ref;
        const obj = Object.assign({}, resolved.node, ref);
        Object.assign(ref, obj);
      }
    }
    function makeBundleVisitor(version, dereference, skipRedoclyRegistryRefs, rootDocument, resolvedRefMap, keepUrlRefs) {
      let components;
      let rootLocation;
      const visitor = {
        ref: {
          leave(node, ctx, resolved) {
            if (!resolved.location || resolved.node === void 0) {
              (0, no_unresolved_refs_1.reportUnresolvedRef)(resolved, ctx.report, ctx.location);
              return;
            }
            if (resolved.location.source === rootDocument.source && resolved.location.source === ctx.location.source && ctx.type.name !== "scalar" && !dereference) {
              return;
            }
            if (skipRedoclyRegistryRefs && (0, domains_1.isRedoclyRegistryURL)(node.$ref)) {
              return;
            }
            if (keepUrlRefs && (0, ref_utils_1.isAbsoluteUrl)(node.$ref)) {
              return;
            }
            const componentType = mapTypeToComponent(ctx.type.name, version);
            if (!componentType) {
              replaceRef(node, resolved, ctx);
            } else {
              if (dereference) {
                saveComponent(componentType, resolved, ctx);
                replaceRef(node, resolved, ctx);
              } else {
                node.$ref = saveComponent(componentType, resolved, ctx);
                resolveBundledComponent(node, resolved, ctx);
              }
            }
          }
        },
        Example: {
          leave(node, ctx) {
            if ((0, ref_utils_1.isExternalValue)(node) && node.value === void 0) {
              const resolved = ctx.resolve({ $ref: node.externalValue });
              if (!resolved.location || resolved.node === void 0) {
                (0, no_unresolved_refs_1.reportUnresolvedRef)(resolved, ctx.report, ctx.location);
                return;
              }
              if (keepUrlRefs && (0, ref_utils_1.isAbsoluteUrl)(node.externalValue)) {
                return;
              }
              node.value = ctx.resolve({ $ref: node.externalValue }).node;
              delete node.externalValue;
            }
          }
        },
        Root: {
          enter(root, ctx) {
            rootLocation = ctx.location;
            if (version === oas_types_1.SpecMajorVersion.OAS3) {
              components = root.components = root.components || {};
            } else if (version === oas_types_1.SpecMajorVersion.OAS2) {
              components = root;
            } else if (version === oas_types_1.SpecMajorVersion.Async2) {
              components = root.components = root.components || {};
            } else if (version === oas_types_1.SpecMajorVersion.Async3) {
              components = root.components = root.components || {};
            } else if (version === oas_types_1.SpecMajorVersion.Arazzo1) {
              components = root.components = root.components || {};
            }
          }
        }
      };
      if (version === oas_types_1.SpecMajorVersion.OAS3) {
        visitor.DiscriminatorMapping = {
          leave(mapping, ctx) {
            for (const name2 of Object.keys(mapping)) {
              const $ref = mapping[name2];
              const resolved = ctx.resolve({ $ref });
              if (!resolved.location || resolved.node === void 0) {
                (0, no_unresolved_refs_1.reportUnresolvedRef)(resolved, ctx.report, ctx.location.child(name2));
                return;
              }
              const componentType = mapTypeToComponent("Schema", version);
              mapping[name2] = saveComponent(componentType, resolved, ctx);
            }
          }
        };
      }
      function resolveBundledComponent(node, resolved, ctx) {
        const newRefId = (0, resolve_1.makeRefId)(ctx.location.source.absoluteRef, node.$ref);
        resolvedRefMap.set(newRefId, {
          document: rootDocument,
          isRemote: false,
          node: resolved.node,
          nodePointer: node.$ref,
          resolved: true
        });
      }
      function saveComponent(componentType, target, ctx) {
        components[componentType] = components[componentType] || {};
        const name2 = getComponentName(target, componentType, ctx);
        components[componentType][name2] = target.node;
        if (version === oas_types_1.SpecMajorVersion.OAS3 || version === oas_types_1.SpecMajorVersion.Async2 || version === oas_types_1.SpecMajorVersion.Async3) {
          return `#/components/${componentType}/${name2}`;
        } else {
          return `#/${componentType}/${name2}`;
        }
      }
      function isEqualOrEqualRef(node, target, ctx) {
        var _a2;
        if ((0, ref_utils_1.isRef)(node) && ((_a2 = ctx.resolve(node, rootLocation.absolutePointer).location) == null ? void 0 : _a2.absolutePointer) === target.location.absolutePointer) {
          return true;
        }
        return (0, utils_1.dequal)(node, target.node);
      }
      function getComponentName(target, componentType, ctx) {
        const [fileRef, pointer] = [target.location.source.absoluteRef, target.location.pointer];
        const componentsGroup = components[componentType];
        let name2 = "";
        const refParts = pointer.slice(2).split("/").filter(utils_1.isTruthy);
        while (refParts.length > 0) {
          name2 = refParts.pop() + (name2 ? `-${name2}` : "");
          if (!componentsGroup || !componentsGroup[name2] || isEqualOrEqualRef(componentsGroup[name2], target, ctx)) {
            return name2;
          }
        }
        name2 = (0, ref_utils_1.refBaseName)(fileRef) + (name2 ? `_${name2}` : "");
        if (!componentsGroup[name2] || isEqualOrEqualRef(componentsGroup[name2], target, ctx)) {
          return name2;
        }
        const prevName = name2;
        let serialId = 2;
        while (componentsGroup[name2] && !isEqualOrEqualRef(componentsGroup[name2], target, ctx)) {
          name2 = `${prevName}-${serialId}`;
          serialId++;
        }
        if (!componentsGroup[name2]) {
          ctx.report({
            message: `Two schemas are referenced with the same name but different content. Renamed ${prevName} to ${name2}.`,
            location: ctx.location,
            forceSeverity: "warn"
          });
        }
        return name2;
      }
      return visitor;
    }
  }
});

// node_modules/@redocly/openapi-core/lib/config/utils.js
var require_utils2 = __commonJS({
  "node_modules/@redocly/openapi-core/lib/config/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigValidationError = void 0;
    exports.parsePresetName = parsePresetName;
    exports.transformApiDefinitionsToApis = transformApiDefinitionsToApis;
    exports.prefixRules = prefixRules;
    exports.mergeExtends = mergeExtends;
    exports.getMergedConfig = getMergedConfig;
    exports.checkForDeprecatedFields = checkForDeprecatedFields;
    exports.transformConfig = transformConfig;
    exports.getResolveConfig = getResolveConfig;
    exports.getUniquePlugins = getUniquePlugins;
    exports.deepCloneMapWithJSON = deepCloneMapWithJSON;
    exports.isDeprecatedPluginFormat = isDeprecatedPluginFormat;
    exports.isCommonJsPlugin = isCommonJsPlugin;
    var utils_1 = require_utils();
    var config_1 = require_config();
    var logger_1 = require_logger();
    function parsePresetName(presetName) {
      if (presetName.indexOf("/") > -1) {
        const [pluginId, configName] = presetName.split("/");
        return { pluginId, configName };
      } else {
        return { pluginId: "", configName: presetName };
      }
    }
    function transformApiDefinitionsToApis(apiDefinitions) {
      if (!apiDefinitions)
        return void 0;
      const apis = {};
      for (const [apiName, apiPath] of Object.entries(apiDefinitions)) {
        apis[apiName] = { root: apiPath };
      }
      return apis;
    }
    function extractFlatConfig({ plugins, extends: _extends3, rules, oas2Rules, oas3_0Rules, oas3_1Rules, async2Rules, async3Rules, arazzo1Rules, overlay1Rules, preprocessors, oas2Preprocessors, oas3_0Preprocessors, oas3_1Preprocessors, async2Preprocessors, async3Preprocessors, arazzo1Preprocessors, overlay1Preprocessors, decorators, oas2Decorators, oas3_0Decorators, oas3_1Decorators, async2Decorators, async3Decorators, arazzo1Decorators, overlay1Decorators, ...rawConfigRest }) {
      var _a2;
      const styleguideConfig = {
        plugins,
        extends: _extends3,
        rules,
        oas2Rules,
        oas3_0Rules,
        oas3_1Rules,
        async2Rules,
        async3Rules,
        arazzo1Rules,
        overlay1Rules,
        preprocessors,
        oas2Preprocessors,
        oas3_0Preprocessors,
        oas3_1Preprocessors,
        async2Preprocessors,
        async3Preprocessors,
        arazzo1Preprocessors,
        overlay1Preprocessors,
        decorators,
        oas2Decorators,
        oas3_0Decorators,
        oas3_1Decorators,
        async2Decorators,
        async3Decorators,
        arazzo1Decorators,
        overlay1Decorators,
        doNotResolveExamples: (_a2 = rawConfigRest.resolve) == null ? void 0 : _a2.doNotResolveExamples
      };
      if (rawConfigRest.lint && rawConfigRest.styleguide || Object.values(styleguideConfig).some(utils_1.isDefined) && (rawConfigRest.lint || rawConfigRest.styleguide)) {
        throw new Error(`Do not use 'lint', 'styleguide' and flat syntax together. 
See more about the configuration in the docs: https://redocly.com/docs/cli/configuration/ 
`);
      }
      return {
        styleguideConfig: Object.values(styleguideConfig).some(utils_1.isDefined) ? styleguideConfig : void 0,
        rawConfigRest
      };
    }
    function transformApis(legacyApis) {
      if (!legacyApis)
        return void 0;
      const apis = {};
      for (const [apiName, { lint, ...apiContent }] of Object.entries(legacyApis)) {
        const { styleguideConfig, rawConfigRest } = extractFlatConfig(apiContent);
        apis[apiName] = {
          styleguide: styleguideConfig || lint,
          ...rawConfigRest
        };
      }
      return apis;
    }
    function prefixRules(rules, prefix) {
      if (!prefix)
        return rules;
      const res = {};
      for (const name2 of Object.keys(rules)) {
        res[`${prefix}/${name2}`] = rules[name2];
      }
      return res;
    }
    function mergeExtends(rulesConfList) {
      const result = {
        rules: {},
        oas2Rules: {},
        oas3_0Rules: {},
        oas3_1Rules: {},
        async2Rules: {},
        async3Rules: {},
        arazzo1Rules: {},
        overlay1Rules: {},
        preprocessors: {},
        oas2Preprocessors: {},
        oas3_0Preprocessors: {},
        oas3_1Preprocessors: {},
        async2Preprocessors: {},
        async3Preprocessors: {},
        arazzo1Preprocessors: {},
        overlay1Preprocessors: {},
        decorators: {},
        oas2Decorators: {},
        oas3_0Decorators: {},
        oas3_1Decorators: {},
        async2Decorators: {},
        async3Decorators: {},
        arazzo1Decorators: {},
        overlay1Decorators: {},
        plugins: [],
        pluginPaths: [],
        extendPaths: []
      };
      for (const rulesConf of rulesConfList) {
        if (rulesConf.extends) {
          throw new Error(`'extends' is not supported in shared configs yet:
${JSON.stringify(rulesConf, null, 2)}`);
        }
        (0, utils_1.assignConfig)(result.rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.oas2Rules, rulesConf.oas2Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.oas2Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.oas3_0Rules, rulesConf.oas3_0Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.oas3_0Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.oas3_1Rules, rulesConf.oas3_1Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.oas3_1Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.async2Rules, rulesConf.async2Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.async2Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.async3Rules, rulesConf.async3Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.async3Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.arazzo1Rules, rulesConf.arazzo1Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.arazzo1Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.overlay1Rules, rulesConf.overlay1Rules);
        (0, utils_1.assignOnlyExistingConfig)(result.overlay1Rules, rulesConf.rules);
        (0, utils_1.assignConfig)(result.preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.oas2Preprocessors, rulesConf.oas2Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.oas2Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.oas3_0Preprocessors, rulesConf.oas3_0Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.oas3_0Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.oas3_1Preprocessors, rulesConf.oas3_1Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.oas3_1Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.async2Preprocessors, rulesConf.async2Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.async2Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.async3Preprocessors, rulesConf.async3Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.async3Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.arazzo1Preprocessors, rulesConf.arazzo1Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.arazzo1Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.overlay1Preprocessors, rulesConf.overlay1Preprocessors);
        (0, utils_1.assignOnlyExistingConfig)(result.overlay1Preprocessors, rulesConf.preprocessors);
        (0, utils_1.assignConfig)(result.decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.oas2Decorators, rulesConf.oas2Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.oas2Decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.oas3_0Decorators, rulesConf.oas3_0Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.oas3_0Decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.oas3_1Decorators, rulesConf.oas3_1Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.oas3_1Decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.async2Decorators, rulesConf.async2Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.async2Decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.async3Decorators, rulesConf.async3Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.async3Decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.arazzo1Decorators, rulesConf.arazzo1Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.arazzo1Decorators, rulesConf.decorators);
        (0, utils_1.assignConfig)(result.overlay1Decorators, rulesConf.overlay1Decorators);
        (0, utils_1.assignOnlyExistingConfig)(result.overlay1Decorators, rulesConf.decorators);
        result.plugins.push(...rulesConf.plugins || []);
        result.pluginPaths.push(...rulesConf.pluginPaths || []);
        result.extendPaths.push(...new Set(rulesConf.extendPaths));
      }
      return result;
    }
    function getMergedConfig(config3, apiName) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const extendPaths = [
        ...Object.values(config3.apis).map((api) => {
          var _a3;
          return (_a3 = api == null ? void 0 : api.styleguide) == null ? void 0 : _a3.extendPaths;
        }),
        (_b = (_a2 = config3.rawConfig) == null ? void 0 : _a2.styleguide) == null ? void 0 : _b.extendPaths
      ].flat().filter(utils_1.isTruthy);
      const pluginPaths = [
        ...Object.values(config3.apis).map((api) => {
          var _a3;
          return (_a3 = api == null ? void 0 : api.styleguide) == null ? void 0 : _a3.pluginPaths;
        }),
        (_d = (_c = config3.rawConfig) == null ? void 0 : _c.styleguide) == null ? void 0 : _d.pluginPaths
      ].flat().filter(utils_1.isTruthy);
      return apiName ? new config_1.Config({
        ...config3.rawConfig,
        styleguide: {
          ...config3.apis[apiName] ? config3.apis[apiName].styleguide : config3.rawConfig.styleguide,
          extendPaths,
          pluginPaths
        },
        theme: {
          ...config3.rawConfig.theme,
          ...(_e = config3.apis[apiName]) == null ? void 0 : _e.theme
        },
        files: [...config3.files, ...(_h = (_g = (_f = config3.apis) == null ? void 0 : _f[apiName]) == null ? void 0 : _g.files) != null ? _h : []]
        // TODO: merge everything else here
      }, config3.configFile) : config3;
    }
    function checkForDeprecatedFields(deprecatedField, updatedField, rawConfig, updatedObject, link) {
      const isDeprecatedFieldInApis = rawConfig.apis && Object.values(rawConfig.apis).some((api) => api[deprecatedField]);
      if (rawConfig[deprecatedField] && updatedField === null) {
        (0, utils_1.showWarningForDeprecatedField)(deprecatedField, void 0, updatedObject, link);
      }
      if (rawConfig[deprecatedField] && updatedField && rawConfig[updatedField]) {
        (0, utils_1.showErrorForDeprecatedField)(deprecatedField, updatedField);
      }
      if (rawConfig[deprecatedField] && updatedObject && rawConfig[updatedObject]) {
        (0, utils_1.showErrorForDeprecatedField)(deprecatedField, updatedField, updatedObject);
      }
      if (rawConfig[deprecatedField] || isDeprecatedFieldInApis) {
        (0, utils_1.showWarningForDeprecatedField)(deprecatedField, updatedField, updatedObject, link);
      }
    }
    function transformConfig(rawConfig) {
      var _a2, _b;
      const migratedFields = [
        ["apiDefinitions", "apis", void 0, void 0],
        ["referenceDocs", "openapi", "theme", void 0],
        [
          "lint",
          void 0,
          void 0,
          "https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties"
        ],
        [
          "styleguide",
          void 0,
          void 0,
          "https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties"
        ],
        ["features.openapi", "openapi", "theme", void 0]
      ];
      for (const [deprecatedField, updatedField, updatedObject, link] of migratedFields) {
        checkForDeprecatedFields(deprecatedField, updatedField, rawConfig, updatedObject, link);
      }
      const { apis, apiDefinitions, referenceDocs, lint, ...rest } = rawConfig;
      const { styleguideConfig, rawConfigRest } = extractFlatConfig(rest);
      const transformedConfig = {
        theme: {
          openapi: {
            ...referenceDocs,
            ...rawConfig["features.openapi"],
            ...(_a2 = rawConfig.theme) == null ? void 0 : _a2.openapi
          },
          mockServer: {
            ...rawConfig["features.mockServer"],
            ...(_b = rawConfig.theme) == null ? void 0 : _b.mockServer
          }
        },
        apis: transformApis(apis) || transformApiDefinitionsToApis(apiDefinitions),
        styleguide: styleguideConfig || lint,
        ...rawConfigRest
      };
      showDeprecationMessages(transformedConfig);
      return transformedConfig;
    }
    function showDeprecationMessages(config3) {
      var _a2, _b;
      let allRules = { ...(_a2 = config3.styleguide) == null ? void 0 : _a2.rules };
      for (const api of Object.values(config3.apis || {})) {
        allRules = { ...allRules, ...(_b = api == null ? void 0 : api.styleguide) == null ? void 0 : _b.rules };
      }
      for (const ruleKey of Object.keys(allRules)) {
        if (ruleKey.startsWith("assert/")) {
          logger_1.logger.warn(`
The 'assert/' syntax in ${ruleKey} is deprecated. Update your configuration to use 'rule/' instead. Examples and more information: https://redocly.com/docs/cli/rules/configurable-rules/
`);
        }
      }
    }
    function getResolveConfig(resolve) {
      var _a2, _b;
      return {
        http: {
          headers: (_b = (_a2 = resolve == null ? void 0 : resolve.http) == null ? void 0 : _a2.headers) != null ? _b : [],
          customFetch: void 0
        }
      };
    }
    function getUniquePlugins(plugins) {
      const seen = /* @__PURE__ */ new Set();
      const results = [];
      for (const p of plugins) {
        if (!seen.has(p.id)) {
          results.push(p);
          seen.add(p.id);
        } else if (p.id) {
          logger_1.logger.warn(`Duplicate plugin id "${logger_1.colorize.red(p.id)}".
`);
        }
      }
      return results;
    }
    var ConfigValidationError = class extends Error {
    };
    exports.ConfigValidationError = ConfigValidationError;
    function deepCloneMapWithJSON(originalMap) {
      return new Map(JSON.parse(JSON.stringify([...originalMap])));
    }
    function isDeprecatedPluginFormat(plugin) {
      return plugin !== void 0 && typeof plugin === "object" && "id" in plugin;
    }
    function isCommonJsPlugin(plugin) {
      return typeof plugin === "function";
    }
  }
});

// node_modules/@redocly/openapi-core/lib/config/config.js
var require_config = __commonJS({
  "node_modules/@redocly/openapi-core/lib/config/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Config = exports.StyleguideConfig = exports.IGNORE_FILE = void 0;
    var fs = __require("fs");
    var path = __require("path");
    var js_yaml_1 = require_js_yaml2();
    var utils_1 = require_utils();
    var oas_types_1 = require_oas_types();
    var env_1 = require_env();
    var utils_2 = require_utils2();
    var ref_utils_1 = require_ref_utils();
    exports.IGNORE_FILE = ".redocly.lint-ignore.yaml";
    var IGNORE_BANNER = `# This file instructs Redocly's linter to ignore the rules contained for specific parts of your API.
# See https://redocly.com/docs/cli/ for more information.
`;
    function getIgnoreFilePath(configFile) {
      if (configFile) {
        return (0, utils_1.doesYamlFileExist)(configFile) ? path.join(path.dirname(configFile), exports.IGNORE_FILE) : path.join(configFile, exports.IGNORE_FILE);
      } else {
        return env_1.isBrowser ? void 0 : path.join(process.cwd(), exports.IGNORE_FILE);
      }
    }
    var StyleguideConfig = class {
      constructor(rawConfig, configFile) {
        this.rawConfig = rawConfig;
        this.configFile = configFile;
        this.ignore = {};
        this._usedRules = /* @__PURE__ */ new Set();
        this._usedVersions = /* @__PURE__ */ new Set();
        this.plugins = rawConfig.plugins || [];
        this.doNotResolveExamples = !!rawConfig.doNotResolveExamples;
        this.recommendedFallback = rawConfig.recommendedFallback || false;
        const ruleGroups = [
          "rules",
          "oas2Rules",
          "oas3_0Rules",
          "oas3_1Rules",
          "async2Rules",
          "async3Rules",
          "arazzo1Rules",
          "overlay1Rules"
        ];
        replaceSpecWithStruct(ruleGroups, rawConfig);
        this.rules = {
          [oas_types_1.SpecVersion.OAS2]: { ...rawConfig.rules, ...rawConfig.oas2Rules },
          [oas_types_1.SpecVersion.OAS3_0]: { ...rawConfig.rules, ...rawConfig.oas3_0Rules },
          [oas_types_1.SpecVersion.OAS3_1]: { ...rawConfig.rules, ...rawConfig.oas3_1Rules },
          [oas_types_1.SpecVersion.Async2]: { ...rawConfig.rules, ...rawConfig.async2Rules },
          [oas_types_1.SpecVersion.Async3]: { ...rawConfig.rules, ...rawConfig.async3Rules },
          [oas_types_1.SpecVersion.Arazzo1]: { ...rawConfig.rules, ...rawConfig.arazzo1Rules },
          [oas_types_1.SpecVersion.Overlay1]: { ...rawConfig.rules, ...rawConfig.overlay1Rules }
        };
        this.preprocessors = {
          [oas_types_1.SpecVersion.OAS2]: { ...rawConfig.preprocessors, ...rawConfig.oas2Preprocessors },
          [oas_types_1.SpecVersion.OAS3_0]: { ...rawConfig.preprocessors, ...rawConfig.oas3_0Preprocessors },
          [oas_types_1.SpecVersion.OAS3_1]: { ...rawConfig.preprocessors, ...rawConfig.oas3_1Preprocessors },
          [oas_types_1.SpecVersion.Async2]: { ...rawConfig.preprocessors, ...rawConfig.async2Preprocessors },
          [oas_types_1.SpecVersion.Async3]: { ...rawConfig.preprocessors, ...rawConfig.async3Preprocessors },
          [oas_types_1.SpecVersion.Arazzo1]: { ...rawConfig.arazzo1Preprocessors },
          [oas_types_1.SpecVersion.Overlay1]: { ...rawConfig.preprocessors, ...rawConfig.overlay1Preprocessors }
        };
        this.decorators = {
          [oas_types_1.SpecVersion.OAS2]: { ...rawConfig.decorators, ...rawConfig.oas2Decorators },
          [oas_types_1.SpecVersion.OAS3_0]: { ...rawConfig.decorators, ...rawConfig.oas3_0Decorators },
          [oas_types_1.SpecVersion.OAS3_1]: { ...rawConfig.decorators, ...rawConfig.oas3_1Decorators },
          [oas_types_1.SpecVersion.Async2]: { ...rawConfig.decorators, ...rawConfig.async2Decorators },
          [oas_types_1.SpecVersion.Async3]: { ...rawConfig.decorators, ...rawConfig.async3Decorators },
          [oas_types_1.SpecVersion.Arazzo1]: { ...rawConfig.arazzo1Decorators },
          [oas_types_1.SpecVersion.Overlay1]: { ...rawConfig.decorators, ...rawConfig.overlay1Decorators }
        };
        this.extendPaths = rawConfig.extendPaths || [];
        this.pluginPaths = rawConfig.pluginPaths || [];
        this.resolveIgnore(getIgnoreFilePath(configFile));
      }
      resolveIgnore(ignoreFile) {
        if (!ignoreFile || !(0, utils_1.doesYamlFileExist)(ignoreFile))
          return;
        this.ignore = (0, js_yaml_1.parseYaml)(fs.readFileSync(ignoreFile, "utf-8")) || {};
        replaceSpecWithStruct(Object.keys(this.ignore), this.ignore);
        for (const fileName of Object.keys(this.ignore)) {
          this.ignore[(0, ref_utils_1.isAbsoluteUrl)(fileName) ? fileName : path.resolve(path.dirname(ignoreFile), fileName)] = this.ignore[fileName];
          for (const ruleId of Object.keys(this.ignore[fileName])) {
            this.ignore[fileName][ruleId] = new Set(this.ignore[fileName][ruleId]);
          }
          if (!(0, ref_utils_1.isAbsoluteUrl)(fileName)) {
            delete this.ignore[fileName];
          }
        }
      }
      saveIgnore() {
        const dir = this.configFile ? path.dirname(this.configFile) : process.cwd();
        const ignoreFile = path.join(dir, exports.IGNORE_FILE);
        const mapped = {};
        for (const absFileName of Object.keys(this.ignore)) {
          const mappedDefinitionName = (0, ref_utils_1.isAbsoluteUrl)(absFileName) ? absFileName : (0, utils_1.slash)(path.relative(dir, absFileName));
          const ignoredRules = mapped[mappedDefinitionName] = this.ignore[absFileName];
          for (const ruleId of Object.keys(ignoredRules)) {
            ignoredRules[ruleId] = Array.from(ignoredRules[ruleId]);
          }
        }
        fs.writeFileSync(ignoreFile, IGNORE_BANNER + (0, js_yaml_1.stringifyYaml)(mapped));
      }
      addIgnore(problem) {
        const ignore = this.ignore;
        const loc = problem.location[0];
        if (loc.pointer === void 0)
          return;
        const fileIgnore = ignore[loc.source.absoluteRef] = ignore[loc.source.absoluteRef] || {};
        const ruleIgnore = fileIgnore[problem.ruleId] = fileIgnore[problem.ruleId] || /* @__PURE__ */ new Set();
        ruleIgnore.add(loc.pointer);
      }
      addProblemToIgnore(problem) {
        const loc = problem.location[0];
        if (loc.pointer === void 0)
          return problem;
        const fileIgnore = this.ignore[loc.source.absoluteRef] || {};
        const ruleIgnore = fileIgnore[problem.ruleId];
        const ignored = ruleIgnore && ruleIgnore.has(loc.pointer);
        return ignored ? {
          ...problem,
          ignored
        } : problem;
      }
      extendTypes(types2, version) {
        let extendedTypes = types2;
        for (const plugin of this.plugins) {
          if (plugin.typeExtension !== void 0) {
            switch (version) {
              case oas_types_1.SpecVersion.OAS3_0:
              case oas_types_1.SpecVersion.OAS3_1:
                if (!plugin.typeExtension.oas3)
                  continue;
                extendedTypes = plugin.typeExtension.oas3(extendedTypes, version);
                break;
              case oas_types_1.SpecVersion.OAS2:
                if (!plugin.typeExtension.oas2)
                  continue;
                extendedTypes = plugin.typeExtension.oas2(extendedTypes, version);
                break;
              case oas_types_1.SpecVersion.Async2:
                if (!plugin.typeExtension.async2)
                  continue;
                extendedTypes = plugin.typeExtension.async2(extendedTypes, version);
                break;
              case oas_types_1.SpecVersion.Async3:
                if (!plugin.typeExtension.async3)
                  continue;
                extendedTypes = plugin.typeExtension.async3(extendedTypes, version);
                break;
              case oas_types_1.SpecVersion.Arazzo1:
                if (!plugin.typeExtension.arazzo1)
                  continue;
                extendedTypes = plugin.typeExtension.arazzo1(extendedTypes, version);
                break;
              case oas_types_1.SpecVersion.Overlay1:
                if (!plugin.typeExtension.overlay1)
                  continue;
                extendedTypes = plugin.typeExtension.overlay1(extendedTypes, version);
                break;
              default:
                throw new Error("Not implemented");
            }
          }
        }
        return extendedTypes;
      }
      getRuleSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.rules[oasVersion][ruleId] || "off";
        if (typeof settings === "string") {
          return {
            severity: settings
          };
        } else {
          return { severity: "error", ...settings };
        }
      }
      getPreprocessorSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.preprocessors[oasVersion][ruleId] || "off";
        if (typeof settings === "string") {
          return {
            severity: settings === "on" ? "error" : settings
          };
        } else {
          return { severity: "error", ...settings };
        }
      }
      getDecoratorSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.decorators[oasVersion][ruleId] || "off";
        if (typeof settings === "string") {
          return {
            severity: settings === "on" ? "error" : settings
          };
        } else {
          return { severity: "error", ...settings };
        }
      }
      getUnusedRules() {
        const rules = [];
        const decorators = [];
        const preprocessors = [];
        for (const usedVersion of Array.from(this._usedVersions)) {
          rules.push(...Object.keys(this.rules[usedVersion]).filter((name2) => !this._usedRules.has(name2)));
          decorators.push(...Object.keys(this.decorators[usedVersion]).filter((name2) => !this._usedRules.has(name2)));
          preprocessors.push(...Object.keys(this.preprocessors[usedVersion]).filter((name2) => !this._usedRules.has(name2)));
        }
        return {
          rules,
          preprocessors,
          decorators
        };
      }
      getRulesForSpecVersion(version) {
        switch (version) {
          case oas_types_1.SpecMajorVersion.OAS3:
            const oas3Rules = [];
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.preprocessors) == null ? void 0 : _a2.oas3) && oas3Rules.push(p.preprocessors.oas3);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.rules) == null ? void 0 : _a2.oas3) && oas3Rules.push(p.rules.oas3);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.decorators) == null ? void 0 : _a2.oas3) && oas3Rules.push(p.decorators.oas3);
            });
            return oas3Rules;
          case oas_types_1.SpecMajorVersion.OAS2:
            const oas2Rules = [];
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.preprocessors) == null ? void 0 : _a2.oas2) && oas2Rules.push(p.preprocessors.oas2);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.rules) == null ? void 0 : _a2.oas2) && oas2Rules.push(p.rules.oas2);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.decorators) == null ? void 0 : _a2.oas2) && oas2Rules.push(p.decorators.oas2);
            });
            return oas2Rules;
          case oas_types_1.SpecMajorVersion.Async2:
            const asyncApi2Rules = [];
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.preprocessors) == null ? void 0 : _a2.async2) && asyncApi2Rules.push(p.preprocessors.async2);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.rules) == null ? void 0 : _a2.async2) && asyncApi2Rules.push(p.rules.async2);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.decorators) == null ? void 0 : _a2.async2) && asyncApi2Rules.push(p.decorators.async2);
            });
            return asyncApi2Rules;
          case oas_types_1.SpecMajorVersion.Async3:
            const asyncApi3Rules = [];
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.preprocessors) == null ? void 0 : _a2.async3) && asyncApi3Rules.push(p.preprocessors.async3);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.rules) == null ? void 0 : _a2.async3) && asyncApi3Rules.push(p.rules.async3);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.decorators) == null ? void 0 : _a2.async3) && asyncApi3Rules.push(p.decorators.async3);
            });
            return asyncApi3Rules;
          case oas_types_1.SpecMajorVersion.Arazzo1:
            const arazzo1Rules = [];
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.preprocessors) == null ? void 0 : _a2.arazzo1) && arazzo1Rules.push(p.preprocessors.arazzo1);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.rules) == null ? void 0 : _a2.arazzo1) && arazzo1Rules.push(p.rules.arazzo1);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.decorators) == null ? void 0 : _a2.arazzo1) && arazzo1Rules.push(p.decorators.arazzo1);
            });
            return arazzo1Rules;
          case oas_types_1.SpecMajorVersion.Overlay1:
            const overlay1Rules = [];
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.preprocessors) == null ? void 0 : _a2.overlay1) && overlay1Rules.push(p.preprocessors.overlay1);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.rules) == null ? void 0 : _a2.overlay1) && overlay1Rules.push(p.rules.overlay1);
            });
            this.plugins.forEach((p) => {
              var _a2;
              return ((_a2 = p.decorators) == null ? void 0 : _a2.overlay1) && overlay1Rules.push(p.decorators.overlay1);
            });
            return overlay1Rules;
        }
      }
      skipRules(rules) {
        for (const ruleId of rules || []) {
          for (const version of Object.values(oas_types_1.SpecVersion)) {
            if (this.rules[version][ruleId]) {
              this.rules[version][ruleId] = "off";
            } else if (Array.isArray(this.rules[version].assertions)) {
              for (const configurableRule of this.rules[version].assertions) {
                if (configurableRule.assertionId === ruleId) {
                  configurableRule.severity = "off";
                }
              }
            }
          }
        }
      }
      skipPreprocessors(preprocessors) {
        for (const preprocessorId of preprocessors || []) {
          for (const version of Object.values(oas_types_1.SpecVersion)) {
            if (this.preprocessors[version][preprocessorId]) {
              this.preprocessors[version][preprocessorId] = "off";
            }
          }
        }
      }
      skipDecorators(decorators) {
        for (const decoratorId of decorators || []) {
          for (const version of Object.values(oas_types_1.SpecVersion)) {
            if (this.decorators[version][decoratorId]) {
              this.decorators[version][decoratorId] = "off";
            }
          }
        }
      }
    };
    exports.StyleguideConfig = StyleguideConfig;
    function replaceSpecWithStruct(ruleGroups, config3) {
      for (const ruleGroup of ruleGroups) {
        if (config3[ruleGroup] && (0, utils_1.isPlainObject)(config3[ruleGroup]) && "spec" in config3[ruleGroup]) {
          (0, utils_1.showWarningForDeprecatedField)("spec", "struct");
          config3[ruleGroup].struct = config3[ruleGroup].spec;
          delete config3[ruleGroup].spec;
        }
      }
    }
    var Config2 = class {
      constructor(rawConfig, configFile) {
        this.rawConfig = rawConfig;
        this.configFile = configFile;
        this.apis = rawConfig.apis || {};
        this.styleguide = new StyleguideConfig(rawConfig.styleguide || {}, configFile);
        this.theme = rawConfig.theme || {};
        this.resolve = (0, utils_2.getResolveConfig)(rawConfig == null ? void 0 : rawConfig.resolve);
        this.region = rawConfig.region;
        this.organization = rawConfig.organization;
        this.files = rawConfig.files || [];
        this.telemetry = rawConfig.telemetry;
      }
    };
    exports.Config = Config2;
  }
});

// node_modules/call-me-maybe/src/next.js
var require_next2 = __commonJS({
  "node_modules/call-me-maybe/src/next.js"(exports, module) {
    "use strict";
    function makeNext() {
      if (typeof process === "object" && typeof process.nextTick === "function") {
        return process.nextTick;
      } else if (typeof setImmediate === "function") {
        return setImmediate;
      } else {
        return function next(f) {
          setTimeout(f, 0);
        };
      }
    }
    module.exports = makeNext();
  }
});

// node_modules/call-me-maybe/src/maybe.js
var require_maybe = __commonJS({
  "node_modules/call-me-maybe/src/maybe.js"(exports, module) {
    "use strict";
    var next = require_next2();
    module.exports = function maybe(cb, promise) {
      if (cb) {
        promise.then(function(result) {
          next(function() {
            cb(null, result);
          });
        }, function(err) {
          next(function() {
            cb(err);
          });
        });
        return void 0;
      } else {
        return promise;
      }
    };
  }
});

// node_modules/http2-client/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/http2-client/lib/utils.js"(exports, module) {
    var DebounceTimers = class {
      constructor(cb, defaultDelay) {
        this.cb = cb;
        this.delay = defaultDelay;
        this.timers = {};
        this.pausers = {};
      }
      setDelay(delay) {
        if (delay >= 0)
          this.delay = delay;
      }
      pause(key2) {
        this.pausers[key2] = this.pausers[key2] || 0;
        this.pausers[key2]++;
      }
      unpause(key2) {
        var count = this.pausers[key2] || 0;
        if (count > 0)
          count--;
        this.pausers[key2] = count;
      }
      unpauseAndTime(key2) {
        this.unpause(key2);
        this.time(key2);
      }
      time(key2) {
        var self2 = this;
        var timers = this.timers;
        var timer = this.timers[key2];
        if (this.pausers[key2] > 0)
          return;
        if (timer)
          clearTimeout(timer);
        timers[key2] = setTimeout(function onTimer() {
          self2.cb(key2);
          delete timers[key2];
        }, self2.delay);
      }
    };
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(name2, expected, actual) {
        const type = name2.includes(".") ? "property" : "argument";
        let msg = `The "${name2}" ${type} ${determiner} ${expected}`;
      }
    };
    function assertIsObject(value, name2, types2 = "Object") {
      if (value !== void 0 && (value === null || typeof value !== "object" || Array.isArray(value))) {
        const err = new ERR_INVALID_ARG_TYPE(name2, types2, value);
        Error.captureStackTrace(err, assertIsObject);
        throw err;
      }
    }
    module.exports = {
      ERR_INVALID_ARG_TYPE,
      assertIsObject,
      DebounceTimers
    };
  }
});

// node_modules/http2-client/lib/request-options.js
var require_request_options = __commonJS({
  "node_modules/http2-client/lib/request-options.js"(exports, module) {
    var { assertIsObject } = require_utils3();
    function initializeOptions(options2) {
      assertIsObject(options2, "options");
      options2 = Object.assign({}, options2);
      options2.allowHalfOpen = true;
      options2.rejectUnauthorized = false;
      assertIsObject(options2.settings, "options.settings");
      options2.settings = Object.assign({}, options2.settings);
      options2.Http1IncomingMessage = options2.Http1IncomingMessage || this.http.IncomingMessage;
      options2.Http1ServerResponse = options2.Http1ServerResponse || this.http.ServerResponse;
      options2.Http2ServerRequest = options2.Http2ServerRequest || (this.http2 || {}).Http2ServerRequest;
      options2.Http2ServerResponse = options2.Http2ServerResponse || (this.http2 || {}).Http2ServerResponse;
      return options2;
    }
    function initializeTLSOptions(options2, servername) {
      options2 = initializeOptions.call(this, options2);
      var ALPNProtocols = options2.ALPNProtocols = [];
      if (this.http2Support)
        ALPNProtocols.push("h2");
      if (options2.allowHTTP1 == true || !this.http2Support)
        ALPNProtocols.push("http/1.1");
      if (servername !== void 0 && options2.servername === void 0)
        options2.servername = servername;
      return options2;
    }
    module.exports = {
      initializeTLSOptions
    };
  }
});

// node_modules/http2-client/lib/request.js
var require_request = __commonJS({
  "node_modules/http2-client/lib/request.js"(exports, module) {
    var { URL: URL2 } = __require("url");
    var { EventEmitter: EventEmitter2 } = __require("events");
    var _extend = __require("util")._extend;
    var { DebounceTimers, assertIsObject, ERR_INVALID_ARG_TYPE } = require_utils3();
    var { initializeTLSOptions } = require_request_options();
    var http = __require("http");
    var https = __require("https");
    var { Stream } = __require("stream");
    function addFunctions(container, obj) {
      const proto = obj.prototype;
      Object.keys(proto).forEach((name2) => {
        if (container.indexOf(name2) != -1)
          return;
        if (name2.indexOf("_") != 0 && typeof proto[name2] == "function") {
          container.push(name2);
        }
      });
    }
    var STUBBED_METHODS_NAME = [];
    addFunctions(STUBBED_METHODS_NAME, http.ClientRequest);
    addFunctions(STUBBED_METHODS_NAME, http.OutgoingMessage);
    addFunctions(STUBBED_METHODS_NAME, EventEmitter2);
    addFunctions(STUBBED_METHODS_NAME, Stream);
    var PROPERTIES_TO_PROXY = [
      "httpVersionMajor",
      "httpVersionMinor",
      "httpVersion"
    ];
    var HEADERS_TO_REMOVE = ["host", "connection"];
    var $stubs = Symbol("stubs");
    function ClientRequest() {
      this.http2Mimic = true;
      this[$stubs] = [];
      for (var i = 0; i < STUBBED_METHODS_NAME.length; i++) {
        let name2 = STUBBED_METHODS_NAME[i];
        if (!ClientRequest.prototype[name2]) {
          this[name2] = function method() {
            return this.genericStubber(name2, arguments);
          }.bind(this);
        }
      }
      var requestOptions, cb, url, args;
      const isInternal = arguments[0] instanceof RequestInternalEnforce;
      var isInternalMethod, isInternalProtocol;
      if (isInternal) {
        const enforceOptions = arguments[0];
        if (enforceOptions.method)
          isInternalMethod = enforceOptions.method;
        if (enforceOptions.protocol)
          isInternalProtocol = enforceOptions.protocol;
      }
      if (isInternal) {
        args = arguments[0].args;
      } else {
        args = arguments;
      }
      if (args[2] != void 0) {
        url = args[0];
        requestOptions = args[1];
        cb = args[2];
      } else if (args[1] == void 0) {
        requestOptions = args[0];
      } else {
        requestOptions = args[0];
        cb = args[1];
      }
      cb = cb || function dummy() {
      };
      if (typeof requestOptions === "string") {
        requestOptions = urlToOptions(new URL2(requestOptions));
        if (!requestOptions.hostname) {
          throw new Error("Unable to determine the domain name");
        }
      } else {
        if (url) {
          requestOptions = _extend(urlToOptions(new URL2(url)), requestOptions);
        } else {
          requestOptions = _extend({}, requestOptions);
        }
      }
      if (isInternalProtocol != isInternalProtocol) {
        requestOptions.protocol = isInternalProtocol;
      }
      if (requestOptions.protocol == "https:" && !requestOptions.port && requestOptions.port != 0)
        requestOptions.port = 443;
      if (!requestOptions.port && requestOptions.port != 0)
        requestOptions.port = 80;
      if (isInternalMethod) {
        requestOptions.method = isInternalMethod;
      } else if (!requestOptions.method)
        requestOptions.method = "GET";
      requestOptions.method = requestOptions.method.toUpperCase();
      const requestManager = requestOptions.requestManager || this.getGlobalManager(requestOptions);
      requestManager.handleClientRequest(this, requestOptions, cb);
    }
    ClientRequest.prototype = {
      getGlobalManager(options2) {
        if (options2.agent)
          return options2.agent.protocol == "https:" ? HttpsRequest.globalManager : HttpRequest.globalManager;
        else
          return HttpRequestManager.globalManager;
      },
      genericStubber(method, args) {
        if (this[$stubs]) {
          this[$stubs].push([method, args]);
          return true;
        } else
          return this[method](...arguments);
      },
      on(eventName, cb) {
        if (eventName == "response") {
          if (!cb.http2Safe) {
            eventName = "http1.response";
            arguments[0] = eventName;
          }
        }
        if (this._on) {
          this._on(...arguments);
        } else
          this.genericStubber("on", arguments);
      },
      once(eventName, cb) {
        if (eventName == "response") {
          if (!cb.http2Safe) {
            eventName = "http1.response";
          }
        }
        if (this._once) {
          this._once(...arguments);
        } else
          this.genericStubber("once", arguments);
      },
      emitError(error) {
        if (this[$stubs]) {
          this[$stubs].forEach(([method, args]) => {
            if ((method === "on" || method === "once") && args[0] === "error") {
              args[1](error);
            }
          });
        } else
          return this.emit("error", error);
      },
      take(stream) {
        for (var i = 0; i < STUBBED_METHODS_NAME.length; i++) {
          let name2 = STUBBED_METHODS_NAME[i];
          if (stream[name2]) {
            this[name2] = stream[name2].bind(stream);
          }
        }
        this._on = stream.on.bind(stream);
        this._once = stream.once.bind(stream);
        this.proxyProps(stream);
        for (let i2 = 0; i2 < this[$stubs].length; i2++) {
          var stub = this[$stubs][i2];
          stream[stub[0]](...stub[1]);
        }
        this[$stubs] = null;
      },
      proxyProps(http2Stream) {
        function getter() {
          return http2Stream[this];
        }
        function setter(value) {
          http2Stream[this] = value;
        }
        const notToProxy = ["on", "_on", "_once", "once", "http2Mimic"].concat(STUBBED_METHODS_NAME);
        const keys2 = Object.keys(this);
        const keysToProxy = [].concat(PROPERTIES_TO_PROXY);
        keys2.forEach(function whichProxyKeys(key2) {
          if (notToProxy.indexOf(key2) == -1 && keysToProxy.indexOf(key2) == -1) {
            keysToProxy.push(key2);
          }
        });
        const properties = Object.getOwnPropertyDescriptors(http2Stream);
        for (var i = 0; i < keysToProxy.length; i++) {
          let name2 = keysToProxy[i];
          const propConfig = properties[name2];
          let shouldCopyValue;
          if (!propConfig)
            shouldCopyValue = true;
          if (propConfig && (propConfig.writable || propConfig))
            shouldCopyValue = true;
          if (shouldCopyValue)
            http2Stream[name2] = this[name2];
          Object.defineProperty(this, name2, {
            get: getter.bind(name2),
            set: setter.bind(name2)
          });
        }
      }
    };
    var HttpRequestManager = class _HttpRequestManager extends EventEmitter2 {
      constructor(options2) {
        super();
        this.httpsAgent = https.globalAgent;
        this.httpAgent = http.globalAgent;
        this.init(options2);
      }
      log() {
      }
      init(options2) {
        options2 = options2 || {};
        this.http2Clients = {};
        this.cachedHTTP1Result = {};
        this.setModules();
        this.http2Debouncer = new DebounceTimers(function stopConnection(key2) {
          this.log("stopping ", key2);
          var foundConnection = this.http2Clients[key2];
          if (foundConnection) {
            this.removeHttp2Client(key2, foundConnection);
          }
        }.bind(this), 1e3);
        this.keepH1IdentificationCacheFor = options2.keepH1IdentificationCacheFor || 3e4;
        this.http2Debouncer.setDelay(options2.keepH2ConnectionFor);
        if (options2.useHttp) {
          this.enforceProtocol = "http:";
        } else if (options2.useHttps) {
          this.enforceProtocol = "https:";
        }
      }
      setModules() {
        this["http"] = __require("http");
        this["https"] = __require("https");
        this["tls"] = __require("tls");
        this["net"] = __require("net");
        this.http2Support = false;
        try {
          this["http2"] = __require("http2");
          this.http2Support = true;
        } catch (err) {
        }
      }
      handleClientRequest(clientRequest, requestOptions, cb) {
        const requestManager = this;
        const clientKey = requestManager.getClientKey(requestOptions);
        if (requestManager.hasCachedConnection(clientKey)) {
          const socket = requestManager.getHttp2Client(clientKey);
          const connectionOptions = {
            createConnection() {
              return socket;
            }
          };
          process.nextTick(function onMakeRequest() {
            requestManager.makeRequest(clientRequest, clientKey, requestOptions, cb, connectionOptions);
          }.bind(requestManager));
        } else
          requestManager.holdConnectionToIdentification(clientKey, requestOptions, function onIdentification(error, connectionOptions) {
            if (error) {
              clientRequest.emitError(error);
              return;
            }
            requestManager.makeRequest(clientRequest, clientKey, requestOptions, cb, connectionOptions);
          }.bind(requestManager));
      }
      getClientKey(url) {
        return `${url.protocol || this.enforceProtocol}${url.servername || url.host || url.hostname}:${url.port}`;
      }
      getHttp2Client(clientKey) {
        return this.http2Clients[clientKey];
      }
      setHttp2Client(clientKey, client) {
        const httpManager = this;
        const prevClient = httpManager.http2Clients[clientKey];
        if (prevClient)
          httpManager.removeHttp2Client(clientKey, prevClient);
        httpManager.http2Clients[clientKey] = client;
        function closeClient() {
          httpManager.removeHttp2Client(clientKey, client);
        }
        client.on("close", closeClient);
        client.on("goaway", closeClient);
        client.on("error", closeClient);
        client.on("frameError", closeClient);
        client.on("timeout", closeClient);
      }
      removeHttp2Client(clientKey, client) {
        try {
          delete this.http2Clients[clientKey];
          if (!client.closed) {
            client.close();
          }
        } catch (err) {
        }
        client.removeAllListeners("close");
        client.removeAllListeners("error");
        client.removeAllListeners("frameError");
        client.removeAllListeners("timeout");
      }
      request(url, options2, cb) {
        var args = new RequestInternalEnforce(arguments);
        if (this.enforceProtocol) {
          args.protocol = this.enforceProtocol;
        }
        return new ClientRequest(args);
      }
      get() {
        var args = new RequestInternalEnforce(arguments);
        args.method = "GET";
        var request = this.request(args);
        request.end();
        return request;
      }
      hasCachedConnection(clientKey) {
        const http2Client = this.getHttp2Client(clientKey);
        if (http2Client) {
          return true;
        }
        return this.cachedHTTP1Result[clientKey] + this.keepH1IdentificationCacheFor < Date.now();
      }
      makeRequest(inStream, clientKey, requestOptions, cb, connectionOptions) {
        const http2Client = this.getHttp2Client(clientKey);
        if (http2Client) {
          return this.makeHttp2Request(clientKey, inStream, http2Client, Object.assign(connectionOptions || {}, requestOptions), cb);
        }
        if (!requestOptions.agent) {
          if (requestOptions.protocol == "https:")
            requestOptions.agent = this.httpsAgent;
          else
            requestOptions.agent = this.httpAgent;
        }
        return this.makeHttpRequest(clientKey, inStream, requestOptions, cb, connectionOptions);
      }
      holdConnectionToIdentification(clientKey, requestOptions, cb) {
        const topic = `identify-${clientKey}`;
        if (this._events[topic])
          this.once(topic, cb);
        else {
          this.once(topic, function letKnowThereIsAnEvent() {
          });
          const socket = this.identifyConnection(requestOptions, function onIdentify(error, type) {
            if (error) {
              return cb(error);
            }
            var options2 = {
              createConnection() {
                return socket;
              }
            };
            if (type == "h2" && this.http2Support) {
              var http2Client = this.http2.connect(requestOptions, options2);
              this.setHttp2Client(clientKey, http2Client);
            } else {
              this.cachedHTTP1Result[clientKey] = Date.now();
            }
            cb(null, options2);
            this.emit(topic, options2);
          }.bind(this));
        }
      }
      makeHttpRequest(clientKey, inStream, options2, cb, connectionOptions) {
        if (options2 instanceof URL2)
          options2 = urlToOptions(options2);
        const h1op = _extend({}, options2);
        if (connectionOptions)
          h1op.createConnection = connectionOptions.createConnection;
        const requestModule = h1op.protocol == "https:" ? this.https : this.http;
        const req = requestModule.request(h1op, cb);
        inStream.take(req);
        inStream._on("response", function onHttp1Response(v) {
          this.emit("http1.response", v);
        });
      }
      makeHttp2Request(clientKey, inStream, http2Client, requestOptions, cb) {
        var http2Debouncer = this.http2Debouncer;
        http2Debouncer.pause(clientKey);
        var headers = _extend({}, requestOptions.headers || {});
        if (requestOptions.method)
          headers[":method"] = requestOptions.method;
        if (requestOptions.path)
          headers[":path"] = requestOptions.path;
        Object.keys(headers).forEach((key2) => {
          if (HEADERS_TO_REMOVE.indexOf((key2 + "").toLowerCase()) != -1) {
            delete headers[key2];
          }
        });
        requestOptions.headers = headers;
        var req = http2Client.request(
          headers
        );
        inStream.emit("socket", requestOptions.createConnection());
        let maxContentLength;
        let currentContent = 0;
        req.on("data", function onData(data) {
          currentContent += data.length;
          if (currentContent >= maxContentLength)
            http2Debouncer.unpauseAndTime(clientKey);
        });
        inStream.take(req);
        function onResponse(headers2) {
          maxContentLength = parseInt(headers2["content-length"]);
          if (maxContentLength < 0)
            this.http2Debouncer.unpauseAndTime(clientKey);
          _HttpRequestManager.httpCompatibleResponse(req, requestOptions, headers2);
          inStream.emit("http1.response", req);
          if (cb)
            cb(req);
        }
        onResponse.http2Safe = true;
        req.once("response", onResponse.bind(this));
      }
      static httpCompatibleResponse(res, requestOptions, headers) {
        res.httpVersion = "2.0";
        res.rawHeaders = headers;
        res.headers = headers;
        res.statusCode = headers[":status"];
        delete headers[":status"];
      }
      identifyConnection(requestOptions, cb) {
        var socket = this.connect(requestOptions, { allowHTTP1: true }, function onConnect() {
          socket.removeListener("error", cb);
          if (socket.alpnProtocol == "h2") {
            cb(null, "h2");
          } else {
            socket.end();
            cb(null, "h1");
          }
        });
        socket.on("error", cb);
        return socket;
      }
      connect(authority, options2, listener) {
        if (typeof options2 === "function") {
          listener = options2;
          options2 = void 0;
        }
        assertIsObject(options2, "options");
        options2 = Object.assign({}, options2);
        if (typeof authority === "string")
          authority = new URL2(authority);
        assertIsObject(authority, "authority", ["string", "Object", "URL"]);
        var protocol2 = authority.protocol || options2.protocol || (this.enforceProtocol != "detect" ? this.enforceProtocol : null) || "http:";
        var port = "" + (authority.port !== "" ? authority.port : authority.protocol === "http:" ? 80 : 443);
        var host = authority.hostname || authority.host || "localhost";
        var socket;
        if (typeof options2.createConnection === "function") {
          socket = options2.createConnection(authority, options2);
        } else {
          switch (protocol2) {
            case "http:":
              socket = this.net.connect(port, host, listener);
              break;
            case "https:":
              socket = this.tls.connect(port, host, initializeTLSOptions.call(this, options2, host), listener);
              break;
            default:
              throw new Error("Not supprted" + protocol2);
          }
        }
        return socket;
      }
    };
    function urlToOptions(url) {
      var options2 = {
        protocol: url.protocol,
        hostname: url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname}${url.search}`,
        href: url.href
      };
      if (url.port !== "") {
        options2.port = Number(url.port);
      }
      if (url.username || url.password) {
        options2.auth = `${url.username}:${url.password}`;
      }
      return options2;
    }
    var RequestInternalEnforce = class _RequestInternalEnforce {
      constructor(args) {
        if (args[0] instanceof _RequestInternalEnforce) {
          return args[0];
        }
        this.args = args;
        this.method = null;
        this.protocol = null;
      }
    };
    var HttpsRequest = class extends HttpRequestManager {
      constructor() {
        super(...arguments);
        this.Agent = https.Agent;
        this.globalAgent = https.globalAgent;
        this.enforceProtocol = "https:";
      }
    };
    var httpsRequestSinglton = new HttpsRequest();
    HttpsRequest.globalManager = httpsRequestSinglton;
    HttpsRequest.Manager = HttpsRequest;
    var HttpRequest = class extends HttpRequestManager {
      constructor() {
        super(...arguments);
        this.Agent = http.Agent;
        this.globalAgent = http.globalAgent;
        this.enforceProtocol = "http:";
      }
    };
    var httpRequestSinglton = new HttpRequest();
    HttpRequest.globalManager = httpRequestSinglton;
    HttpRequest.Manager = HttpRequest;
    var singeltonHttpManager = new HttpRequestManager();
    singeltonHttpManager.enforceProtocol = "detect";
    HttpRequestManager.globalManager = singeltonHttpManager;
    module.exports = {
      HttpRequest,
      HttpsRequest,
      HTTP2OutgoingMessage: ClientRequest,
      ClientRequest,
      HttpRequestManager
    };
  }
});

// node_modules/http2-client/lib/http.js
var require_http = __commonJS({
  "node_modules/http2-client/lib/http.js"(exports, module) {
    var {
      HttpRequest,
      ClientRequest
    } = require_request();
    var globalManager = HttpRequest.globalManager;
    var request = globalManager.request.bind(globalManager);
    var get = globalManager.get.bind(globalManager);
    var http = Object.assign({}, __require("http"));
    module.exports = Object.assign(http, {
      ClientRequest,
      globalManager,
      request,
      get
    });
  }
});

// node_modules/http2-client/lib/https.js
var require_https = __commonJS({
  "node_modules/http2-client/lib/https.js"(exports, module) {
    var {
      HttpsRequest,
      ClientRequest
    } = require_request();
    var globalManager = HttpsRequest.globalManager;
    var request = globalManager.request.bind(globalManager);
    var get = globalManager.get.bind(globalManager);
    var https = Object.assign({}, __require("https"));
    module.exports = Object.assign(https, {
      ClientRequest,
      globalManager,
      request,
      get
    });
  }
});

// node_modules/http2-client/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/http2-client/lib/index.js"(exports, module) {
    var {
      HttpRequestManager,
      HTTP2OutgoingMessage,
      ClientRequest
    } = require_request();
    var http = require_http();
    var https = require_https();
    var autoDetectManager = new HttpRequestManager();
    HttpRequestManager.globalManager = autoDetectManager;
    var request = autoDetectManager.request.bind(autoDetectManager);
    var get = autoDetectManager.get.bind(autoDetectManager);
    module.exports = {
      HTTP2OutgoingMessage,
      ClientRequest,
      globalManager: HttpRequestManager.globalManager,
      request,
      get,
      http,
      https
    };
  }
});

// node_modules/node-fetch-h2/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/node-fetch-h2/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(__require("stream"));
    var http = _interopDefault(__require("http"));
    var Url = _interopDefault(__require("url"));
    var h2 = _interopDefault(require_lib2());
    var zlib = _interopDefault(__require("zlib"));
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options2 = arguments[1];
        const buffers = [];
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options2 && options2.type !== void 0 && String(options2.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = __require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (body instanceof Blob2) {
        body = body[BUFFER];
      } else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name2 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name2);
          Object.defineProperty(proto, name2, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      if (this.body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (Buffer.isBuffer(this.body)) {
        return Body.Promise.resolve(this.body);
      }
      if (!(this.body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        _this4.body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        _this4.body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        _this4.body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function clone2(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (body instanceof Blob2) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name2) {
      name2 = `${name2}`;
      if (invalidTokenRegex.test(name2)) {
        throw new TypeError(`${name2} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find2(map, name2) {
      name2 = name2.toLowerCase();
      for (const key2 in map) {
        if (key2.toLowerCase() === name2) {
          return key2;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers2 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair2 of init) {
              if (typeof pair2 !== "object" || typeof pair2[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair2));
            }
            for (const pair2 of pairs) {
              if (pair2.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair2[0], pair2[1]);
            }
          } else {
            for (const key2 of Object.keys(init)) {
              const value = init[key2];
              this.append(key2, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key2 = find2(this[MAP], name2);
        if (key2 === void 0) {
          return null;
        }
        return this[MAP][key2].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name2 = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name2, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name2, value) {
        name2 = `${name2}`;
        value = `${value}`;
        validateName(name2);
        validateValue(value);
        const key2 = find2(this[MAP], name2);
        this[MAP][key2 !== void 0 ? key2 : name2] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name2, value) {
        name2 = `${name2}`;
        value = `${value}`;
        validateName(name2);
        validateValue(value);
        const key2 = find2(this[MAP], name2);
        if (key2 !== void 0) {
          this[MAP][key2].push(value);
        } else {
          this[MAP][name2] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name2) {
        name2 = `${name2}`;
        validateName(name2);
        return find2(this[MAP], name2) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key2 = find2(this[MAP], name2);
        if (key2 !== void 0) {
          delete this[MAP][key2];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys2 = Object.keys(headers[MAP]).sort();
      return keys2.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index2 = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index2 >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index2 + 1;
        return {
          value: values[index2],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find2(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2();
      for (const name2 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name2)) {
          continue;
        }
        if (Array.isArray(obj[name2])) {
          for (const val of obj[name2]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name2] === void 0) {
              headers[MAP][name2] = [val];
            } else {
              headers[MAP][name2].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name2])) {
          headers[MAP][name2] = [obj[name2]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts2);
        const status = opts2.status || 200;
        const headers = new Headers2(opts2.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts2.url,
          status,
          statusText: opts2.statusText || STATUS_CODES[status],
          headers
        };
      }
      get url() {
        return this[INTERNALS$1].url;
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var parse_url = Url.parse;
    var format_url = Url.format;
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone2(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers2(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers2(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      if (!headers.has("Connection") && !request.agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent: request.agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var PassThrough$1 = Stream.PassThrough;
    var resolve_url = Url.resolve;
    function fetch2(url, opts2) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve, reject) {
        const request = new Request(url, opts2);
        const options2 = getNodeRequestOptions(request);
        const send = h2.request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options2);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            const locationURL = location === null ? null : resolve_url(request.url, location);
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal
                };
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module.exports = exports = fetch2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers2;
    exports.Request = Request;
    exports.Response = Response;
    exports.FetchError = FetchError;
  }
});

// node_modules/yaml/dist/PlainValue-ec8e588e.js
var require_PlainValue_ec8e588e = __commonJS({
  "node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports) {
    "use strict";
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src) {
      const ls = [0];
      let offset = src.indexOf("\n");
      while (offset !== -1) {
        offset += 1;
        ls.push(offset);
        offset = src.indexOf("\n", offset);
      }
      return ls;
    }
    function getSrcInfo(cst) {
      let lineStarts, src;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src = cst;
      } else {
        if (Array.isArray(cst)) cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src = cst.context.src;
        }
      }
      return {
        lineStarts,
        src
      };
    }
    function getLinePos(offset, cst) {
      if (typeof offset !== "number" || offset < 0) return null;
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !src || offset > src.length) return null;
      for (let i = 0; i < lineStarts.length; ++i) {
        const start = lineStarts[i];
        if (offset < start) {
          return {
            line: i,
            col: offset - lineStarts[i - 1] + 1
          };
        }
        if (offset === start) return {
          line: i + 1,
          col: 1
        };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset - lineStarts[line - 1] + 1
      };
    }
    function getLine(line, cst) {
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src[end - 1] === "\n") --end;
      return src.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src = getLine(start.line, cst);
      if (!src) return null;
      let {
        col
      } = start;
      if (src.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src = src.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src.length - maxWidth;
          src = "\u2026" + src.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src}
${offset}${err}${errEnd}`;
    }
    var Range3 = class _Range {
      static copy(orig) {
        return new _Range(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      /**
       * Set `origStart` and `origEnd` to point to the original source range for
       * this node, which may differ due to dropped CR characters.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
      setOrigRange(cr, offset) {
        const {
          start,
          end
        } = this;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        let i = offset;
        while (i < cr.length) {
          if (cr[i] > start) break;
          else ++i;
        }
        this.origStart = start + i;
        const nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end) break;
          else ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    };
    var Node2 = class _Node {
      static addStringTerminator(src, offset, str) {
        if (str[str.length - 1] === "\n") return str;
        const next = _Node.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str + "\n" : str;
      }
      // ^(---|...)
      static atDocumentBoundary(src, offset, sep) {
        const ch0 = src[offset];
        if (!ch0) return true;
        const prev = src[offset - 1];
        if (prev && prev !== "\n") return false;
        if (sep) {
          if (ch0 !== sep) return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
        }
        const ch1 = src[offset + 1];
        const ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0) return false;
        const ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src, offset) {
        let ch = src[offset];
        const isVerbatim = ch === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];
        if (isVerbatim && ch === ">") offset += 1;
        return offset;
      }
      static endOfIndent(src, offset) {
        let ch = src[offset];
        while (ch === " ") ch = src[offset += 1];
        return offset;
      }
      static endOfLine(src, offset) {
        let ch = src[offset];
        while (ch && ch !== "\n") ch = src[offset += 1];
        return offset;
      }
      static endOfWhiteSpace(src, offset) {
        let ch = src[offset];
        while (ch === "	" || ch === " ") ch = src[offset += 1];
        return offset;
      }
      static startOfLine(src, offset) {
        let ch = src[offset - 1];
        if (ch === "\n") return offset;
        while (ch && ch !== "\n") ch = src[offset -= 1];
        return offset + 1;
      }
      /**
       * End of indentation, or null if the line's indent level is not more
       * than `indent`
       *
       * @param {string} src
       * @param {number} indent
       * @param {number} lineStart
       * @returns {?number}
       */
      static endOfBlockIndent(src, indent, lineStart) {
        const inEnd = _Node.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = _Node.endOfWhiteSpace(src, inEnd);
          const ch = src[wsEnd];
          if (!ch || ch === "\n") return wsEnd;
        }
        return null;
      }
      static atBlank(src, offset, endAsBlank) {
        const ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
      static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0) return false;
        if (indentDiff > 0) return true;
        return indicatorAsIndent && ch === "-";
      }
      // should be at line or string end, or at next non-whitespace char
      static normalizeOffset(src, offset) {
        const ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : _Node.endOfWhiteSpace(src, offset);
      }
      // fold single newline into space, multiple newlines to N - 1 newlines
      // presumes src[offset] === '\n'
      static foldNewline(src, offset, indent) {
        let inCount = 0;
        let error = false;
        let fold = "";
        let ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent) error = true;
              offset = _Node.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold) fold = " ";
        if (ch && inCount <= indent) error = true;
        return {
          fold,
          offset,
          error
        };
      }
      constructor(type, props, context) {
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type;
        this.value = null;
      }
      getPropValue(idx, key2, skipKey) {
        if (!this.context) return null;
        const {
          src
        } = this.context;
        const prop = this.props[idx];
        return prop && src[prop.start] === key2 ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i = 0; i < this.props.length; ++i) {
          const anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null) return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i = 0; i < this.props.length; ++i) {
          const comment2 = this.getPropValue(i, Char.COMMENT, true);
          if (comment2 != null) comments.push(comment2);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src
        } = this.context;
        if (this.header && start === this.header.end) return false;
        if (!this.valueRange) return false;
        const {
          end
        } = this.valueRange;
        return start !== end || _Node.atBlank(src, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT) return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT) return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context) return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start) return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context) return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i = 0; i < this.props.length; ++i) {
          const tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context) return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        for (let i = start; i < end; ++i) {
          if (src[i] === "\n") return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src
        } = this.context;
        if (src[start] === Char.COMMENT) {
          const end = _Node.endOfLine(src, start + 1);
          const commentRange = new Range3(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      /**
       * Populates the `origStart` and `origEnd` values of all ranges for this
       * node. Extended by child classes to handle descendant nodes.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
      setOrigRanges(cr, offset) {
        if (this.range) offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
        this.props.forEach((prop) => prop.setOrigRange(cr, offset));
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          range,
          value
        } = this;
        if (value != null) return value;
        const str = src.slice(range.start, range.end);
        return _Node.addStringTerminator(src, range.end, str);
      }
    };
    var YAMLError = class extends Error {
      constructor(name2, source, message) {
        if (!message || !(source instanceof Node2)) throw new Error(`Invalid arguments for new ${name2}`);
        super();
        this.name = name2;
        this.message = message;
        this.source = source;
      }
      makePretty() {
        if (!this.source) return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range3(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx) this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLReferenceError", source, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSemanticError", source, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSyntaxError", source, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source, message) {
        super("YAMLWarning", source, message);
      }
    };
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    var PlainValue = class _PlainValue extends Node2 {
      static endOfLine(src, start, inFlow) {
        let ch = src[start];
        let offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ",")) break;
          const next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ",")) break;
          if ((ch === " " || ch === "	") && next === "#") break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        let ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " ")) ch = src[--end - 1];
        let str = "";
        for (let i = start; i < end; ++i) {
          const ch2 = src[i];
          if (ch2 === "\n") {
            const {
              fold,
              offset
            } = Node2.foldNewline(src, i, -1);
            str += fold;
            i = offset;
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str += ch2;
          }
        }
        const ch0 = src[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          default:
            return str;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src
        } = this.context;
        let offset = start;
        let valueEnd = start;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node2.atDocumentBoundary(src, offset + 1)) break;
          const end = Node2.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#") break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = _PlainValue.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty()) this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      /**
       * Parses a plain value from the source
       *
       * Accepted forms are:
       * ```
       * #comment
       *
       * first line
       *
       * first line #comment
       *
       * first line
       * block
       * lines
       *
       * #comment
       * block
       * lines
       * ```
       * where block lines are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar, may be `\n`
       */
      parse(context, start) {
        this.context = context;
        const {
          inFlow,
          src
        } = context;
        let offset = start;
        const ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = _PlainValue.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range3(start, offset);
        offset = Node2.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    };
    exports.Char = Char;
    exports.Node = Node2;
    exports.PlainValue = PlainValue;
    exports.Range = Range3;
    exports.Type = Type;
    exports.YAMLError = YAMLError;
    exports.YAMLReferenceError = YAMLReferenceError;
    exports.YAMLSemanticError = YAMLSemanticError;
    exports.YAMLSyntaxError = YAMLSyntaxError;
    exports.YAMLWarning = YAMLWarning;
    exports._defineProperty = _defineProperty;
    exports.defaultTagPrefix = defaultTagPrefix;
    exports.defaultTags = defaultTags;
  }
});

// node_modules/yaml/dist/parse-cst.js
var require_parse_cst = __commonJS({
  "node_modules/yaml/dist/parse-cst.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var BlankLine = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.BLANK_LINE);
      }
      /* istanbul ignore next */
      get includesTrailingLines() {
        return true;
      }
      /**
       * Parses a blank line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first \n character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        this.range = new PlainValue.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue.Node {
      constructor(type, props) {
        super(type, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          atLineStart,
          lineStart
        } = context;
        if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context.indent;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        let ch = src[offset];
        const inlineComment = ch === "#";
        const comments = [];
        let blankLine = null;
        while (ch === "\n" || ch === "#") {
          if (ch === "#") {
            const end2 = PlainValue.Node.endOfLine(src, offset + 1);
            comments.push(new PlainValue.Range(offset, end2));
            offset = end2;
          } else {
            atLineStart = true;
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
            if (src[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
            }
            offset = PlainValue.Node.endOfIndent(src, lineStart);
          }
          ch = src[offset];
        }
        if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset);
        } else if (ch && lineStart > start + 1) {
          offset = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context.parent.items || context.parent.contents;
            if (items) items.push(blankLine);
          }
          if (comments.length) Array.prototype.push.apply(this.props, comments);
          offset = this.node.range.end;
        } else {
          if (inlineComment) {
            const c = comments[0];
            this.props.push(c);
            offset = c.end;
          } else {
            offset = PlainValue.Node.endOfLine(src, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset;
        this.valueRange = new PlainValue.Range(start, end);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.node ? this.node.setOrigRanges(cr, offset) : offset;
      }
      toString() {
        const {
          context: {
            src
          },
          node,
          range,
          value
        } = this;
        if (value != null) return value;
        const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str);
      }
    };
    var Comment = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.COMMENT);
      }
      /**
       * Parses a comment line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const offset = this.parseComment(start);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    function grabCollectionEndComments(node) {
      let cnode = node;
      while (cnode instanceof CollectionItem) cnode = cnode.node;
      if (!(cnode instanceof Collection)) return null;
      const len = cnode.items.length;
      let ci = -1;
      for (let i = len - 1; i >= 0; --i) {
        const n = cnode.items[i];
        if (n.type === PlainValue.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n.context;
          if (indent > 0 && n.range.start >= lineStart + indent) break;
          ci = i;
        } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;
        else break;
      }
      if (ci === -1) return null;
      const ca = cnode.items.splice(ci, len - ci);
      const prevEnd = ca[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
        if (cnode === node) break;
        cnode = cnode.context.parent;
      }
      return ca;
    }
    var Collection = class _Collection extends PlainValue.Node {
      static nextContentHasIndent(src, offset, indent) {
        const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
        offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
        const ch = src[offset];
        if (!ch) return false;
        if (offset >= lineStart + indent) return true;
        if (ch !== "#" && ch !== "\n") return false;
        return _Collection.nextContentHasIndent(src, offset, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);
        for (let i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec) Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let lineStart = PlainValue.Node.startOfLine(src, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset = start;
        offset = PlainValue.Node.normalizeOffset(src, offset);
        let ch = src[offset];
        let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
        let prevIncludesTrailingLines = false;
        while (ch) {
          while (ch === "\n" || ch === "#") {
            if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset = blankLine.parse({
                src
              }, offset);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
              this.items.push(blankLine);
              offset -= 1;
            } else if (ch === "#") {
              if (offset < lineStart + indent && !_Collection.nextContentHasIndent(src, offset, indent)) {
                return offset;
              }
              const comment2 = new Comment();
              offset = comment2.parse({
                indent,
                lineStart,
                src
              }, offset);
              this.items.push(comment2);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
            }
            lineStart = offset + 1;
            offset = PlainValue.Node.endOfIndent(src, lineStart);
            if (PlainValue.Node.atBlank(src, offset)) {
              const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
              const next = src[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset = wsEnd;
              }
            }
            ch = src[offset];
            atLineStart = true;
          }
          if (!ch) {
            break;
          }
          if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
            if (offset < lineStart + indent) {
              if (lineStart > start) offset = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
            if (ch !== "-") {
              if (lineStart > start) offset = lineStart;
              break;
            }
          } else if (ch === "-" && !this.error) {
            const next = src[offset + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          const node = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset);
          if (!node) return offset;
          this.items.push(node);
          this.valueRange.end = node.valueRange.end;
          offset = PlainValue.Node.normalizeOffset(src, node.range.end);
          ch = src[offset];
          atLineStart = false;
          prevIncludesTrailingLines = node.includesTrailingLines;
          if (ch) {
            let ls = offset - 1;
            let prev = src[ls];
            while (prev === " " || prev === "	") prev = src[--ls];
            if (prev === "\n") {
              lineStart = ls + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node);
          if (ec) Array.prototype.push.apply(this.items, ec);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null) return value;
        let str = src.slice(range.start, items[0].range.start) + String(items[0]);
        for (let i = 1; i < items.length; ++i) {
          const item = items[i];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart) for (let i2 = 0; i2 < indent; ++i2) str += " ";
          str += String(item);
        }
        return PlainValue.Node.addStringTerminator(src, range.end, str);
      }
    };
    var Directive = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "	" && ch !== " ") ch = src[offset += 1];
        this.name = src.slice(start, offset);
        return offset;
      }
      parseParameters(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "#") ch = src[offset += 1];
        this.valueRange = new PlainValue.Range(start, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        let offset = this.parseName(start + 1);
        offset = this.parseParameters(offset);
        offset = this.parseComment(offset);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    var Document = class _Document extends PlainValue.Node {
      static startCommentOrEndBlankLine(src, start) {
        const offset = PlainValue.Node.endOfWhiteSpace(src, start);
        const ch = src[offset];
        return ch === "#" || ch === "\n" ? offset : start;
      }
      constructor() {
        super(PlainValue.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset = start;
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
          offset = _Document.startCommentOrEndBlankLine(src, offset);
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment2 = new Comment();
                offset = comment2.parse({
                  src
                }, offset);
                this.directives.push(comment2);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset = directive.parse({
                  parent: this,
                  src
                }, offset);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset;
          }
        }
        if (src[offset]) {
          this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
          return offset + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset;
      }
      parseContents(start) {
        const {
          parseNode,
          src
        } = this.context;
        if (!this.contents) this.contents = [];
        let lineStart = start;
        while (src[lineStart - 1] === "-") lineStart -= 1;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue.Range(offset);
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              lineStart = offset;
              break;
            case "#":
              {
                const comment2 = new Comment();
                offset = comment2.parse({
                  src
                }, offset);
                this.contents.push(comment2);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue.Node.endOfIndent(src, offset);
              const context = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node = parseNode(context, iEnd);
              if (!node) return this.valueRange.end = iEnd;
              this.contents.push(node);
              offset = node.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node);
              if (ec) Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset = _Document.startCommentOrEndBlankLine(src, offset);
        }
        this.valueRange.end = offset;
        if (src[offset]) {
          this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
          offset += 3;
          if (src[offset]) {
            offset = PlainValue.Node.endOfWhiteSpace(src, offset);
            if (src[offset] === "#") {
              const comment2 = new Comment();
              offset = comment2.parse({
                src
              }, offset);
              this.contents.push(comment2);
            }
            switch (src[offset]) {
              case "\n":
                offset += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        context.root = this;
        this.context = context;
        const {
          src
        } = context;
        let offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
        offset = this.parseDirectives(offset);
        offset = this.parseContents(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.directives.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
        this.contents.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
        return offset;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null) return value;
        let str = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += "---\n";
          str += contents.join("");
        }
        if (str[str.length - 1] !== "\n") str += "\n";
        return str;
      }
    };
    var Alias = class extends PlainValue.Node {
      /**
       * Parses an *alias from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
        this.valueRange = new PlainValue.Range(start + 1, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue.Node {
      constructor(type, props) {
        super(type, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (this.valueRange.isEmpty()) return "";
        let lastNewLine = null;
        let ch = src[end - 1];
        while (ch === "\n" || ch === "	" || ch === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP) break;
            else return "";
          }
          if (ch === "\n") lastNewLine = end;
          ch = src[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi = indent + this.blockIndent;
        const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
        let atStart = true;
        let str = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i = start; i < end; ++i) {
          for (let j = 0; j < bi; ++j) {
            if (src[i] !== " ") break;
            i += 1;
          }
          const ch2 = src[i];
          if (ch2 === "\n") {
            if (sep === "\n") str += "\n";
            else sep = "\n";
          } else {
            const lineEnd = PlainValue.Node.endOfLine(src, i);
            const line = src.slice(i, lineEnd);
            i = lineEnd;
            if (folded && (ch2 === " " || ch2 === "	") && i < keepStart) {
              if (sep === " ") sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n") sep = "\n\n";
              str += sep + line;
              sep = lineEnd < end && src[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str += sep + line;
              sep = folded && i < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "") atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str : str + "\n";
      }
      parseBlockHeader(start) {
        const {
          src
        } = this.context;
        let offset = start + 1;
        let bi = "";
        while (true) {
          const ch = src[offset];
          switch (ch) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi += ch;
              break;
            default:
              this.blockIndent = Number(bi) || null;
              this.header = new PlainValue.Range(start, offset);
              return offset;
          }
          offset += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          offset += 1;
          if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
          const end = PlainValue.Node.endOfBlockIndent(src, indent, offset);
          if (end === null) break;
          const ch2 = src[end];
          const lineIndent = end - (offset + indent);
          if (!this.blockIndent) {
            if (src[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch2 && ch2 !== "\n" && lineIndent < this.blockIndent) {
            if (src[end] === "#") break;
            if (!this.error) {
              const src2 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src2}`;
              this.error = new PlainValue.YAMLSemanticError(this, msg);
            }
          }
          if (src[end] === "\n") {
            offset = end;
          } else {
            offset = valueEnd = PlainValue.Node.endOfLine(src, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue.Range(start + 1, offset);
        return offset;
      }
      /**
       * Parses a block value from the source
       *
       * Accepted forms are:
       * ```
       * BS
       * block
       * lines
       *
       * BS #comment
       * block
       * lines
       * ```
       * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
       * are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this block
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = this.parseBlockHeader(start);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        offset = this.parseBlockValue(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.header ? this.header.setOrigRange(cr, offset) : offset;
      }
    };
    var FlowCollection = class extends PlainValue.Node {
      constructor(type, props) {
        super(type, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node = this.items[idx - 1];
        return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          indent,
          lineStart
        } = context;
        let char = src[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        char = src[offset];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset + 1;
                const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
                if (src[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset = PlainValue.Node.endOfIndent(src, lineStart);
                if (offset <= lineStart + indent) {
                  char = src[offset];
                  if (offset < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
              }
              break;
            case "#":
              {
                const comment2 = new Comment();
                offset = comment2.parse({
                  src
                }, offset);
                this.items.push(comment2);
              }
              break;
            case "?":
            case ":": {
              const next = src[offset + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
              char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
                break;
              }
            }
            default: {
              const node = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset);
              if (!node) {
                this.valueRange = new PlainValue.Range(start, offset);
                return offset;
              }
              this.items.push(node);
              offset = PlainValue.Node.normalizeOffset(src, node.range.end);
            }
          }
          offset = PlainValue.Node.endOfWhiteSpace(src, offset);
          char = src[offset];
        }
        this.valueRange = new PlainValue.Range(start, offset + 1);
        if (char) {
          this.items.push({
            char,
            offset
          });
          offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
          offset = this.parseComment(offset);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node) => {
          if (node instanceof PlainValue.Node) {
            offset = node.setOrigRanges(cr, offset);
          } else if (cr.length === 0) {
            node.origOffset = node.offset;
          } else {
            let i = offset;
            while (i < cr.length) {
              if (cr[i] > node.offset) break;
              else ++i;
            }
            node.origOffset = node.offset + i;
            offset = i;
          }
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null) return value;
        const nodes = items.filter((item) => item instanceof PlainValue.Node);
        let str = "";
        let prevEnd = range.start;
        nodes.forEach((node) => {
          const prefix = src.slice(prevEnd, node.range.start);
          prevEnd = node.range.end;
          str += prefix + String(node);
          if (str[str.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str += src.slice(prevEnd, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str);
      }
    };
    var QuoteDouble = class _QuoteDouble extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch && ch !== '"') {
          offset += ch === "\\" ? 2 : 1;
          ch = src[offset];
        }
        return offset + 1;
      }
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str += fold;
            i = offset;
            if (error) errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch === "\\") {
            i += 1;
            switch (src[i]) {
              case "0":
                str += "\0";
                break;
              case "a":
                str += "\x07";
                break;
              case "b":
                str += "\b";
                break;
              case "e":
                str += "\x1B";
                break;
              case "f":
                str += "\f";
                break;
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "v":
                str += "\v";
                break;
              case "N":
                str += "\x85";
                break;
              case "_":
                str += "\xA0";
                break;
              case "L":
                str += "\u2028";
                break;
              case "P":
                str += "\u2029";
                break;
              case " ":
                str += " ";
                break;
              case '"':
                str += '"';
                break;
              case "/":
                str += "/";
                break;
              case "\\":
                str += "\\";
                break;
              case "	":
                str += "	";
                break;
              case "x":
                str += this.parseCharCode(i + 1, 2, errors);
                i += 2;
                break;
              case "u":
                str += this.parseCharCode(i + 1, 4, errors);
                i += 4;
                break;
              case "U":
                str += this.parseCharCode(i + 1, 8, errors);
                i += 8;
                break;
              case "\n":
                while (src[i + 1] === " " || src[i + 1] === "	") i += 1;
                break;
              default:
                errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
                str += "\\" + src[i];
            }
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str
        } : str;
      }
      parseCharCode(offset, length, errors) {
        const {
          src
        } = this.context;
        const cc = src.substr(offset, length);
        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
          return src.substr(offset - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      /**
       * Parses a "double quoted" value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = _QuoteDouble.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var QuoteSingle = class _QuoteSingle extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch) {
          if (ch === "'") {
            if (src[offset + 1] !== "'") break;
            ch = src[offset += 2];
          } else {
            ch = src[offset += 1];
          }
        }
        return offset + 1;
      }
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      get strValue() {
        if (!this.valueRange || !this.context) return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str += fold;
            i = offset;
            if (error) errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch === "'") {
            str += ch;
            i += 1;
            if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str
        } : str;
      }
      /**
       * Parses a 'single quoted' value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = _QuoteSingle.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    function createNewNode(type, props) {
      switch (type) {
        case PlainValue.Type.ALIAS:
          return new Alias(type, props);
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
          return new BlockValue(type, props);
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.FLOW_SEQ:
          return new FlowCollection(type, props);
        case PlainValue.Type.MAP_KEY:
        case PlainValue.Type.MAP_VALUE:
        case PlainValue.Type.SEQ_ITEM:
          return new CollectionItem(type, props);
        case PlainValue.Type.COMMENT:
        case PlainValue.Type.PLAIN:
          return new PlainValue.PlainValue(type, props);
        case PlainValue.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type, props);
        case PlainValue.Type.QUOTE_SINGLE:
          return new QuoteSingle(type, props);
        default:
          return null;
      }
    }
    var ParseContext2 = class _ParseContext {
      static parseType(src, offset, inFlow) {
        switch (src[offset]) {
          case "*":
            return PlainValue.Type.ALIAS;
          case ">":
            return PlainValue.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue.Type.FLOW_MAP;
          case "[":
            return PlainValue.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;
          case '"':
            return PlainValue.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue.Type.QUOTE_SINGLE;
          default:
            return PlainValue.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
          const context = new _ParseContext(this, overlay);
          const {
            props,
            type,
            valueStart
          } = context.parseProps(start);
          const node = createNewNode(type, props);
          let offset = node.parse(context, valueStart);
          node.range = new PlainValue.Range(start, offset);
          if (offset <= start) {
            node.error = new Error(`Node#parse consumed no characters`);
            node.error.parseEnd = offset;
            node.error.source = node;
            node.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node)) {
            if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
              node.error = new PlainValue.YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection(node);
            offset = collection.parse(new _ParseContext(context), offset);
            collection.range = new PlainValue.Range(start, offset);
            return collection;
          }
          return node;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node) {
        const {
          inCollection,
          inFlow,
          src
        } = this;
        if (inCollection || inFlow) return false;
        if (node instanceof CollectionItem) return true;
        let offset = node.range.end;
        if (src[offset] === "\n" || src[offset - 1] === "\n") return false;
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        return src[offset] === ":";
      }
      // Anchor and tag are before type, which determines the node implementation
      // class; hence this intermediate step.
      parseProps(offset) {
        const {
          inFlow,
          parent,
          src
        } = this;
        const props = [];
        let lineHasProps = false;
        offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
        let ch = src[offset];
        while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === "\n") {
          if (ch === "\n") {
            let inEnd = offset;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue.Node.endOfIndent(src, lineStart);
            } while (src[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src[inEnd] !== "#" && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset = inEnd;
          } else if (ch === PlainValue.Char.COMMENT) {
            const end = PlainValue.Node.endOfLine(src, offset + 1);
            props.push(new PlainValue.Range(offset, end));
            offset = end;
          } else {
            let end = PlainValue.Node.endOfIdentifier(src, offset + 1);
            if (ch === PlainValue.Char.TAG && src[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
              end = PlainValue.Node.endOfIdentifier(src, end + 5);
            }
            props.push(new PlainValue.Range(offset, end));
            lineHasProps = true;
            offset = PlainValue.Node.endOfWhiteSpace(src, end);
          }
          ch = src[offset];
        }
        if (lineHasProps && ch === ":" && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
        const type = _ParseContext.parseType(src, offset, inFlow);
        return {
          props,
          type,
          valueStart: offset
        };
      }
      /**
       * Parses a node from the source
       * @param {ParseContext} overlay
       * @param {number} start - Index of first non-whitespace character for the node
       * @returns {?Node} - null if at a document boundary
       */
    };
    function parse(src) {
      const cr = [];
      if (src.indexOf("\r") !== -1) {
        src = src.replace(/\r\n?/g, (match, offset2) => {
          if (match.length > 1) cr.push(offset2);
          return "\n";
        });
      }
      const documents = [];
      let offset = 0;
      do {
        const doc2 = new Document();
        const context = new ParseContext2({
          src
        });
        offset = doc2.parse(context, offset);
        documents.push(doc2);
      } while (offset < src.length);
      documents.setOrigRanges = () => {
        if (cr.length === 0) return false;
        for (let i = 1; i < cr.length; ++i) cr[i] -= i;
        let crOffset = 0;
        for (let i = 0; i < documents.length; ++i) {
          crOffset = documents[i].setOrigRanges(cr, crOffset);
        }
        cr.splice(0, cr.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    exports.parse = parse;
  }
});

// node_modules/yaml/dist/resolveSeq-d03cb037.js
var require_resolveSeq_d03cb037 = __commonJS({
  "node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    function addCommentBefore(str, indent, comment2) {
      if (!comment2) return str;
      const cc = comment2.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str}`;
    }
    function addComment(str, indent, comment2) {
      return !comment2 ? str : comment2.indexOf("\n") === -1 ? `${str} #${comment2}` : `${str}
` + comment2.replace(/^/gm, `${indent || ""}#`);
    }
    var Node2 = class {
    };
    function toJSON(value, arg, ctx) {
      if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor) ctx.onCreate = (res2) => {
          anchor.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate) ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint") return Number(value);
      return value;
    }
    var Scalar = class extends Node2 {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, k, {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return schema.createNode(v, false);
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
    var Collection = class _Collection extends Node2 {
      constructor(schema) {
        super();
        PlainValue._defineProperty(this, "items", []);
        this.schema = schema;
      }
      addIn(path, value) {
        if (isEmptyPath(path)) this.add(value);
        else {
          const [key2, ...rest] = path;
          const node = this.get(key2, true);
          if (node instanceof _Collection) node.addIn(rest, value);
          else if (node === void 0 && this.schema) this.set(key2, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key2, ...rest]) {
        if (rest.length === 0) return this.delete(key2);
        const node = this.get(key2, true);
        if (node instanceof _Collection) return node.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
      }
      getIn([key2, ...rest], keepScalar) {
        const node = this.get(key2, true);
        if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;
        else return node instanceof _Collection ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node) => {
          if (!node || node.type !== "PAIR") return false;
          const n = node.value;
          return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key2, ...rest]) {
        if (rest.length === 0) return this.has(key2);
        const node = this.get(key2, true);
        return node instanceof _Collection ? node.hasIn(rest) : false;
      }
      setIn([key2, ...rest], value) {
        if (rest.length === 0) {
          this.set(key2, value);
        } else {
          const node = this.get(key2, true);
          if (node instanceof _Collection) node.setIn(rest, value);
          else if (node === void 0 && this.schema) this.set(key2, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
        }
      }
      // overridden in implementations
      /* istanbul ignore next */
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify
        } = ctx;
        const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow) itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i) => {
          let comment2;
          if (item) {
            if (!chompKeep && item.spaceBefore) nodes2.push({
              type: "comment",
              str: ""
            });
            if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach((line) => {
              nodes2.push({
                type: "comment",
                str: `#${line}`
              });
            });
            if (item.comment) comment2 = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str2 = stringify(item, ctx, () => comment2 = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str2.includes("\n")) hasItemWithNewLine = true;
          if (inFlow && i < this.items.length - 1) str2 += ",";
          str2 = addComment(str2, itemIndent, comment2);
          if (chompKeep && (comment2 || inFlow)) chompKeep = false;
          nodes2.push({
            type: "item",
            str: str2
          });
          return nodes2;
        }, []);
        let str;
        if (nodes.length === 0) {
          str = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n) => n.str);
          if (hasItemWithNewLine || strings.reduce((sum, str2) => sum + str2.length + 2, 2) > _Collection.maxFlowStringSingleLineLength) {
            str = start;
            for (const s of strings) {
              str += s ? `
${indentStep}${indent}${s}` : "\n";
            }
            str += `
${indent}${end}`;
          } else {
            str = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str = strings.shift();
          for (const s of strings) str += s ? `
${indent}${s}` : "\n";
        }
        if (this.comment) {
          str += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment) onComment();
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str;
      }
    };
    PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key2) {
      let idx = key2 instanceof Scalar ? key2.value : key2;
      if (idx && typeof idx === "string") idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq = class extends Collection {
      add(value) {
        this.items.push(value);
      }
      delete(key2) {
        const idx = asItemIndex(key2);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key2, keepScalar) {
        const idx = asItemIndex(key2);
        if (typeof idx !== "number") return void 0;
        const it = this.items[idx];
        return !keepScalar && it instanceof Scalar ? it.value : it;
      }
      has(key2) {
        const idx = asItemIndex(key2);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key2, value) {
        const idx = asItemIndex(key2);
        if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key2}.`);
        this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx && ctx.onCreate) ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key2, jsKey, ctx) => {
      if (jsKey === null) return "";
      if (typeof jsKey !== "object") return String(jsKey);
      if (key2 instanceof Node2 && ctx && ctx.doc) return key2.toString({
        anchors: /* @__PURE__ */ Object.create(null),
        doc: ctx.doc,
        indent: "",
        indentStep: ctx.indentStep,
        inFlow: true,
        inStringifyKey: true,
        stringify: ctx.stringify
      });
      return JSON.stringify(jsKey);
    };
    var Pair = class _Pair extends Node2 {
      constructor(key2, value = null) {
        super();
        this.key = key2;
        this.value = value;
        this.type = _Pair.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node2 ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null) this.key = new Scalar(null);
        if (this.key instanceof Node2) this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map) {
        const key2 = toJSON(this.key, "", ctx);
        if (map instanceof Map) {
          const value = toJSON(this.value, key2, ctx);
          map.set(key2, value);
        } else if (map instanceof Set) {
          map.add(key2);
        } else {
          const stringKey = stringifyKey(this.key, key2, ctx);
          const value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map) Object.defineProperty(map, stringKey, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
          else map[stringKey] = value;
        }
        return map;
      }
      toJSON(_, ctx) {
        const pair2 = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair2);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc) return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key: key2,
          value
        } = this;
        let keyComment = key2 instanceof Node2 && key2.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key2 instanceof Collection) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key2 || keyComment || (key2 instanceof Node2 ? key2 instanceof Collection || key2.type === PlainValue.Type.BLOCK_FOLDED || key2.type === PlainValue.Type.BLOCK_LITERAL : typeof key2 === "object"));
        const {
          doc: doc2,
          indent,
          indentStep,
          stringify
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str = stringify(key2, ctx, () => keyComment = null, () => chompKeep = true);
        str = addComment(str, ctx.indent, keyComment);
        if (!explicitKey && str.length > 1024) {
          if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment) onComment();
          } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();
          return ctx.inFlow && !explicitKey ? str : `? ${str}`;
        }
        str = explicitKey ? `? ${str}
${indent}:` : `${str}:`;
        if (this.comment) {
          str = addComment(str, ctx.indent, this.comment);
          if (onComment) onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node2) {
          if (value.spaceBefore) vcb = "\n";
          if (value.commentBefore) {
            const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc2.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc2.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws = " ";
        if (vcb || this.comment) {
          ws = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n")) ws = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n") ws = "";
        if (chompKeep && !valueComment && onChompKeep) onChompKeep();
        return addComment(str + ws + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue._defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node, anchors) => {
      if (node instanceof Alias) {
        const anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(item, anchors);
          if (c > count) count = c;
        }
        return count;
      } else if (node instanceof Pair) {
        const kc = getAliasCount(node.key, anchors);
        const vc = getAliasCount(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias = class _Alias extends Node2 {
      static stringify({
        range,
        source
      }, {
        anchors,
        doc: doc2,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
        if (!anchor && inStringifyKey) anchor = doc2.anchors.getName(source) || doc2.anchors.newName();
        if (anchor) return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc2.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range}]`);
      }
      constructor(source) {
        super();
        this.source = source;
        this.type = PlainValue.Type.ALIAS;
      }
      set tag(t2) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx) return toJSON(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
          else throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
            else throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      // Only called when stringifying an alias mapping key while constructing
      // Object output.
      toString(ctx) {
        return _Alias.stringify(this, ctx);
      }
    };
    PlainValue._defineProperty(Alias, "default", true);
    function findPair(items, key2) {
      const k = key2 instanceof Scalar ? key2.value : key2;
      for (const it of items) {
        if (it instanceof Pair) {
          if (it.key === key2 || it.key === k) return it;
          if (it.key && it.key.value === k) return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection {
      add(pair2, overwrite) {
        if (!pair2) pair2 = new Pair(pair2);
        else if (!(pair2 instanceof Pair)) pair2 = new Pair(pair2.key || pair2, pair2.value);
        const prev = findPair(this.items, pair2.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite) prev.value = pair2.value;
          else throw new Error(`Key ${pair2.key} already set`);
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(pair2, item) < 0);
          if (i === -1) this.items.push(pair2);
          else this.items.splice(i, 0, pair2);
        } else {
          this.items.push(pair2);
        }
      }
      delete(key2) {
        const it = findPair(this.items, key2);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key2, keepScalar) {
        const it = findPair(this.items, key2);
        const node = it && it.value;
        return !keepScalar && node instanceof Scalar ? node.value : node;
      }
      has(key2) {
        return !!findPair(this.items, key2);
      }
      set(key2, value) {
        this.add(new Pair(key2, value), true);
      }
      /**
       * @param {*} arg ignored
       * @param {*} ctx Conversion context, originally set in Document#toJSON()
       * @param {Class} Type If set, forces the returned collection type
       * @returns {*} Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate) ctx.onCreate(map);
        for (const item of this.items) item.addToJSMap(ctx, map);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n) => n.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge = class extends Pair {
      constructor(pair2) {
        if (pair2 instanceof Pair) {
          let seq = pair2.value;
          if (!(seq instanceof YAMLSeq)) {
            seq = new YAMLSeq();
            seq.items.push(pair2.value);
            seq.range = pair2.value.range;
          }
          super(pair2.key, seq);
          this.range = pair2.range;
        } else {
          super(new Scalar(MERGE_KEY), new YAMLSeq());
        }
        this.type = Pair.Type.MERGE_PAIR;
      }
      // If the value associated with a merge key is a single mapping node, each of
      // its key/value pairs is inserted into the current mapping, unless the key
      // already exists in it. If the value associated with the merge key is a
      // sequence, then this sequence is expected to contain mapping nodes and each
      // of these nodes is merged in turn according to its order in the sequence.
      // Keys in mapping nodes earlier in the sequence override keys specified in
      // later mapping nodes. -- http://yaml.org/type/merge.html
      addToJSMap(ctx, map) {
        for (const {
          source
        } of this.value.items) {
          if (!(source instanceof YAMLMap)) throw new Error("Merge sources must be maps");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key2, value] of srcMap) {
            if (map instanceof Map) {
              if (!map.has(key2)) map.set(key2, value);
            } else if (map instanceof Set) {
              map.add(key2);
            } else if (!Object.prototype.hasOwnProperty.call(map, key2)) {
              Object.defineProperty(map, key2, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map;
      }
      toString(ctx, onComment) {
        const seq = this.value;
        if (seq.items.length > 1) return super.toString(ctx, onComment);
        this.value = seq.items[0];
        const str = super.toString(ctx, onComment);
        this.value = seq;
        return str;
      }
    };
    var binaryOptions = {
      defaultType: PlainValue.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions = {
      asBigInt: false
    };
    var nullOptions = {
      nullStr: "null"
    };
    var strOptions = {
      defaultType: PlainValue.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str, tags2, scalarFallback) {
      for (const {
        format,
        test,
        resolve
      } of tags2) {
        if (test) {
          const match = str.match(test);
          if (match) {
            let res = resolve.apply(null, match);
            if (!(res instanceof Scalar)) res = new Scalar(res);
            if (format) res.format = format;
            return res;
          }
        }
      }
      if (scalarFallback) str = scalarFallback(str);
      return new Scalar(str);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text2, i) => {
      let ch = text2[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text2[i += 1];
        } while (ch && ch !== "\n");
        ch = text2[i + 1];
      }
      return i;
    };
    function foldFlowLines(text2, indent, mode, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0) return text2;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text2.length <= endStep) return text2;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text2, i);
        if (i !== -1) end = i + endStep;
      }
      for (let ch; ch = text2[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text2[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text2, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text2[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	") split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text2[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j]) return text2;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow) onOverflow();
      if (folds.length === 0) return text2;
      if (onFold) onFold();
      let res = text2.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text2.length;
        if (fold === 0) res = `
${indent}${text2.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text2[fold]}\\`;
          res += `
${indent}${text2.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0) return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit) return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit) return true;
          start = i + 1;
          if (strLen - start <= limit) return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions.doubleQuoted;
      const json2 = JSON.stringify(value);
      if (jsonEncoding) return json2;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
        if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
          str += json2.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\") switch (json2[i + 1]) {
          case "u":
            {
              str += json2.slice(start, i);
              const code = json2.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
                  else str += json2.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json2.slice(start, i) + "\n\n";
              while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                str += "\n";
                i += 2;
              }
              str += indent;
              if (json2[i + 2] === " ") str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
      }
      str = start ? str + json2.slice(start) : json2;
      return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value)) return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment: comment2,
      type,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal2 = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
      let header = literal2 ? "|" : ">";
      if (!value) return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf("\n");
        if (n === -1) {
          header += "-";
        } else if (value === ws || n !== ws.length - 1) {
          header += "+";
          if (onChompKeep) onChompKeep();
        }
        wsEnd = ws.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(" ") !== -1) header += indentSize;
        const m = ws.match(/ +$/);
        if (m) {
          wsStart = ws.slice(0, -m[0].length);
          return m[0];
        } else {
          wsStart = ws;
          return "";
        }
      });
      if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment2) {
        header += " #" + comment2.replace(/ ?[\r\n]+/g, " ");
        if (onComment) onComment();
      }
      if (!value) return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal2) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment: comment2,
        type,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags: tags2
        } = ctx.doc.schema;
        const resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
        if (typeof resolved !== "string") return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment2 && !inFlow && (body.indexOf("\n") !== -1 || comment2.indexOf("\n") !== -1)) {
        if (onComment) onComment();
        return addCommentBefore(body, indent, comment2);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue.Type.BLOCK_FOLDED:
          case PlainValue.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type = PlainValue.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {
        type = PlainValue.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint") return String(value);
      if (!isFinite(value)) return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0) n += "0";
      }
      return n;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name2;
      switch (cst.type) {
        case PlainValue.Type.FLOW_MAP:
          char = "}";
          name2 = "flow map";
          break;
        case PlainValue.Type.FLOW_SEQ:
          char = "]";
          name2 = "flow sequence";
          break;
        default:
          errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i = cst.items.length - 1; i >= 0; --i) {
        const item = cst.items[i];
        if (!item || item.type !== PlainValue.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name2} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment2) {
      const prev = comment2.context.src[comment2.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue.YAMLSemanticError(comment2, msg));
      }
    }
    function getLongKeyError(source, key2) {
      const sk = String(key2);
      const k = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment: comment2
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment2 !== void 0) {
            if (collection.comment) collection.comment += "\n" + comment2;
            else collection.comment = comment2;
          }
        } else {
          if (afterKey && item.value) item = item.value;
          if (comment2 === void 0) {
            if (afterKey || !item.commentBefore) item.spaceBefore = true;
          } else {
            if (item.commentBefore) item.commentBefore += "\n" + comment2;
            else item.commentBefore = comment2;
          }
        }
      }
    }
    function resolveString(doc2, node) {
      const res = node.strValue;
      if (!res) return "";
      if (typeof res === "string") return res;
      res.errors.forEach((error) => {
        if (!error.source) error.source = node;
        doc2.errors.push(error);
      });
      return res.str;
    }
    function resolveTagHandle(doc2, node) {
      const {
        handle,
        suffix
      } = node.tag;
      let prefix = doc2.tagPrefixes.find((p) => p.handle === handle);
      if (!prefix) {
        const dtp = doc2.getDefaults().tagPrefixes;
        if (dtp) prefix = dtp.find((p) => p.handle === handle);
        if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc2.version || doc2.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc2.warnings.push(new PlainValue.YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc2, node) {
      const {
        tag,
        type
      } = node;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!") return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc2.errors.push(new PlainValue.YAMLSemanticError(node, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc2, node);
          } catch (error) {
            doc2.errors.push(error);
          }
        }
      }
      switch (type) {
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
        case PlainValue.Type.QUOTE_DOUBLE:
        case PlainValue.Type.QUOTE_SINGLE:
          return PlainValue.defaultTags.STR;
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        case PlainValue.Type.PLAIN:
          return nonSpecific ? PlainValue.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc2, node, tagName) {
      const {
        tags: tags2
      } = doc2.schema;
      const matchWithTest = [];
      for (const tag of tags2) {
        if (tag.tag === tagName) {
          if (tag.test) matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc2, node);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
      const str = resolveString(doc2, node);
      if (typeof str === "string" && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags2.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type
    }) {
      switch (type) {
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        default:
          return PlainValue.defaultTags.STR;
      }
    }
    function resolveTag(doc2, node, tagName) {
      try {
        const res = resolveByTagName(doc2, node, tagName);
        if (res) {
          if (tagName && node.tag) res.tag = tagName;
          return res;
        }
      } catch (error) {
        if (!error.source) error.source = node;
        doc2.errors.push(error);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node);
        if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc2.warnings.push(new PlainValue.YAMLWarning(node, msg));
        const res = resolveByTagName(doc2, node, fallback);
        res.tag = tagName;
        return res;
      } catch (error) {
        const refError = new PlainValue.YAMLReferenceError(node, error.message);
        refError.stack = error.stack;
        doc2.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node) => {
      if (!node) return false;
      const {
        type
      } = node;
      return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
      for (const {
        start,
        end
      } of props) {
        switch (node.context.src[start]) {
          case PlainValue.Char.COMMENT: {
            if (!node.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            const {
              header,
              valueRange
            } = node;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc2, node) {
      const {
        anchors,
        errors,
        schema
      } = doc2;
      if (node.type === PlainValue.Type.ALIAS) {
        const name2 = node.rawValue;
        const src = anchors.getNode(name2);
        if (!src) {
          const msg = `Aliased anchor not found: ${name2}`;
          errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
        const res = new Alias(src);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc2, node);
      if (tagName) return resolveTag(doc2, node, tagName);
      if (node.type !== PlainValue.Type.PLAIN) {
        const msg = `Failed to resolve ${node.type} node here`;
        errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        return null;
      }
      try {
        const str = resolveString(doc2, node);
        return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
      } catch (error) {
        if (!error.source) error.source = node;
        errors.push(error);
        return null;
      }
    }
    function resolveNode2(doc2, node) {
      if (!node) return null;
      if (node.error) doc2.errors.push(node.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc2.errors, node);
      if (hasAnchor) {
        const {
          anchors
        } = doc2;
        const name2 = node.anchor;
        const prev = anchors.getNode(name2);
        if (prev) anchors.map[anchors.newName(name2)] = prev;
        anchors.map[name2] = node;
      }
      if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc2.errors.push(new PlainValue.YAMLSemanticError(node, msg));
      }
      const res = resolveNodeValue(doc2, node);
      if (res) {
        res.range = [node.range.start, node.range.end];
        if (doc2.options.keepCstNodes) res.cstNode = node;
        if (doc2.options.keepNodeTypes) res.type = node.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca = comments.after.join("\n");
        if (ca) res.comment = res.comment ? `${res.comment}
${ca}` : ca;
      }
      return node.resolved = res;
    }
    function resolveMap(doc2, cst) {
      if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc2.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc2, cst) : resolveBlockMapItems(doc2, cst);
      const map = new YAMLMap();
      map.items = items;
      resolveComments(map, comments);
      let hasCollectionKey = false;
      for (let i = 0; i < items.length; ++i) {
        const {
          key: iKey
        } = items[i];
        if (iKey instanceof Collection) hasCollectionKey = true;
        if (doc2.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i] = new Merge(items[i]);
          const sources = items[i].value.items;
          let error = null;
          sources.some((node) => {
            if (node instanceof Alias) {
              const {
                type
              } = node.source;
              if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;
              return error = "Merge nodes aliases can only point to maps";
            }
            return error = "Merge nodes can only have Alias nodes as values";
          });
          if (error) doc2.errors.push(new PlainValue.YAMLSemanticError(cst, error));
        } else {
          for (let j = i + 1; j < items.length; ++j) {
            const {
              key: jKey
            } = items[j];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc2.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc2.options.mapAsMap) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc2.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = map;
      return map;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node,
        src
      },
      props
    }) => {
      if (props.length === 0) return false;
      const {
        start
      } = props[0];
      if (node && start > node.valueRange.start) return false;
      if (src[start] !== PlainValue.Char.COMMENT) return false;
      for (let i = lineStart; i < start; ++i) if (src[i] === "\n") return false;
      return true;
    };
    function resolvePairComment(item, pair2) {
      if (!valueHasPairComment(item)) return;
      const comment2 = item.getPropValue(0, PlainValue.Char.COMMENT, true);
      let found = false;
      const cb = pair2.value.commentBefore;
      if (cb && cb.startsWith(comment2)) {
        pair2.value.commentBefore = cb.substr(comment2.length + 1);
        found = true;
      } else {
        const cc = pair2.value.comment;
        if (!item.node && cc && cc.startsWith(comment2)) {
          pair2.value.comment = cc.substr(comment2.length + 1);
          found = true;
        }
      }
      if (found) pair2.comment = comment2;
    }
    function resolveBlockMapItems(doc2, cst) {
      const comments = [];
      const items = [];
      let key2 = void 0;
      let keyStart = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key2,
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              afterKey: !!key2,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue.Type.MAP_KEY:
            if (key2 !== void 0) items.push(new Pair(key2));
            if (item.error) doc2.errors.push(item.error);
            key2 = resolveNode2(doc2, item.node);
            keyStart = null;
            break;
          case PlainValue.Type.MAP_VALUE:
            {
              if (key2 === void 0) key2 = null;
              if (item.error) doc2.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc2.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair2 = new Pair(key2, resolveNode2(doc2, valueNode));
              resolvePairComment(item, pair2);
              items.push(pair2);
              if (key2 && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024) doc2.errors.push(getLongKeyError(cst, key2));
              }
              key2 = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key2 !== void 0) items.push(new Pair(key2));
            key2 = resolveNode2(doc2, item);
            keyStart = item.range.start;
            if (item.error) doc2.errors.push(item.error);
            next: for (let j = i + 1; ; ++j) {
              const nextItem = cst.items[j];
              switch (nextItem && nextItem.type) {
                case PlainValue.Type.BLANK_LINE:
                case PlainValue.Type.COMMENT:
                  continue next;
                case PlainValue.Type.MAP_VALUE:
                  break next;
                default: {
                  const msg = "Implicit map keys need to be followed by map values";
                  doc2.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                  break next;
                }
              }
            }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc2.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key2 !== void 0) items.push(new Pair(key2));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc2, cst) {
      const comments = [];
      const items = [];
      let key2 = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char === "?" && key2 === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key2 === void 0) key2 = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key2 === void 0 && char !== ",") key2 = null;
              explicitKey = false;
            }
            if (key2 !== void 0) {
              items.push(new Pair(key2));
              key2 = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i === cst.items.length - 1) continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue.YAMLSyntaxError(cst, msg);
          err.offset = offset;
          doc2.errors.push(err);
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key2,
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc2.errors, item);
          comments.push({
            afterKey: !!key2,
            before: items.length,
            comment: item.comment
          });
        } else if (key2 === void 0) {
          if (next === ",") doc2.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
          key2 = resolveNode2(doc2, item);
        } else {
          if (next !== ",") doc2.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair(key2, resolveNode2(doc2, item)));
          key2 = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc2.errors, cst);
      if (key2 !== void 0) items.push(new Pair(key2));
      return {
        comments,
        items
      };
    }
    function resolveSeq(doc2, cst) {
      if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc2.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc2, cst) : resolveBlockSeqItems(doc2, cst);
      const seq = new YAMLSeq();
      seq.items = items;
      resolveComments(seq, comments);
      if (!doc2.options.mapAsMap && items.some((it) => it instanceof Pair && it.key instanceof Collection)) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc2.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = seq;
      return seq;
    }
    function resolveBlockSeqItems(doc2, cst) {
      const comments = [];
      const items = [];
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue.Type.SEQ_ITEM:
            if (item.error) doc2.errors.push(item.error);
            items.push(resolveNode2(doc2, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc2.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error) doc2.errors.push(item.error);
            doc2.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc2, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key2 = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char !== ":" && (explicitKey || key2 !== void 0)) {
            if (explicitKey && key2 === void 0) key2 = next ? items.pop() : null;
            items.push(new Pair(key2));
            explicitKey = false;
            key2 = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key2 === void 0) {
            if (next === ",") {
              key2 = items.pop();
              if (key2 instanceof Pair) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = offset;
                doc2.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024) doc2.errors.push(getLongKeyError(cst, key2));
                const {
                  src
                } = prevItem.context;
                for (let i2 = keyStart; i2 < keyEnd; ++i2) if (src[i2] === "\n") {
                  const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                  doc2.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                  break;
                }
              }
            } else {
              key2 = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue.YAMLSyntaxError(cst, msg);
            err.offset = offset;
            doc2.errors.push(err);
          }
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc2.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc2.errors.push(new PlainValue.YAMLSemanticError(item, msg));
          }
          const value = resolveNode2(doc2, item);
          if (key2 === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair(key2, value));
            key2 = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc2.errors, cst);
      if (key2 !== void 0) items.push(new Pair(key2));
      return {
        comments,
        items
      };
    }
    exports.Alias = Alias;
    exports.Collection = Collection;
    exports.Merge = Merge;
    exports.Node = Node2;
    exports.Pair = Pair;
    exports.Scalar = Scalar;
    exports.YAMLMap = YAMLMap;
    exports.YAMLSeq = YAMLSeq;
    exports.addComment = addComment;
    exports.binaryOptions = binaryOptions;
    exports.boolOptions = boolOptions;
    exports.findPair = findPair;
    exports.intOptions = intOptions;
    exports.isEmptyPath = isEmptyPath;
    exports.nullOptions = nullOptions;
    exports.resolveMap = resolveMap;
    exports.resolveNode = resolveNode2;
    exports.resolveSeq = resolveSeq;
    exports.resolveString = resolveString;
    exports.strOptions = strOptions;
    exports.stringifyNumber = stringifyNumber;
    exports.stringifyString = stringifyString;
    exports.toJSON = toJSON;
  }
});

// node_modules/yaml/dist/warnings-1000a372.js
var require_warnings_1000a372 = __commonJS({
  "node_modules/yaml/dist/warnings-1000a372.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve: (doc2, node) => {
        const src = resolveSeq.resolveString(doc2, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc2.errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: resolveSeq.binaryOptions,
      stringify: ({
        comment: comment2,
        type,
        value
      }, ctx, onComment, onChompKeep) => {
        let src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type) type = resolveSeq.binaryOptions.defaultType;
        if (type === PlainValue.Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          const {
            lineWidth
          } = resolveSeq.binaryOptions;
          const n = Math.ceil(src.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = src.substr(o, lineWidth);
          }
          value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq.stringifyString({
          comment: comment2,
          type,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc2, cst) {
      const seq = resolveSeq.resolveSeq(doc2, cst);
      for (let i = 0; i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (item instanceof resolveSeq.Pair) continue;
        else if (item instanceof resolveSeq.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          }
          const pair2 = item.items[0] || new resolveSeq.Pair();
          if (item.commentBefore) pair2.commentBefore = pair2.commentBefore ? `${item.commentBefore}
${pair2.commentBefore}` : item.commentBefore;
          if (item.comment) pair2.comment = pair2.comment ? `${item.comment}
${pair2.comment}` : item.comment;
          item = pair2;
        }
        seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
      }
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const pairs2 = new resolveSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      for (const it of iterable) {
        let key2, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key2 = it[0];
            value = it[1];
          } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys2 = Object.keys(it);
          if (keys2.length === 1) {
            key2 = keys2[0];
            value = it[key2];
          } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key2 = it;
        }
        const pair2 = schema.createPair(key2, value, ctx);
        pairs2.items.push(pair2);
      }
      return pairs2;
    }
    var pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class _YAMLOMap extends resolveSeq.YAMLSeq {
      constructor() {
        super();
        PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
        PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
        PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
        PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
        PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
        this.tag = _YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        const map = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate) ctx.onCreate(map);
        for (const pair2 of this.items) {
          let key2, value;
          if (pair2 instanceof resolveSeq.Pair) {
            key2 = resolveSeq.toJSON(pair2.key, "", ctx);
            value = resolveSeq.toJSON(pair2.value, key2, ctx);
          } else {
            key2 = resolveSeq.toJSON(pair2, "", ctx);
          }
          if (map.has(key2)) throw new Error("Ordered maps must not include duplicate keys");
          map.set(key2, value);
        }
        return map;
      }
    };
    PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc2, cst) {
      const pairs2 = parsePairs(doc2, cst);
      const seenKeys = [];
      for (const {
        key: key2
      } of pairs2.items) {
        if (key2 instanceof resolveSeq.Scalar) {
          if (seenKeys.includes(key2.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key2.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs2);
    }
    function createOMap(schema, iterable, ctx) {
      const pairs2 = createPairs(schema, iterable, ctx);
      const omap2 = new YAMLOMap();
      omap2.items = pairs2.items;
      return omap2;
    }
    var omap = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class _YAMLSet extends resolveSeq.YAMLMap {
      constructor() {
        super();
        this.tag = _YAMLSet.tag;
      }
      add(key2) {
        const pair2 = key2 instanceof resolveSeq.Pair ? key2 : new resolveSeq.Pair(key2);
        const prev = resolveSeq.findPair(this.items, pair2.key);
        if (!prev) this.items.push(pair2);
      }
      get(key2, keepPair) {
        const pair2 = resolveSeq.findPair(this.items, key2);
        return !keepPair && pair2 instanceof resolveSeq.Pair ? pair2.key instanceof resolveSeq.Scalar ? pair2.key.value : pair2.key : pair2;
      }
      set(key2, value) {
        if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq.findPair(this.items, key2);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq.Pair(key2));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
      }
    };
    PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc2, cst) {
      const map = resolveSeq.resolveMap(doc2, cst);
      if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map);
    }
    function createSet(schema, iterable, ctx) {
      const set2 = new YAMLSet();
      for (const value of iterable) set2.items.push(schema.createPair(value, null, ctx));
      return set2;
    }
    var set = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
      return sign === "-" ? -n : n;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec) millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30) d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined") return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined") return !YAML_SILENCE_WARNINGS;
      return !env.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit) emit(warning, type);
        else {
          console.warn(type ? `${type}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename) {
      if (shouldWarn(true)) {
        const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned2 = {};
    function warnOptionDeprecation(name2, alternative) {
      if (!warned2[name2] && shouldWarn(true)) {
        warned2[name2] = true;
        let msg = `The option '${name2}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    exports.binary = binary;
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.omap = omap;
    exports.pairs = pairs;
    exports.set = set;
    exports.timestamp = timestamp;
    exports.warn = warn;
    exports.warnFileDeprecation = warnFileDeprecation;
    exports.warnOptionDeprecation = warnOptionDeprecation;
  }
});

// node_modules/yaml/dist/Schema-88e323a7.js
var require_Schema_88e323a7 = __commonJS({
  "node_modules/yaml/dist/Schema-88e323a7.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var warnings = require_warnings_1000a372();
    function createMap(schema, obj, ctx) {
      const map2 = new resolveSeq.YAMLMap(schema);
      if (obj instanceof Map) {
        for (const [key2, value] of obj) map2.items.push(schema.createPair(key2, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key2 of Object.keys(obj)) map2.items.push(schema.createPair(key2, obj[key2], ctx));
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    var map = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq.resolveMap
    };
    function createSeq(schema, obj, ctx) {
      const seq2 = new resolveSeq.YAMLSeq(schema);
      if (obj && obj[Symbol.iterator]) {
        for (const it of obj) {
          const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
          seq2.items.push(v);
        }
      }
      return seq2;
    }
    var seq = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq.resolveSeq
    };
    var string2 = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq.strOptions
    };
    var failsafe = [map, seq, string2];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    function intStringify$1(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
      return resolveSeq.stringifyNumber(node);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => str[0] === "t" || str[0] === "T",
      options: resolveSeq.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str, oct) => intResolve$1(str, oct, 8),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str) => intResolve$1(str, str, 10),
      options: resolveSeq.intOptions,
      stringify: resolveSeq.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str, hex) => intResolve$1(str, hex, 16),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str, frac1, frac2) {
        const frac = frac1 || frac2;
        const node = new resolveSeq.Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0") node.minFractionDigits = frac.length;
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    };
    var core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json2 = [map, seq, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str) => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }];
    json2.scalarFallback = (str) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src, radix) {
      let str = src.replace(/_/g, "");
      if (resolveSeq.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return resolveSeq.stringifyNumber(node);
    }
    var yaml11 = failsafe.concat([{
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node) => intStringify(node, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node) => intStringify(node, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node) => intStringify(node, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str, frac) {
        const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          const f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
    var schemas = {
      core,
      failsafe,
      json: json2,
      yaml11
    };
    var tags2 = {
      binary: warnings.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings.intTime,
      map,
      null: nullObj,
      omap: warnings.omap,
      pairs: warnings.pairs,
      seq,
      set: warnings.set,
      timestamp: warnings.timestamp
    };
    function findTagObject(value, tagName, tags3) {
      if (tagName) {
        const match = tags3.filter((t2) => t2.tag === tagName);
        const tagObj = match.find((t2) => !t2.format) || match[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags3.find((t2) => (t2.identify && t2.identify(value) || t2.class && value instanceof t2.class) && !t2.format);
    }
    function createNode(value, tagName, ctx) {
      if (value instanceof resolveSeq.Node) return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!")) tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function") value = value.toJSON();
        if (!value || typeof value !== "object") return wrapScalars ? new resolveSeq.Scalar(value) : value;
        tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias = new resolveSeq.Alias(prev);
          ctx.aliasNodes.push(alias);
          return alias;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags3 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags3) {
        const keys2 = Object.keys(schemas2).map((key2) => JSON.stringify(key2)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys2}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags) tags3 = tags3.concat(tag);
      } else if (typeof customTags === "function") {
        tags3 = customTags(tags3.slice());
      }
      for (let i = 0; i < tags3.length; ++i) {
        const tag = tags3[i];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys2 = Object.keys(knownTags).map((key2) => JSON.stringify(key2)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys2}`);
          }
          tags3[i] = tagObj;
        }
      }
      return tags3;
    }
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema2 = class _Schema {
      // TODO: remove in v2
      // TODO: remove in v2
      constructor({
        customTags,
        merge,
        schema,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags2, customTags || deprecatedCustomTags, schema);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: _Schema.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode(value, tagName, createCtx);
      }
      createPair(key2, value, ctx) {
        if (!ctx) ctx = {
          wrapScalars: true
        };
        const k = this.createNode(key2, ctx.wrapScalars, null, ctx);
        const v = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq.Pair(k, v);
      }
    };
    PlainValue._defineProperty(Schema2, "defaultPrefix", PlainValue.defaultTagPrefix);
    PlainValue._defineProperty(Schema2, "defaultTags", PlainValue.defaultTags);
    exports.Schema = Schema2;
  }
});

// node_modules/yaml/dist/Document-9b4560a1.js
var require_Document_9b4560a1 = __commonJS({
  "node_modules/yaml/dist/Document-9b4560a1.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema2 = require_Schema_88e323a7();
    var defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      // TODO Set true in v2
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc2, tag) {
      if ((doc2.version || doc2.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv) return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p = doc2.tagPrefixes.find((p2) => tag.indexOf(p2.prefix) === 0);
      if (!p) {
        const dtp = doc2.getDefaults().tagPrefixes;
        p = dtp && dtp.find((p2) => tag.indexOf(p2.prefix) === 0);
      }
      if (!p) return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, (ch) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch]);
      return p.handle + suffix;
    }
    function getTagObject(tags2, item) {
      if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;
      if (item.tag) {
        const match = tags2.filter((t2) => t2.tag === item.tag);
        if (match.length > 0) return match.find((t2) => t2.format === item.format) || match[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match = tags2.filter((t2) => t2.identify && t2.identify(obj) || t2.class && obj instanceof t2.class);
        tagObj = match.find((t2) => t2.format === item.format) || match.find((t2) => !t2.format);
      } else {
        obj = item;
        tagObj = tags2.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
      }
      if (!tagObj) {
        const name2 = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name2} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, {
      anchors,
      doc: doc2
    }) {
      const props = [];
      const anchor = doc2.anchors.getName(node);
      if (anchor) {
        anchors[anchor] = node;
        props.push(`&${anchor}`);
      }
      if (node.tag) {
        props.push(stringifyTag(doc2, node.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc2, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o) => tagObj = o,
          prevObjects: /* @__PURE__ */ new Map()
        };
        item = schema.createNode(item, true, null, createCtx);
        for (const alias of createCtx.aliasNodes) {
          alias.source = alias.source.node;
          let name2 = anchors.getName(alias.source);
          if (!name2) {
            name2 = anchors.newName();
            anchors.map[name2] = alias.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj) tagObj = getTagObject(schema.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props) return str;
      return item instanceof resolveSeq.Scalar || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    var Anchors = class _Anchors {
      static validAnchorNode(node) {
        return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue._defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node, name2) {
        this.setAnchor(node, name2);
        return new resolveSeq.Alias(node);
      }
      createMergePair(...sources) {
        const merge = new resolveSeq.Merge();
        merge.value.items = sources.map((s) => {
          if (s instanceof resolveSeq.Alias) {
            if (s.source instanceof resolveSeq.YAMLMap) return s;
          } else if (s instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge;
      }
      getName(node) {
        const {
          map
        } = this;
        return Object.keys(map).find((a) => map[a] === node);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name2) {
        return this.map[name2];
      }
      newName(prefix) {
        if (!prefix) prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i = 1; true; ++i) {
          const name2 = `${prefix}${i}`;
          if (!names.includes(name2)) return name2;
        }
      }
      // During parsing, map & aliases contain CST nodes
      resolveNodes() {
        const {
          map,
          _cstAliases
        } = this;
        Object.keys(map).forEach((a) => {
          map[a] = map[a].resolved;
        });
        _cstAliases.forEach((a) => {
          a.source = a.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node, name2) {
        if (node != null && !_Anchors.validAnchorNode(node)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name2 && /[\x00-\x19\s,[\]{}]/.test(name2)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map
        } = this;
        const prev = node && Object.keys(map).find((a) => map[a] === node);
        if (prev) {
          if (!name2) {
            return prev;
          } else if (prev !== name2) {
            delete map[prev];
            map[name2] = node;
          }
        } else {
          if (!name2) {
            if (!node) return null;
            name2 = this.newName();
          }
          map[name2] = node;
        }
        return name2;
      }
    };
    var visit = (node, tags2) => {
      if (node && typeof node === "object") {
        const {
          tag
        } = node;
        if (node instanceof resolveSeq.Collection) {
          if (tag) tags2[tag] = true;
          node.items.forEach((n) => visit(n, tags2));
        } else if (node instanceof resolveSeq.Pair) {
          visit(node.key, tags2);
          visit(node.value, tags2);
        } else if (node instanceof resolveSeq.Scalar) {
          if (tag) tags2[tag] = true;
        }
      }
      return tags2;
    };
    var listTagNames = (node) => Object.keys(visit(node, {}));
    function parseContents(doc2, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node of contents) {
        if (node.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc2.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc2, node);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node.comment);
        } else if (node.type === PlainValue.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc2.commentBefore) {
            doc2.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc2.contents = body || null;
      if (!body) {
        doc2.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc2.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p) => p.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc2, directive) {
      let [version] = directive.parameters;
      if (directive.name === "YAML:1.0") version = "1.0";
      if (!version) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version]) {
        const v0 = doc2.version || doc2.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
        doc2.warnings.push(new PlainValue.YAMLWarning(directive, msg));
      }
      return version;
    }
    function parseDirectives(doc2, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment: comment2,
          name: name2
        } = directive;
        switch (name2) {
          case "TAG":
            try {
              doc2.tagPrefixes.push(resolveTagDirective(doc2, directive));
            } catch (error) {
              doc2.errors.push(error);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc2.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc2.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
            }
            try {
              doc2.version = resolveYamlDirective(doc2, directive);
            } catch (error) {
              doc2.errors.push(error);
            }
            hasDirectives = true;
            break;
          default:
            if (name2) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name2}`;
              doc2.warnings.push(new PlainValue.YAMLWarning(directive, msg));
            }
        }
        if (comment2) directiveComments.push(comment2);
      }
      if (prevDoc && !hasDirectives && "1.1" === (doc2.version || prevDoc.version || doc2.options.version)) {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc2.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc2.version = prevDoc.version;
      }
      doc2.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection) return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document = class _Document {
      constructor(options2) {
        this.anchors = new Anchors(options2.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options2;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path, value) {
        assertCollection(this.contents);
        this.contents.addIn(path, value);
      }
      delete(key2) {
        assertCollection(this.contents);
        return this.contents.delete(key2);
      }
      deleteIn(path) {
        if (resolveSeq.isEmptyPath(path)) {
          if (this.contents == null) return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path);
      }
      getDefaults() {
        return _Document.defaults[this.version] || _Document.defaults[this.options.version] || {};
      }
      get(key2, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key2, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key2) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key2) : false;
      }
      hasIn(path) {
        if (resolveSeq.isEmptyPath(path)) return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
      }
      set(key2, value) {
        assertCollection(this.contents);
        this.contents.set(key2, value);
      }
      setIn(path, value) {
        if (resolveSeq.isEmptyPath(path)) this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema) return;
        if (typeof id === "number") id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version) this.version = id;
          else this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags)) this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema2.Schema(opt);
      }
      parse(node, prevDoc) {
        if (this.options.keepCstNodes) this.cstNode = node;
        if (this.options.keepNodeTypes) this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error,
          valueRange
        } = node;
        if (error) {
          if (!error.source) error.source = this;
          this.errors.push(error);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker) this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error2 of this.errors) if (error2 instanceof PlainValue.YAMLError) error2.makePretty();
          for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t2) => t2.indexOf(Schema2.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!") throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p) => p.handle === handle);
          if (prev) prev.prefix = prefix;
          else this.tagPrefixes.push({
            handle,
            prefix
          });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p) => p.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify
          // Requiring directly in Pair would create circular dependencies
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map((name2) => [this.anchors.map[name2], {
          alias: [],
          aliasCount: 0,
          count: 1
        }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors) for (const {
          count,
          res: res2
        } of ctx.anchors.values()) onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0") vd = "%YAML:1.0";
            else if (this.version === "1.1") vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t2) => t2.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker) lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker) lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify
          // Requiring directly in nodes would create circular dependencies
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push("");
            if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue._defineProperty(Document, "defaults", documentOptions);
    exports.Document = Document;
    exports.defaultOptions = defaultOptions;
    exports.scalarOptions = scalarOptions;
  }
});

// node_modules/yaml/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var parseCst = require_parse_cst();
    var Document$1 = require_Document_9b4560a1();
    var Schema2 = require_Schema_88e323a7();
    var PlainValue = require_PlainValue_ec8e588e();
    var warnings = require_warnings_1000a372();
    require_resolveSeq_d03cb037();
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options2 = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema = new Schema2.Schema(options2);
      return schema.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options2) {
        super(Object.assign({}, Document$1.defaultOptions, options2));
      }
    };
    function parseAllDocuments(src, options2) {
      const stream = [];
      let prev;
      for (const cstDoc of parseCst.parse(src)) {
        const doc2 = new Document(options2);
        doc2.parse(cstDoc, prev);
        stream.push(doc2);
        prev = doc2;
      }
      return stream;
    }
    function parseDocument(src, options2) {
      const cst = parseCst.parse(src);
      const doc2 = new Document(options2).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc2.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc2;
    }
    function parse(src, options2) {
      const doc2 = parseDocument(src, options2);
      doc2.warnings.forEach((warning) => warnings.warn(warning));
      if (doc2.errors.length > 0) throw doc2.errors[0];
      return doc2.toJSON();
    }
    function stringify(value, options2) {
      const doc2 = new Document(options2);
      doc2.contents = value;
      return String(doc2);
    }
    var YAML = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument,
      scalarOptions: Document$1.scalarOptions,
      stringify
    };
    exports.YAML = YAML;
  }
});

// node_modules/yaml/index.js
var require_yaml = __commonJS({
  "node_modules/yaml/index.js"(exports, module) {
    module.exports = require_dist4().YAML;
  }
});

// node_modules/reftools/lib/jptr.js
var require_jptr = __commonJS({
  "node_modules/reftools/lib/jptr.js"(exports, module) {
    "use strict";
    function jpescape(s) {
      return s.replace(/\~/g, "~0").replace(/\//g, "~1");
    }
    function jpunescape(s) {
      return s.replace(/\~1/g, "/").replace(/~0/g, "~");
    }
    function jptr(obj, prop, newValue) {
      if (typeof obj === "undefined") return false;
      if (!prop || typeof prop !== "string" || prop === "#") return typeof newValue !== "undefined" ? newValue : obj;
      if (prop.indexOf("#") >= 0) {
        let parts = prop.split("#");
        let uri = parts[0];
        if (uri) return false;
        prop = parts[1];
        prop = decodeURIComponent(prop.slice(1).split("+").join(" "));
      }
      if (prop.startsWith("/")) prop = prop.slice(1);
      let components = prop.split("/");
      for (let i = 0; i < components.length; i++) {
        components[i] = jpunescape(components[i]);
        let setAndLast = typeof newValue !== "undefined" && i == components.length - 1;
        let index2 = parseInt(components[i], 10);
        if (!Array.isArray(obj) || isNaN(index2) || index2.toString() !== components[i]) {
          index2 = Array.isArray(obj) && components[i] === "-" ? -2 : -1;
        } else {
          components[i] = i > 0 ? components[i - 1] : "";
        }
        if (index2 != -1 || obj && obj.hasOwnProperty(components[i])) {
          if (index2 >= 0) {
            if (setAndLast) {
              obj[index2] = newValue;
            }
            obj = obj[index2];
          } else if (index2 === -2) {
            if (setAndLast) {
              if (Array.isArray(obj)) {
                obj.push(newValue);
              }
              return newValue;
            } else return void 0;
          } else {
            if (setAndLast) {
              obj[components[i]] = newValue;
            }
            obj = obj[components[i]];
          }
        } else {
          if (typeof newValue !== "undefined" && typeof obj === "object" && !Array.isArray(obj)) {
            obj[components[i]] = setAndLast ? newValue : components[i + 1] === "0" || components[i + 1] === "-" ? [] : {};
            obj = obj[components[i]];
          } else return false;
        }
      }
      return obj;
    }
    module.exports = {
      jptr,
      jpescape,
      jpunescape
    };
  }
});

// node_modules/reftools/lib/isref.js
var require_isref = __commonJS({
  "node_modules/reftools/lib/isref.js"(exports, module) {
    "use strict";
    function isRef(obj, key2) {
      return key2 === "$ref" && (!!obj && typeof obj[key2] === "string");
    }
    module.exports = {
      isRef
    };
  }
});

// node_modules/reftools/lib/clone.js
var require_clone = __commonJS({
  "node_modules/reftools/lib/clone.js"(exports, module) {
    "use strict";
    function nop(obj) {
      return obj;
    }
    function clone2(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function shallowClone(obj) {
      let result = {};
      for (let p in obj) {
        if (obj.hasOwnProperty(p)) {
          result[p] = obj[p];
        }
      }
      return result;
    }
    function deepClone(obj) {
      let result = Array.isArray(obj) ? [] : {};
      for (let p in obj) {
        if (obj.hasOwnProperty(p) || Array.isArray(obj)) {
          result[p] = typeof obj[p] === "object" ? deepClone(obj[p]) : obj[p];
        }
      }
      return result;
    }
    function fastClone(obj) {
      return Object.assign({}, obj);
    }
    function circularClone(obj, hash) {
      if (!hash) hash = /* @__PURE__ */ new WeakMap();
      if (Object(obj) !== obj || obj instanceof Function) return obj;
      if (hash.has(obj)) return hash.get(obj);
      try {
        var result = new obj.constructor();
      } catch (e) {
        result = Object.create(Object.getPrototypeOf(obj));
      }
      hash.set(obj, result);
      return Object.assign(result, ...Object.keys(obj).map(
        (key2) => ({ [key2]: circularClone(obj[key2], hash) })
      ));
    }
    module.exports = {
      nop,
      clone: clone2,
      shallowClone,
      deepClone,
      fastClone,
      circularClone
    };
  }
});

// node_modules/reftools/lib/recurse.js
var require_recurse = __commonJS({
  "node_modules/reftools/lib/recurse.js"(exports, module) {
    "use strict";
    var jpescape = require_jptr().jpescape;
    function defaultState() {
      return {
        path: "#",
        depth: 0,
        pkey: "",
        parent: {},
        payload: {},
        seen: /* @__PURE__ */ new WeakMap(),
        identity: false,
        identityDetection: false
      };
    }
    function recurse(object, state, callback) {
      if (!state) state = { depth: 0 };
      if (!state.depth) {
        state = Object.assign({}, defaultState(), state);
      }
      if (typeof object !== "object") return;
      let oPath = state.path;
      for (let key2 in object) {
        state.key = key2;
        state.path = state.path + "/" + encodeURIComponent(jpescape(key2));
        state.identityPath = state.seen.get(object[key2]);
        state.identity = typeof state.identityPath !== "undefined";
        if (object.hasOwnProperty(key2)) {
          callback(object, key2, state);
        }
        if (typeof object[key2] === "object" && !state.identity) {
          if (state.identityDetection && !Array.isArray(object[key2]) && object[key2] !== null) {
            state.seen.set(object[key2], state.path);
          }
          let newState = {};
          newState.parent = object;
          newState.path = state.path;
          newState.depth = state.depth ? state.depth + 1 : 1;
          newState.pkey = key2;
          newState.payload = state.payload;
          newState.seen = state.seen;
          newState.identity = false;
          newState.identityDetection = state.identityDetection;
          recurse(object[key2], newState, callback);
        }
        state.path = oPath;
      }
    }
    module.exports = {
      recurse
    };
  }
});

// node_modules/reftools/lib/dereference.js
var require_dereference = __commonJS({
  "node_modules/reftools/lib/dereference.js"(exports, module) {
    "use strict";
    var recurse = require_recurse().recurse;
    var clone2 = require_clone().shallowClone;
    var jptr = require_jptr().jptr;
    var isRef = require_isref().isRef;
    var getLogger = function(options2) {
      if (options2 && options2.verbose) {
        return {
          warn: function() {
            var args = Array.prototype.slice.call(arguments);
            console.warn.apply(console, args);
          }
        };
      } else {
        return {
          warn: function() {
          }
        };
      }
    };
    function dereference(o, definitions, options2) {
      if (!options2) options2 = {};
      if (!options2.cache) options2.cache = {};
      if (!options2.state) options2.state = {};
      options2.state.identityDetection = true;
      options2.depth = options2.depth ? options2.depth + 1 : 1;
      let obj = options2.depth > 1 ? o : clone2(o);
      let container = { data: obj };
      let defs = options2.depth > 1 ? definitions : clone2(definitions);
      if (!options2.master) options2.master = obj;
      let logger = getLogger(options2);
      let changes = 1;
      while (changes > 0) {
        changes = 0;
        recurse(container, options2.state, function(obj2, key2, state) {
          if (isRef(obj2, key2)) {
            let $ref = obj2[key2];
            changes++;
            if (!options2.cache[$ref]) {
              let entry = {};
              entry.path = state.path.split("/$ref")[0];
              entry.key = $ref;
              logger.warn("Dereffing %s at %s", $ref, entry.path);
              entry.source = defs;
              entry.data = jptr(entry.source, entry.key);
              if (entry.data === false) {
                entry.data = jptr(options2.master, entry.key);
                entry.source = options2.master;
              }
              if (entry.data === false) {
                logger.warn("Missing $ref target", entry.key);
              }
              options2.cache[$ref] = entry;
              entry.data = state.parent[state.pkey] = dereference(jptr(entry.source, entry.key), entry.source, options2);
              if (options2.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[state.pkey][options2.$ref] = $ref;
              entry.resolved = true;
            } else {
              let entry = options2.cache[$ref];
              if (entry.resolved) {
                logger.warn("Patching %s for %s", $ref, entry.path);
                state.parent[state.pkey] = entry.data;
                if (options2.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[state.pkey][options2.$ref] = $ref;
              } else if ($ref === entry.path) {
                throw new Error(`Tight circle at ${entry.path}`);
              } else {
                logger.warn("Unresolved ref");
                state.parent[state.pkey] = jptr(entry.source, entry.path);
                if (state.parent[state.pkey] === false) {
                  state.parent[state.pkey] = jptr(entry.source, entry.key);
                }
                if (options2.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[options2.$ref] = $ref;
              }
            }
          }
        });
      }
      return container.data;
    }
    module.exports = {
      dereference
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options2) {
      if (typeof options2 === "undefined") {
        options2 = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options2);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace2, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace2 });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace2]);
        }
      } else {
        parent[k] = replace2;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options2) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options2);
          }
        } else {
          var keys2 = Object.keys(val);
          for (i = 0; i < keys2.length; i++) {
            var key2 = keys2[i];
            decirc(val[key2], key2, i, stack, val, depth, options2);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options2) {
      if (typeof options2 === "undefined") {
        options2 = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options2) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options2);
          }
        } else {
          var tmp = {};
          var keys2 = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys2.length; i++) {
            var key2 = keys2[i];
            deterministicDecirc(val[key2], key2, i, stack, val, depth, options2);
            tmp[key2] = val[key2];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key2, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key2 && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key2, val);
      };
    }
  }
});

// node_modules/oas-kit-common/index.js
var require_oas_kit_common = __commonJS({
  "node_modules/oas-kit-common/index.js"(exports, module) {
    "use strict";
    var sjs = require_fast_safe_stringify();
    var colour = process.env.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
    function uniqueOnly(value, index2, self2) {
      return self2.indexOf(value) === index2;
    }
    function hasDuplicates(array) {
      return new Set(array).size !== array.length;
    }
    function allSame(array) {
      return new Set(array).size <= 1;
    }
    function deepEquals(obj1, obj2) {
      function _equals(obj12, obj22) {
        return sjs.stringify(obj12) === sjs.stringify(Object.assign({}, obj12, obj22));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    }
    function compressArray(arr) {
      let result = [];
      for (let candidate of arr) {
        let dupe = result.find(function(e, i, a) {
          return deepEquals(e, candidate);
        });
        if (!dupe) result.push(candidate);
      }
      return result;
    }
    function distinctArray(arr) {
      return arr.length === compressArray(arr).length;
    }
    function firstDupe(arr) {
      return arr.find(function(e, i, a) {
        return arr.indexOf(e) < i;
      });
    }
    function hash(s) {
      let hash2 = 0;
      let chr;
      if (s.length === 0) return hash2;
      for (let i = 0; i < s.length; i++) {
        chr = s.charCodeAt(i);
        hash2 = (hash2 << 5) - hash2 + chr;
        hash2 |= 0;
      }
      return hash2;
    }
    String.prototype.toCamelCase = function camelize() {
      return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(match, group1) {
        return group1.toUpperCase();
      });
    };
    var parameterTypeProperties = [
      "format",
      "minimum",
      "maximum",
      "exclusiveMinimum",
      "exclusiveMaximum",
      "minLength",
      "maxLength",
      "multipleOf",
      "minItems",
      "maxItems",
      "uniqueItems",
      "minProperties",
      "maxProperties",
      "additionalProperties",
      "pattern",
      "enum",
      "default"
    ];
    var arrayProperties = [
      "items",
      "minItems",
      "maxItems",
      "uniqueItems"
    ];
    var httpMethods = [
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
      "trace"
    ];
    function sanitise(s) {
      s = s.replace("[]", "Array");
      let components = s.split("/");
      components[0] = components[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_");
      return components.join("/");
    }
    function sanitiseAll(s) {
      return sanitise(s.split("/").join("_"));
    }
    module.exports = {
      colour,
      uniqueOnly,
      hasDuplicates,
      allSame,
      distinctArray,
      firstDupe,
      hash,
      parameterTypeProperties,
      arrayProperties,
      httpMethods,
      sanitise,
      sanitiseAll
    };
  }
});

// node_modules/oas-resolver/index.js
var require_oas_resolver = __commonJS({
  "node_modules/oas-resolver/index.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var url = __require("url");
    var fetch2 = require_lib3();
    var yaml = require_yaml();
    var jptr = require_jptr().jptr;
    var recurse = require_recurse().recurse;
    var clone2 = require_clone().clone;
    var deRef = require_dereference().dereference;
    var isRef = require_isref().isRef;
    var common = require_oas_kit_common();
    function unique(arr) {
      return [...new Set(arr)];
    }
    function readFileAsync(filename, encoding, options2, pointer, def) {
      return new Promise(function(resolve2, reject) {
        fs.readFile(filename, encoding, function(err, data) {
          if (err) {
            if (options2.ignoreIOErrors && def) {
              if (options2.verbose) console.warn("FAILED", pointer);
              options2.externalRefs[pointer].failed = true;
              resolve2(def);
            } else {
              reject(err);
            }
          } else {
            resolve2(data);
          }
        });
      });
    }
    function resolveAllFragment(obj, context, src, parentPath, base2, options2) {
      let attachPoint = options2.externalRefs[src + parentPath].paths[0];
      let baseUrl = url.parse(base2);
      let seen = {};
      let changes = 1;
      while (changes) {
        changes = 0;
        recurse(obj, { identityDetection: true }, function(obj2, key2, state) {
          if (isRef(obj2, key2)) {
            if (obj2[key2].startsWith("#")) {
              if (!seen[obj2[key2]] && !obj2.$fixed) {
                let target = clone2(jptr(context, obj2[key2]));
                if (options2.verbose > 1) console.warn((target === false ? common.colour.red : common.colour.green) + "Fragment resolution", obj2[key2], common.colour.normal);
                if (target === false) {
                  state.parent[state.pkey] = {};
                  if (options2.fatal) {
                    let ex = new Error("Fragment $ref resolution failed " + obj2[key2]);
                    if (options2.promise) options2.promise.reject(ex);
                    else throw ex;
                  }
                } else {
                  changes++;
                  state.parent[state.pkey] = target;
                  seen[obj2[key2]] = state.path.replace("/%24ref", "");
                }
              } else {
                if (!obj2.$fixed) {
                  let newRef = (attachPoint + "/" + seen[obj2[key2]]).split("/#/").join("/");
                  state.parent[state.pkey] = { $ref: newRef, "x-miro": obj2[key2], $fixed: true };
                  if (options2.verbose > 1) console.warn("Replacing with", newRef);
                  changes++;
                }
              }
            } else if (baseUrl.protocol) {
              let newRef = url.resolve(base2, obj2[key2]).toString();
              if (options2.verbose > 1) console.warn(common.colour.yellow + "Rewriting external url ref", obj2[key2], "as", newRef, common.colour.normal);
              obj2["x-miro"] = obj2[key2];
              if (options2.externalRefs[obj2[key2]]) {
                if (!options2.externalRefs[newRef]) {
                  options2.externalRefs[newRef] = options2.externalRefs[obj2[key2]];
                }
                options2.externalRefs[newRef].failed = options2.externalRefs[obj2[key2]].failed;
              }
              obj2[key2] = newRef;
            } else if (!obj2["x-miro"]) {
              let newRef = url.resolve(base2, obj2[key2]).toString();
              let failed = false;
              if (options2.externalRefs[obj2[key2]]) {
                failed = options2.externalRefs[obj2[key2]].failed;
              }
              if (!failed) {
                if (options2.verbose > 1) console.warn(common.colour.yellow + "Rewriting external ref", obj2[key2], "as", newRef, common.colour.normal);
                obj2["x-miro"] = obj2[key2];
                obj2[key2] = newRef;
              }
            }
          }
        });
      }
      recurse(obj, {}, function(obj2, key2, state) {
        if (isRef(obj2, key2)) {
          if (typeof obj2.$fixed !== "undefined") delete obj2.$fixed;
        }
      });
      if (options2.verbose > 1) console.warn("Finished fragment resolution");
      return obj;
    }
    function filterData(data, options2) {
      if (!options2.filters || !options2.filters.length) return data;
      for (let filter of options2.filters) {
        data = filter(data, options2);
      }
      return data;
    }
    function testProtocol(input, backup) {
      if (input && input.length > 2) return input;
      if (backup && backup.length > 2) return backup;
      return "file:";
    }
    function resolveExternal(root, pointer, options2, callback) {
      var u = url.parse(options2.source);
      var base2 = options2.source.split("\\").join("/").split("/");
      let doc2 = base2.pop();
      if (!doc2) base2.pop();
      let fragment = "";
      let fnComponents = pointer.split("#");
      if (fnComponents.length > 1) {
        fragment = "#" + fnComponents[1];
        pointer = fnComponents[0];
      }
      base2 = base2.join("/");
      let u2 = url.parse(pointer);
      let effectiveProtocol = testProtocol(u2.protocol, u.protocol);
      let target;
      if (effectiveProtocol === "file:") {
        target = path.resolve(base2 ? base2 + "/" : "", pointer);
      } else {
        target = url.resolve(base2 ? base2 + "/" : "", pointer);
      }
      if (options2.cache[target]) {
        if (options2.verbose) console.warn("CACHED", target, fragment);
        let context = clone2(options2.cache[target]);
        let data = options2.externalRef = context;
        if (fragment) {
          data = jptr(data, fragment);
          if (data === false) {
            data = {};
            if (options2.fatal) {
              let ex = new Error("Cached $ref resolution failed " + target + fragment);
              if (options2.promise) options2.promise.reject(ex);
              else throw ex;
            }
          }
        }
        data = resolveAllFragment(data, context, pointer, fragment, target, options2);
        data = filterData(data, options2);
        callback(clone2(data), target, options2);
        return Promise.resolve(data);
      }
      if (options2.verbose) console.warn("GET", target, fragment);
      if (options2.handlers && options2.handlers[effectiveProtocol]) {
        return options2.handlers[effectiveProtocol](base2, pointer, fragment, options2).then(function(data) {
          options2.externalRef = data;
          data = filterData(data, options2);
          options2.cache[target] = data;
          callback(data, target, options2);
          return data;
        }).catch(function(ex) {
          if (options2.verbose) console.warn(ex);
          throw ex;
        });
      } else if (effectiveProtocol && effectiveProtocol.startsWith("http")) {
        const fetchOptions = Object.assign({}, options2.fetchOptions, { agent: options2.agent });
        return options2.fetch(target, fetchOptions).then(function(res) {
          if (res.status !== 200) {
            if (options2.ignoreIOErrors) {
              if (options2.verbose) console.warn("FAILED", pointer);
              options2.externalRefs[pointer].failed = true;
              return '{"$ref":"' + pointer + '"}';
            } else {
              throw new Error(`Received status code ${res.status}: ${target}`);
            }
          }
          return res.text();
        }).then(function(data) {
          try {
            let context = yaml.parse(data, { schema: "core", prettyErrors: true });
            data = options2.externalRef = context;
            options2.cache[target] = clone2(data);
            if (fragment) {
              data = jptr(data, fragment);
              if (data === false) {
                data = {};
                if (options2.fatal) {
                  let ex = new Error("Remote $ref resolution failed " + target + fragment);
                  if (options2.promise) options2.promise.reject(ex);
                  else throw ex;
                }
              }
            }
            data = resolveAllFragment(data, context, pointer, fragment, target, options2);
            data = filterData(data, options2);
          } catch (ex) {
            if (options2.verbose) console.warn(ex);
            if (options2.promise && options2.fatal) options2.promise.reject(ex);
            else throw ex;
          }
          callback(data, target, options2);
          return data;
        }).catch(function(err) {
          if (options2.verbose) console.warn(err);
          options2.cache[target] = {};
          if (options2.promise && options2.fatal) options2.promise.reject(err);
          else throw err;
        });
      } else {
        const def = '{"$ref":"' + pointer + '"}';
        return readFileAsync(target, options2.encoding || "utf8", options2, pointer, def).then(function(data) {
          try {
            let context = yaml.parse(data, { schema: "core", prettyErrors: true });
            data = options2.externalRef = context;
            options2.cache[target] = clone2(data);
            if (fragment) {
              data = jptr(data, fragment);
              if (data === false) {
                data = {};
                if (options2.fatal) {
                  let ex = new Error("File $ref resolution failed " + target + fragment);
                  if (options2.promise) options2.promise.reject(ex);
                  else throw ex;
                }
              }
            }
            data = resolveAllFragment(data, context, pointer, fragment, target, options2);
            data = filterData(data, options2);
          } catch (ex) {
            if (options2.verbose) console.warn(ex);
            if (options2.promise && options2.fatal) options2.promise.reject(ex);
            else throw ex;
          }
          callback(data, target, options2);
          return data;
        }).catch(function(err) {
          if (options2.verbose) console.warn(err);
          if (options2.promise && options2.fatal) options2.promise.reject(err);
          else throw err;
        });
      }
    }
    function scanExternalRefs(options2) {
      return new Promise(function(res, rej) {
        function inner(obj, key2, state) {
          if (obj[key2] && isRef(obj[key2], "$ref")) {
            let $ref = obj[key2].$ref;
            if (!$ref.startsWith("#")) {
              let $extra = "";
              if (!refs[$ref]) {
                let potential = Object.keys(refs).find(function(e, i, a) {
                  return $ref.startsWith(e + "/");
                });
                if (potential) {
                  if (options2.verbose) console.warn("Found potential subschema at", potential);
                  $extra = "/" + ($ref.split("#")[1] || "").replace(potential.split("#")[1] || "");
                  $extra = $extra.split("/undefined").join("");
                  $ref = potential;
                }
              }
              if (!refs[$ref]) {
                refs[$ref] = { resolved: false, paths: [], extras: {}, description: obj[key2].description };
              }
              if (refs[$ref].resolved) {
                if (refs[$ref].failed) {
                } else if (options2.rewriteRefs) {
                  let newRef = refs[$ref].resolvedAt;
                  if (options2.verbose > 1) console.warn("Rewriting ref", $ref, newRef);
                  obj[key2]["x-miro"] = $ref;
                  obj[key2].$ref = newRef + $extra;
                } else {
                  obj[key2] = clone2(refs[$ref].data);
                }
              } else {
                refs[$ref].paths.push(state.path);
                refs[$ref].extras[state.path] = $extra;
              }
            }
          }
        }
        let refs = options2.externalRefs;
        if (options2.resolver.depth > 0 && options2.source === options2.resolver.base) {
          return res(refs);
        }
        recurse(options2.openapi.definitions, { identityDetection: true, path: "#/definitions" }, inner);
        recurse(options2.openapi.components, { identityDetection: true, path: "#/components" }, inner);
        recurse(options2.openapi, { identityDetection: true }, inner);
        res(refs);
      });
    }
    function findExternalRefs(options2) {
      return new Promise(function(res, rej) {
        scanExternalRefs(options2).then(function(refs) {
          for (let ref in refs) {
            if (!refs[ref].resolved) {
              let depth = options2.resolver.depth;
              if (depth > 0) depth++;
              options2.resolver.actions[depth].push(function() {
                return resolveExternal(options2.openapi, ref, options2, function(data, source, options3) {
                  if (!refs[ref].resolved) {
                    let external = {};
                    external.context = refs[ref];
                    external.$ref = ref;
                    external.original = clone2(data);
                    external.updated = data;
                    external.source = source;
                    options3.externals.push(external);
                    refs[ref].resolved = true;
                  }
                  let localOptions = Object.assign({}, options3, {
                    source: "",
                    resolver: {
                      actions: options3.resolver.actions,
                      depth: options3.resolver.actions.length - 1,
                      base: options3.resolver.base
                    }
                  });
                  if (options3.patch && refs[ref].description && !data.description && typeof data === "object") {
                    data.description = refs[ref].description;
                  }
                  refs[ref].data = data;
                  let pointers = unique(refs[ref].paths);
                  pointers = pointers.sort(function(a, b) {
                    const aComp = a.startsWith("#/components/") || a.startsWith("#/definitions/");
                    const bComp = b.startsWith("#/components/") || b.startsWith("#/definitions/");
                    if (aComp && !bComp) return -1;
                    if (bComp && !aComp) return 1;
                    return 0;
                  });
                  for (let ptr of pointers) {
                    if (refs[ref].resolvedAt && ptr !== refs[ref].resolvedAt && ptr.indexOf("x-ms-examples/") < 0) {
                      if (options3.verbose > 1) console.warn("Creating pointer to data at", ptr);
                      jptr(options3.openapi, ptr, { $ref: refs[ref].resolvedAt + refs[ref].extras[ptr], "x-miro": ref + refs[ref].extras[ptr] });
                    } else {
                      if (refs[ref].resolvedAt) {
                        if (options3.verbose > 1) console.warn("Avoiding circular reference");
                      } else {
                        refs[ref].resolvedAt = ptr;
                        if (options3.verbose > 1) console.warn("Creating initial clone of data at", ptr);
                      }
                      let cdata = clone2(data);
                      jptr(options3.openapi, ptr, cdata);
                    }
                  }
                  if (options3.resolver.actions[localOptions.resolver.depth].length === 0) {
                    options3.resolver.actions[localOptions.resolver.depth].push(function() {
                      return findExternalRefs(localOptions);
                    });
                  }
                });
              });
            }
          }
        }).catch(function(ex) {
          if (options2.verbose) console.warn(ex);
          rej(ex);
        });
        let result = { options: options2 };
        result.actions = options2.resolver.actions[options2.resolver.depth];
        res(result);
      });
    }
    var serial = (funcs) => funcs.reduce((promise, func) => promise.then((result) => func().then(Array.prototype.concat.bind(result))), Promise.resolve([]));
    function loopReferences(options2, res, rej) {
      options2.resolver.actions.push([]);
      findExternalRefs(options2).then(function(data) {
        serial(data.actions).then(function() {
          if (options2.resolver.depth >= options2.resolver.actions.length) {
            console.warn("Ran off the end of resolver actions");
            return res(true);
          } else {
            options2.resolver.depth++;
            if (options2.resolver.actions[options2.resolver.depth].length) {
              setTimeout(function() {
                loopReferences(data.options, res, rej);
              }, 0);
            } else {
              if (options2.verbose > 1) console.warn(common.colour.yellow + "Finished external resolution!", common.colour.normal);
              if (options2.resolveInternal) {
                if (options2.verbose > 1) console.warn(common.colour.yellow + "Starting internal resolution!", common.colour.normal);
                options2.openapi = deRef(options2.openapi, options2.original, { verbose: options2.verbose - 1 });
                if (options2.verbose > 1) console.warn(common.colour.yellow + "Finished internal resolution!", common.colour.normal);
              }
              recurse(options2.openapi, {}, function(obj, key2, state) {
                if (isRef(obj, key2)) {
                  if (!options2.preserveMiro) delete obj["x-miro"];
                }
              });
              res(options2);
            }
          }
        }).catch(function(ex) {
          if (options2.verbose) console.warn(ex);
          rej(ex);
        });
      }).catch(function(ex) {
        if (options2.verbose) console.warn(ex);
        rej(ex);
      });
    }
    function setupOptions(options2) {
      if (!options2.cache) options2.cache = {};
      if (!options2.fetch) options2.fetch = fetch2;
      if (options2.source) {
        let srcUrl = url.parse(options2.source);
        if (!srcUrl.protocol || srcUrl.protocol.length <= 2) {
          options2.source = path.resolve(options2.source);
        }
      }
      options2.externals = [];
      options2.externalRefs = {};
      options2.rewriteRefs = true;
      options2.resolver = {};
      options2.resolver.depth = 0;
      options2.resolver.base = options2.source;
      options2.resolver.actions = [[]];
    }
    function optionalResolve(options2) {
      setupOptions(options2);
      return new Promise(function(res, rej) {
        if (options2.resolve)
          loopReferences(options2, res, rej);
        else
          res(options2);
      });
    }
    function resolve(openapi, source, options2) {
      if (!options2) options2 = {};
      options2.openapi = openapi;
      options2.source = source;
      options2.resolve = true;
      setupOptions(options2);
      return new Promise(function(res, rej) {
        loopReferences(options2, res, rej);
      });
    }
    module.exports = {
      optionalResolve,
      resolve
    };
  }
});

// node_modules/oas-schema-walker/index.js
var require_oas_schema_walker = __commonJS({
  "node_modules/oas-schema-walker/index.js"(exports, module) {
    "use strict";
    function getDefaultState() {
      return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: true, combine: false, allowRefSiblings: false };
    }
    function walkSchema(schema, parent, state, callback) {
      if (typeof state.depth === "undefined") state = getDefaultState();
      if (schema === null || typeof schema === "undefined") return schema;
      if (typeof schema.$ref !== "undefined") {
        let temp = { $ref: schema.$ref };
        if (state.allowRefSiblings && schema.description) {
          temp.description = schema.description;
        }
        callback(temp, parent, state);
        return temp;
      }
      if (state.combine) {
        if (schema.allOf && Array.isArray(schema.allOf) && schema.allOf.length === 1) {
          schema = Object.assign({}, schema.allOf[0], schema);
          delete schema.allOf;
        }
        if (schema.anyOf && Array.isArray(schema.anyOf) && schema.anyOf.length === 1) {
          schema = Object.assign({}, schema.anyOf[0], schema);
          delete schema.anyOf;
        }
        if (schema.oneOf && Array.isArray(schema.oneOf) && schema.oneOf.length === 1) {
          schema = Object.assign({}, schema.oneOf[0], schema);
          delete schema.oneOf;
        }
      }
      callback(schema, parent, state);
      if (state.seen.has(schema)) {
        return schema;
      }
      if (typeof schema === "object" && schema !== null) state.seen.set(schema, true);
      state.top = false;
      state.depth++;
      if (typeof schema.items !== "undefined") {
        state.property = "items";
        walkSchema(schema.items, schema, state, callback);
      }
      if (schema.additionalItems) {
        if (typeof schema.additionalItems === "object") {
          state.property = "additionalItems";
          walkSchema(schema.additionalItems, schema, state, callback);
        }
      }
      if (schema.additionalProperties) {
        if (typeof schema.additionalProperties === "object") {
          state.property = "additionalProperties";
          walkSchema(schema.additionalProperties, schema, state, callback);
        }
      }
      if (schema.properties) {
        for (let prop in schema.properties) {
          let subSchema = schema.properties[prop];
          state.property = "properties/" + prop;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.patternProperties) {
        for (let prop in schema.patternProperties) {
          let subSchema = schema.patternProperties[prop];
          state.property = "patternProperties/" + prop;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.allOf) {
        for (let index2 in schema.allOf) {
          let subSchema = schema.allOf[index2];
          state.property = "allOf/" + index2;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.anyOf) {
        for (let index2 in schema.anyOf) {
          let subSchema = schema.anyOf[index2];
          state.property = "anyOf/" + index2;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.oneOf) {
        for (let index2 in schema.oneOf) {
          let subSchema = schema.oneOf[index2];
          state.property = "oneOf/" + index2;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.not) {
        state.property = "not";
        walkSchema(schema.not, schema, state, callback);
      }
      state.depth--;
      return schema;
    }
    module.exports = {
      getDefaultState,
      walkSchema
    };
  }
});

// node_modules/swagger2openapi/lib/statusCodes.js
var require_statusCodes = __commonJS({
  "node_modules/swagger2openapi/lib/statusCodes.js"(exports, module) {
    "use strict";
    var http = __require("http");
    var ours = {
      "default": "Default response",
      "1XX": "Informational",
      "103": "Early hints",
      // not in Node < 10
      "2XX": "Successful",
      "3XX": "Redirection",
      "4XX": "Client Error",
      "5XX": "Server Error",
      "7XX": "Developer Error"
      // April fools RFC
    };
    module.exports = {
      statusCodes: Object.assign({}, ours, http.STATUS_CODES)
    };
  }
});

// node_modules/swagger2openapi/package.json
var require_package = __commonJS({
  "node_modules/swagger2openapi/package.json"(exports, module) {
    module.exports = {
      name: "swagger2openapi",
      version: "7.0.8",
      description: "Convert Swagger 2.0 definitions to OpenApi 3.0 and validate",
      main: "index.js",
      bin: {
        swagger2openapi: "./swagger2openapi.js",
        "oas-validate": "./oas-validate.js",
        boast: "./boast.js"
      },
      funding: "https://github.com/Mermade/oas-kit?sponsor=1",
      scripts: {
        test: "mocha"
      },
      browserify: {
        transform: [
          [
            "babelify",
            {
              presets: [
                "es2015"
              ]
            }
          ]
        ]
      },
      repository: {
        url: "https://github.com/Mermade/oas-kit.git",
        type: "git"
      },
      bugs: {
        url: "https://github.com/mermade/oas-kit/issues"
      },
      author: "Mike Ralphson <mike.ralphson@gmail.com>",
      license: "BSD-3-Clause",
      dependencies: {
        "call-me-maybe": "^1.0.1",
        "node-fetch": "^2.6.1",
        "node-fetch-h2": "^2.3.0",
        "node-readfiles": "^0.2.0",
        "oas-kit-common": "^1.0.8",
        "oas-resolver": "^2.5.6",
        "oas-schema-walker": "^1.1.5",
        "oas-validator": "^5.0.8",
        reftools: "^1.1.9",
        yaml: "^1.10.0",
        yargs: "^17.0.1"
      },
      keywords: [
        "swagger",
        "openapi",
        "openapi2",
        "openapi3",
        "converter",
        "conversion",
        "validator",
        "validation",
        "resolver",
        "lint",
        "linter"
      ],
      gitHead: "b1bba3fc5007e96a991bf2a015cf0534ac36b88b"
    };
  }
});

// node_modules/swagger2openapi/index.js
var require_swagger2openapi = __commonJS({
  "node_modules/swagger2openapi/index.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var url = __require("url");
    var pathlib = __require("path");
    var maybe = require_maybe();
    var fetch2 = require_lib3();
    var yaml = require_yaml();
    var jptr = require_jptr();
    var resolveInternal = jptr.jptr;
    var isRef = require_isref().isRef;
    var clone2 = require_clone().clone;
    var cclone = require_clone().circularClone;
    var recurse = require_recurse().recurse;
    var resolver = require_oas_resolver();
    var sw = require_oas_schema_walker();
    var common = require_oas_kit_common();
    var statusCodes = require_statusCodes().statusCodes;
    var ourVersion = require_package().version;
    var targetVersion = "3.0.0";
    var componentNames;
    var S2OError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "S2OError";
      }
    };
    function throwError(message, options2) {
      let err = new S2OError(message);
      err.options = options2;
      if (options2.promise) {
        options2.promise.reject(err);
      } else {
        throw err;
      }
    }
    function throwOrWarn(message, container, options2) {
      if (options2.warnOnly) {
        container[options2.warnProperty || "x-s2o-warning"] = message;
      } else {
        throwError(message, options2);
      }
    }
    function fixUpSubSchema(schema, parent, options2) {
      if (schema.nullable) options2.patches++;
      if (schema.discriminator && typeof schema.discriminator === "string") {
        schema.discriminator = { propertyName: schema.discriminator };
      }
      if (schema.items && Array.isArray(schema.items)) {
        if (schema.items.length === 0) {
          schema.items = {};
        } else if (schema.items.length === 1) {
          schema.items = schema.items[0];
        } else schema.items = { anyOf: schema.items };
      }
      if (schema.type && Array.isArray(schema.type)) {
        if (options2.patch) {
          options2.patches++;
          if (schema.type.length === 0) {
            delete schema.type;
          } else {
            if (!schema.oneOf) schema.oneOf = [];
            for (let type of schema.type) {
              let newSchema = {};
              if (type === "null") {
                schema.nullable = true;
              } else {
                newSchema.type = type;
                for (let prop of common.arrayProperties) {
                  if (typeof schema.prop !== "undefined") {
                    newSchema[prop] = schema[prop];
                    delete schema[prop];
                  }
                }
              }
              if (newSchema.type) {
                schema.oneOf.push(newSchema);
              }
            }
            delete schema.type;
            if (schema.oneOf.length === 0) {
              delete schema.oneOf;
            } else if (schema.oneOf.length < 2) {
              schema.type = schema.oneOf[0].type;
              if (Object.keys(schema.oneOf[0]).length > 1) {
                throwOrWarn("Lost properties from oneOf", schema, options2);
              }
              delete schema.oneOf;
            }
          }
          if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
            schema.type = schema.type[0];
          }
        } else {
          throwError("(Patchable) schema type must not be an array", options2);
        }
      }
      if (schema.type && schema.type === "null") {
        delete schema.type;
        schema.nullable = true;
      }
      if (schema.type === "array" && !schema.items) {
        schema.items = {};
      }
      if (schema.type === "file") {
        schema.type = "string";
        schema.format = "binary";
      }
      if (typeof schema.required === "boolean") {
        if (schema.required && schema.name) {
          if (typeof parent.required === "undefined") {
            parent.required = [];
          }
          if (Array.isArray(parent.required)) parent.required.push(schema.name);
        }
        delete schema.required;
      }
      if (schema.xml && typeof schema.xml.namespace === "string") {
        if (!schema.xml.namespace) delete schema.xml.namespace;
      }
      if (typeof schema.allowEmptyValue !== "undefined") {
        options2.patches++;
        delete schema.allowEmptyValue;
      }
    }
    function fixUpSubSchemaExtensions(schema, parent) {
      if (schema["x-required"] && Array.isArray(schema["x-required"])) {
        if (!schema.required) schema.required = [];
        schema.required = schema.required.concat(schema["x-required"]);
        delete schema["x-required"];
      }
      if (schema["x-anyOf"]) {
        schema.anyOf = schema["x-anyOf"];
        delete schema["x-anyOf"];
      }
      if (schema["x-oneOf"]) {
        schema.oneOf = schema["x-oneOf"];
        delete schema["x-oneOf"];
      }
      if (schema["x-not"]) {
        schema.not = schema["x-not"];
        delete schema["x-not"];
      }
      if (typeof schema["x-nullable"] === "boolean") {
        schema.nullable = schema["x-nullable"];
        delete schema["x-nullable"];
      }
      if (typeof schema["x-discriminator"] === "object" && typeof schema["x-discriminator"].propertyName === "string") {
        schema.discriminator = schema["x-discriminator"];
        delete schema["x-discriminator"];
        for (let entry in schema.discriminator.mapping) {
          let schemaOrRef = schema.discriminator.mapping[entry];
          if (schemaOrRef.startsWith("#/definitions/")) {
            schema.discriminator.mapping[entry] = schemaOrRef.replace("#/definitions/", "#/components/schemas/");
          }
        }
      }
    }
    function fixUpSchema(schema, options2) {
      sw.walkSchema(schema, {}, {}, function(schema2, parent, state) {
        fixUpSubSchemaExtensions(schema2, parent);
        fixUpSubSchema(schema2, parent, options2);
      });
    }
    function getMiroComponentName(ref) {
      if (ref.indexOf("#") >= 0) {
        ref = ref.split("#")[1].split("/").pop();
      } else {
        ref = ref.split("/").pop().split(".")[0];
      }
      return encodeURIComponent(common.sanitise(ref));
    }
    function fixupRefs(obj, key2, state) {
      let options2 = state.payload.options;
      if (isRef(obj, key2)) {
        if (obj[key2].startsWith("#/components/")) {
        } else if (obj[key2] === "#/consumes") {
          delete obj[key2];
          state.parent[state.pkey] = clone2(options2.openapi.consumes);
        } else if (obj[key2] === "#/produces") {
          delete obj[key2];
          state.parent[state.pkey] = clone2(options2.openapi.produces);
        } else if (obj[key2].startsWith("#/definitions/")) {
          let keys2 = obj[key2].replace("#/definitions/", "").split("/");
          const ref = jptr.jpunescape(keys2[0]);
          let newKey = componentNames.schemas[decodeURIComponent(ref)];
          if (newKey) {
            keys2[0] = newKey;
          } else {
            throwOrWarn("Could not resolve reference " + obj[key2], obj, options2);
          }
          obj[key2] = "#/components/schemas/" + keys2.join("/");
        } else if (obj[key2].startsWith("#/parameters/")) {
          obj[key2] = "#/components/parameters/" + common.sanitise(obj[key2].replace("#/parameters/", ""));
        } else if (obj[key2].startsWith("#/responses/")) {
          obj[key2] = "#/components/responses/" + common.sanitise(obj[key2].replace("#/responses/", ""));
        } else if (obj[key2].startsWith("#")) {
          let target = clone2(jptr.jptr(options2.openapi, obj[key2]));
          if (target === false) throwOrWarn("direct $ref not found " + obj[key2], obj, options2);
          else if (options2.refmap[obj[key2]]) {
            obj[key2] = options2.refmap[obj[key2]];
          } else {
            let oldRef = obj[key2];
            oldRef = oldRef.replace("/properties/headers/", "");
            oldRef = oldRef.replace("/properties/responses/", "");
            oldRef = oldRef.replace("/properties/parameters/", "");
            oldRef = oldRef.replace("/properties/schemas/", "");
            let type = "schemas";
            let schemaIndex = oldRef.lastIndexOf("/schema");
            type = oldRef.indexOf("/headers/") > schemaIndex ? "headers" : oldRef.indexOf("/responses/") > schemaIndex ? "responses" : oldRef.indexOf("/example") > schemaIndex ? "examples" : oldRef.indexOf("/x-") > schemaIndex ? "extensions" : oldRef.indexOf("/parameters/") > schemaIndex ? "parameters" : "schemas";
            if (type === "schemas") {
              fixUpSchema(target, options2);
            }
            if (type !== "responses" && type !== "extensions") {
              let prefix = type.substr(0, type.length - 1);
              if (prefix === "parameter" && target.name && target.name === common.sanitise(target.name)) {
                prefix = encodeURIComponent(target.name);
              }
              let suffix = 1;
              if (obj["x-miro"]) {
                prefix = getMiroComponentName(obj["x-miro"]);
                suffix = "";
              }
              while (jptr.jptr(options2.openapi, "#/components/" + type + "/" + prefix + suffix)) {
                suffix = suffix === "" ? 2 : ++suffix;
              }
              let newRef = "#/components/" + type + "/" + prefix + suffix;
              let refSuffix = "";
              if (type === "examples") {
                target = { value: target };
                refSuffix = "/value";
              }
              jptr.jptr(options2.openapi, newRef, target);
              options2.refmap[obj[key2]] = newRef + refSuffix;
              obj[key2] = newRef + refSuffix;
            }
          }
        }
        delete obj["x-miro"];
        if (Object.keys(obj).length > 1) {
          const tmpRef = obj[key2];
          const inSchema = state.path.indexOf("/schema") >= 0;
          if (options2.refSiblings === "preserve") {
          } else if (inSchema && options2.refSiblings === "allOf") {
            delete obj.$ref;
            state.parent[state.pkey] = { allOf: [{ $ref: tmpRef }, obj] };
          } else {
            state.parent[state.pkey] = { $ref: tmpRef };
          }
        }
      }
      if (key2 === "x-ms-odata" && typeof obj[key2] === "string" && obj[key2].startsWith("#/")) {
        let keys2 = obj[key2].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/");
        let newKey = componentNames.schemas[decodeURIComponent(keys2[0])];
        if (newKey) {
          keys2[0] = newKey;
        } else {
          throwOrWarn("Could not resolve reference " + obj[key2], obj, options2);
        }
        obj[key2] = "#/components/schemas/" + keys2.join("/");
      }
    }
    function dedupeRefs(openapi, options2) {
      for (let ref in options2.refmap) {
        jptr.jptr(openapi, ref, { $ref: options2.refmap[ref] });
      }
    }
    function processSecurity(securityObject) {
      for (let s in securityObject) {
        for (let k in securityObject[s]) {
          let sname = common.sanitise(k);
          if (k !== sname) {
            securityObject[s][sname] = securityObject[s][k];
            delete securityObject[s][k];
          }
        }
      }
    }
    function processSecurityScheme(scheme, options2) {
      if (scheme.type === "basic") {
        scheme.type = "http";
        scheme.scheme = "basic";
      }
      if (scheme.type === "oauth2") {
        let flow = {};
        let flowName = scheme.flow;
        if (scheme.flow === "application") flowName = "clientCredentials";
        if (scheme.flow === "accessCode") flowName = "authorizationCode";
        if (typeof scheme.authorizationUrl !== "undefined") flow.authorizationUrl = scheme.authorizationUrl.split("?")[0].trim() || "/";
        if (typeof scheme.tokenUrl === "string") flow.tokenUrl = scheme.tokenUrl.split("?")[0].trim() || "/";
        flow.scopes = scheme.scopes || {};
        scheme.flows = {};
        scheme.flows[flowName] = flow;
        delete scheme.flow;
        delete scheme.authorizationUrl;
        delete scheme.tokenUrl;
        delete scheme.scopes;
        if (typeof scheme.name !== "undefined") {
          if (options2.patch) {
            options2.patches++;
            delete scheme.name;
          } else {
            throwError("(Patchable) oauth2 securitySchemes should not have name property", options2);
          }
        }
      }
    }
    function keepParameters(value) {
      return value && !value["x-s2o-delete"];
    }
    function processHeader(header, options2) {
      if (header.$ref) {
        header.$ref = header.$ref.replace("#/responses/", "#/components/responses/");
      } else {
        if (header.type && !header.schema) {
          header.schema = {};
        }
        if (header.type) header.schema.type = header.type;
        if (header.items && header.items.type !== "array") {
          if (header.items.collectionFormat !== header.collectionFormat) {
            throwOrWarn("Nested collectionFormats are not supported", header, options2);
          }
          delete header.items.collectionFormat;
        }
        if (header.type === "array") {
          if (header.collectionFormat === "ssv") {
            throwOrWarn("collectionFormat:ssv is no longer supported for headers", header, options2);
          } else if (header.collectionFormat === "pipes") {
            throwOrWarn("collectionFormat:pipes is no longer supported for headers", header, options2);
          } else if (header.collectionFormat === "multi") {
            header.explode = true;
          } else if (header.collectionFormat === "tsv") {
            throwOrWarn("collectionFormat:tsv is no longer supported", header, options2);
            header["x-collectionFormat"] = "tsv";
          } else {
            header.style = "simple";
          }
          delete header.collectionFormat;
        } else if (header.collectionFormat) {
          if (options2.patch) {
            options2.patches++;
            delete header.collectionFormat;
          } else {
            throwError("(Patchable) collectionFormat is only applicable to header.type array", options2);
          }
        }
        delete header.type;
        for (let prop of common.parameterTypeProperties) {
          if (typeof header[prop] !== "undefined") {
            header.schema[prop] = header[prop];
            delete header[prop];
          }
        }
        for (let prop of common.arrayProperties) {
          if (typeof header[prop] !== "undefined") {
            header.schema[prop] = header[prop];
            delete header[prop];
          }
        }
      }
    }
    function fixParamRef(param, options2) {
      if (param.$ref.indexOf("#/parameters/") >= 0) {
        let refComponents = param.$ref.split("#/parameters/");
        param.$ref = refComponents[0] + "#/components/parameters/" + common.sanitise(refComponents[1]);
      }
      if (param.$ref.indexOf("#/definitions/") >= 0) {
        throwOrWarn("Definition used as parameter", param, options2);
      }
    }
    function attachRequestBody(op, options2) {
      let newOp = {};
      for (let key2 of Object.keys(op)) {
        newOp[key2] = op[key2];
        if (key2 === "parameters") {
          newOp.requestBody = {};
          if (options2.rbname) newOp[options2.rbname] = "";
        }
      }
      newOp.requestBody = {};
      return newOp;
    }
    function processParameter(param, op, path, method, index2, openapi, options2) {
      let result = {};
      let singularRequestBody = true;
      let originalType;
      if (op && op.consumes && typeof op.consumes === "string") {
        if (options2.patch) {
          options2.patches++;
          op.consumes = [op.consumes];
        } else {
          return throwError("(Patchable) operation.consumes must be an array", options2);
        }
      }
      if (!Array.isArray(openapi.consumes)) delete openapi.consumes;
      let consumes = ((op ? op.consumes : null) || (openapi.consumes || [])).filter(common.uniqueOnly);
      if (param && param.$ref && typeof param.$ref === "string") {
        fixParamRef(param, options2);
        let ptr = decodeURIComponent(param.$ref.replace("#/components/parameters/", ""));
        let rbody = false;
        let target = openapi.components.parameters[ptr];
        if ((!target || target["x-s2o-delete"]) && param.$ref.startsWith("#/")) {
          param["x-s2o-delete"] = true;
          rbody = true;
        }
        if (rbody) {
          let ref = param.$ref;
          let newParam = resolveInternal(openapi, param.$ref);
          if (!newParam && ref.startsWith("#/")) {
            throwOrWarn("Could not resolve reference " + ref, param, options2);
          } else {
            if (newParam) param = newParam;
          }
        }
      }
      if (param && (param.name || param.in)) {
        if (typeof param["x-deprecated"] === "boolean") {
          param.deprecated = param["x-deprecated"];
          delete param["x-deprecated"];
        }
        if (typeof param["x-example"] !== "undefined") {
          param.example = param["x-example"];
          delete param["x-example"];
        }
        if (param.in !== "body" && !param.type) {
          if (options2.patch) {
            options2.patches++;
            param.type = "string";
          } else {
            throwError("(Patchable) parameter.type is mandatory for non-body parameters", options2);
          }
        }
        if (param.type && typeof param.type === "object" && param.type.$ref) {
          param.type = resolveInternal(openapi, param.type.$ref);
        }
        if (param.type === "file") {
          param["x-s2o-originalType"] = param.type;
          originalType = param.type;
        }
        if (param.description && typeof param.description === "object" && param.description.$ref) {
          param.description = resolveInternal(openapi, param.description.$ref);
        }
        if (param.description === null) delete param.description;
        let oldCollectionFormat = param.collectionFormat;
        if (param.type === "array" && !oldCollectionFormat) {
          oldCollectionFormat = "csv";
        }
        if (oldCollectionFormat) {
          if (param.type !== "array") {
            if (options2.patch) {
              options2.patches++;
              delete param.collectionFormat;
            } else {
              throwError("(Patchable) collectionFormat is only applicable to param.type array", options2);
            }
          }
          if (oldCollectionFormat === "csv" && (param.in === "query" || param.in === "cookie")) {
            param.style = "form";
            param.explode = false;
          }
          if (oldCollectionFormat === "csv" && (param.in === "path" || param.in === "header")) {
            param.style = "simple";
          }
          if (oldCollectionFormat === "ssv") {
            if (param.in === "query") {
              param.style = "spaceDelimited";
            } else {
              throwOrWarn("collectionFormat:ssv is no longer supported except for in:query parameters", param, options2);
            }
          }
          if (oldCollectionFormat === "pipes") {
            if (param.in === "query") {
              param.style = "pipeDelimited";
            } else {
              throwOrWarn("collectionFormat:pipes is no longer supported except for in:query parameters", param, options2);
            }
          }
          if (oldCollectionFormat === "multi") {
            param.explode = true;
          }
          if (oldCollectionFormat === "tsv") {
            throwOrWarn("collectionFormat:tsv is no longer supported", param, options2);
            param["x-collectionFormat"] = "tsv";
          }
          delete param.collectionFormat;
        }
        if (param.type && param.type !== "body" && param.in !== "formData") {
          if (param.items && param.schema) {
            throwOrWarn("parameter has array,items and schema", param, options2);
          } else {
            if (param.schema) options2.patches++;
            if (!param.schema || typeof param.schema !== "object") param.schema = {};
            param.schema.type = param.type;
            if (param.items) {
              param.schema.items = param.items;
              delete param.items;
              recurse(param.schema.items, null, function(obj, key2, state) {
                if (key2 === "collectionFormat" && typeof obj[key2] === "string") {
                  if (oldCollectionFormat && obj[key2] !== oldCollectionFormat) {
                    throwOrWarn("Nested collectionFormats are not supported", param, options2);
                  }
                  delete obj[key2];
                }
              });
            }
            for (let prop of common.parameterTypeProperties) {
              if (typeof param[prop] !== "undefined") param.schema[prop] = param[prop];
              delete param[prop];
            }
          }
        }
        if (param.schema) {
          fixUpSchema(param.schema, options2);
        }
        if (param["x-ms-skip-url-encoding"]) {
          if (param.in === "query") {
            param.allowReserved = true;
            delete param["x-ms-skip-url-encoding"];
          }
        }
      }
      if (param && param.in === "formData") {
        singularRequestBody = false;
        result.content = {};
        let contentType = "application/x-www-form-urlencoded";
        if (consumes.length && consumes.indexOf("multipart/form-data") >= 0) {
          contentType = "multipart/form-data";
        }
        result.content[contentType] = {};
        if (param.schema) {
          result.content[contentType].schema = param.schema;
          if (param.schema.$ref) {
            result["x-s2o-name"] = decodeURIComponent(param.schema.$ref.replace("#/components/schemas/", ""));
          }
        } else {
          result.content[contentType].schema = {};
          result.content[contentType].schema.type = "object";
          result.content[contentType].schema.properties = {};
          result.content[contentType].schema.properties[param.name] = {};
          let schema = result.content[contentType].schema;
          let target = result.content[contentType].schema.properties[param.name];
          if (param.description) target.description = param.description;
          if (param.example) target.example = param.example;
          if (param.type) target.type = param.type;
          for (let prop of common.parameterTypeProperties) {
            if (typeof param[prop] !== "undefined") target[prop] = param[prop];
          }
          if (param.required === true) {
            if (!schema.required) schema.required = [];
            schema.required.push(param.name);
            result.required = true;
          }
          if (typeof param.default !== "undefined") target.default = param.default;
          if (target.properties) target.properties = param.properties;
          if (param.allOf) target.allOf = param.allOf;
          if (param.type === "array" && param.items) {
            target.items = param.items;
            if (target.items.collectionFormat) delete target.items.collectionFormat;
          }
          if (originalType === "file" || param["x-s2o-originalType"] === "file") {
            target.type = "string";
            target.format = "binary";
          }
          copyExtensions(param, target);
        }
      } else if (param && param.type === "file") {
        if (param.required) result.required = param.required;
        result.content = {};
        result.content["application/octet-stream"] = {};
        result.content["application/octet-stream"].schema = {};
        result.content["application/octet-stream"].schema.type = "string";
        result.content["application/octet-stream"].schema.format = "binary";
        copyExtensions(param, result);
      }
      if (param && param.in === "body") {
        result.content = {};
        if (param.name) result["x-s2o-name"] = (op && op.operationId ? common.sanitiseAll(op.operationId) : "") + ("_" + param.name).toCamelCase();
        if (param.description) result.description = param.description;
        if (param.required) result.required = param.required;
        if (op && options2.rbname && param.name) {
          op[options2.rbname] = param.name;
        }
        if (param.schema && param.schema.$ref) {
          result["x-s2o-name"] = decodeURIComponent(param.schema.$ref.replace("#/components/schemas/", ""));
        } else if (param.schema && param.schema.type === "array" && param.schema.items && param.schema.items.$ref) {
          result["x-s2o-name"] = decodeURIComponent(param.schema.items.$ref.replace("#/components/schemas/", "")) + "Array";
        }
        if (!consumes.length) {
          consumes.push("application/json");
        }
        for (let mimetype of consumes) {
          result.content[mimetype] = {};
          result.content[mimetype].schema = clone2(param.schema || {});
          fixUpSchema(result.content[mimetype].schema, options2);
        }
        copyExtensions(param, result);
      }
      if (Object.keys(result).length > 0) {
        param["x-s2o-delete"] = true;
        if (op) {
          if (op.requestBody && singularRequestBody) {
            op.requestBody["x-s2o-overloaded"] = true;
            let opId = op.operationId || index2;
            throwOrWarn("Operation " + opId + " has multiple requestBodies", op, options2);
          } else {
            if (!op.requestBody) {
              op = path[method] = attachRequestBody(op, options2);
            }
            if (op.requestBody.content && op.requestBody.content["multipart/form-data"] && op.requestBody.content["multipart/form-data"].schema && op.requestBody.content["multipart/form-data"].schema.properties && result.content["multipart/form-data"] && result.content["multipart/form-data"].schema && result.content["multipart/form-data"].schema.properties) {
              op.requestBody.content["multipart/form-data"].schema.properties = Object.assign(op.requestBody.content["multipart/form-data"].schema.properties, result.content["multipart/form-data"].schema.properties);
              op.requestBody.content["multipart/form-data"].schema.required = (op.requestBody.content["multipart/form-data"].schema.required || []).concat(result.content["multipart/form-data"].schema.required || []);
              if (!op.requestBody.content["multipart/form-data"].schema.required.length) {
                delete op.requestBody.content["multipart/form-data"].schema.required;
              }
            } else if (op.requestBody.content && op.requestBody.content["application/x-www-form-urlencoded"] && op.requestBody.content["application/x-www-form-urlencoded"].schema && op.requestBody.content["application/x-www-form-urlencoded"].schema.properties && result.content["application/x-www-form-urlencoded"] && result.content["application/x-www-form-urlencoded"].schema && result.content["application/x-www-form-urlencoded"].schema.properties) {
              op.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(op.requestBody.content["application/x-www-form-urlencoded"].schema.properties, result.content["application/x-www-form-urlencoded"].schema.properties);
              op.requestBody.content["application/x-www-form-urlencoded"].schema.required = (op.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(result.content["application/x-www-form-urlencoded"].schema.required || []);
              if (!op.requestBody.content["application/x-www-form-urlencoded"].schema.required.length) {
                delete op.requestBody.content["application/x-www-form-urlencoded"].schema.required;
              }
            } else {
              op.requestBody = Object.assign(op.requestBody, result);
              if (!op.requestBody["x-s2o-name"]) {
                if (op.requestBody.schema && op.requestBody.schema.$ref) {
                  op.requestBody["x-s2o-name"] = decodeURIComponent(op.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("");
                } else if (op.operationId) {
                  op.requestBody["x-s2o-name"] = common.sanitiseAll(op.operationId);
                }
              }
            }
          }
        }
      }
      if (param && !param["x-s2o-delete"]) {
        delete param.type;
        for (let prop of common.parameterTypeProperties) {
          delete param[prop];
        }
        if (param.in === "path" && (typeof param.required === "undefined" || param.required !== true)) {
          if (options2.patch) {
            options2.patches++;
            param.required = true;
          } else {
            throwError("(Patchable) path parameters must be required:true [" + param.name + " in " + index2 + "]", options2);
          }
        }
      }
      return op;
    }
    function copyExtensions(src, tgt) {
      for (let prop in src) {
        if (prop.startsWith("x-") && !prop.startsWith("x-s2o")) {
          tgt[prop] = src[prop];
        }
      }
    }
    function processResponse(response, name2, op, openapi, options2) {
      if (!response) return false;
      if (response.$ref && typeof response.$ref === "string") {
        if (response.$ref.indexOf("#/definitions/") >= 0) {
          throwOrWarn("definition used as response: " + response.$ref, response, options2);
        } else {
          if (response.$ref.startsWith("#/responses/")) {
            response.$ref = "#/components/responses/" + common.sanitise(decodeURIComponent(response.$ref.replace("#/responses/", "")));
          }
        }
      } else {
        if (typeof response.description === "undefined" || response.description === null || response.description === "" && options2.patch) {
          if (options2.patch) {
            if (typeof response === "object" && !Array.isArray(response)) {
              options2.patches++;
              response.description = statusCodes[response] || "";
            }
          } else {
            throwError("(Patchable) response.description is mandatory", options2);
          }
        }
        if (typeof response.schema !== "undefined") {
          fixUpSchema(response.schema, options2);
          if (response.schema.$ref && typeof response.schema.$ref === "string" && response.schema.$ref.startsWith("#/responses/")) {
            response.schema.$ref = "#/components/responses/" + common.sanitise(decodeURIComponent(response.schema.$ref.replace("#/responses/", "")));
          }
          if (op && op.produces && typeof op.produces === "string") {
            if (options2.patch) {
              options2.patches++;
              op.produces = [op.produces];
            } else {
              return throwError("(Patchable) operation.produces must be an array", options2);
            }
          }
          if (openapi.produces && !Array.isArray(openapi.produces)) delete openapi.produces;
          let produces = ((op ? op.produces : null) || (openapi.produces || [])).filter(common.uniqueOnly);
          if (!produces.length) produces.push("*/*");
          response.content = {};
          for (let mimetype of produces) {
            response.content[mimetype] = {};
            response.content[mimetype].schema = clone2(response.schema);
            if (response.examples && response.examples[mimetype]) {
              let example = {};
              example.value = response.examples[mimetype];
              response.content[mimetype].examples = {};
              response.content[mimetype].examples.response = example;
              delete response.examples[mimetype];
            }
            if (response.content[mimetype].schema.type === "file") {
              response.content[mimetype].schema = { type: "string", format: "binary" };
            }
          }
          delete response.schema;
        }
        for (let mimetype in response.examples) {
          if (!response.content) response.content = {};
          if (!response.content[mimetype]) response.content[mimetype] = {};
          response.content[mimetype].examples = {};
          response.content[mimetype].examples.response = {};
          response.content[mimetype].examples.response.value = response.examples[mimetype];
        }
        delete response.examples;
        if (response.headers) {
          for (let h in response.headers) {
            if (h.toLowerCase() === "status code") {
              if (options2.patch) {
                options2.patches++;
                delete response.headers[h];
              } else {
                throwError('(Patchable) "Status Code" is not a valid header', options2);
              }
            } else {
              processHeader(response.headers[h], options2);
            }
          }
        }
      }
    }
    function processPaths(container, containerName, options2, requestBodyCache, openapi) {
      for (let p in container) {
        let path = container[p];
        if (path && path["x-trace"] && typeof path["x-trace"] === "object") {
          path.trace = path["x-trace"];
          delete path["x-trace"];
        }
        if (path && path["x-summary"] && typeof path["x-summary"] === "string") {
          path.summary = path["x-summary"];
          delete path["x-summary"];
        }
        if (path && path["x-description"] && typeof path["x-description"] === "string") {
          path.description = path["x-description"];
          delete path["x-description"];
        }
        if (path && path["x-servers"] && Array.isArray(path["x-servers"])) {
          path.servers = path["x-servers"];
          delete path["x-servers"];
        }
        for (let method in path) {
          if (common.httpMethods.indexOf(method) >= 0 || method === "x-amazon-apigateway-any-method") {
            let op = path[method];
            if (op && op.parameters && Array.isArray(op.parameters)) {
              if (path.parameters) {
                for (let param of path.parameters) {
                  if (typeof param.$ref === "string") {
                    fixParamRef(param, options2);
                    param = resolveInternal(openapi, param.$ref);
                  }
                  let match = op.parameters.find(function(e, i, a) {
                    return e.name === param.name && e.in === param.in;
                  });
                  if (!match && (param.in === "formData" || param.in === "body" || param.type === "file")) {
                    op = processParameter(param, op, path, method, p, openapi, options2);
                    if (options2.rbname && op[options2.rbname] === "") {
                      delete op[options2.rbname];
                    }
                  }
                }
              }
              for (let param of op.parameters) {
                op = processParameter(param, op, path, method, method + ":" + p, openapi, options2);
              }
              if (options2.rbname && op[options2.rbname] === "") {
                delete op[options2.rbname];
              }
              if (!options2.debug) {
                if (op.parameters) op.parameters = op.parameters.filter(keepParameters);
              }
            }
            if (op && op.security) processSecurity(op.security);
            if (typeof op === "object") {
              if (!op.responses) {
                let defaultResp = {};
                defaultResp.description = "Default response";
                op.responses = { default: defaultResp };
              }
              for (let r in op.responses) {
                let response = op.responses[r];
                processResponse(response, r, op, openapi, options2);
              }
            }
            if (op && op["x-servers"] && Array.isArray(op["x-servers"])) {
              op.servers = op["x-servers"];
              delete op["x-servers"];
            } else if (op && op.schemes && op.schemes.length) {
              for (let scheme of op.schemes) {
                if (!openapi.schemes || openapi.schemes.indexOf(scheme) < 0) {
                  if (!op.servers) {
                    op.servers = [];
                  }
                  if (Array.isArray(openapi.servers)) {
                    for (let server of openapi.servers) {
                      let newServer = clone2(server);
                      let serverUrl = url.parse(newServer.url);
                      serverUrl.protocol = scheme;
                      newServer.url = serverUrl.format();
                      op.servers.push(newServer);
                    }
                  }
                }
              }
            }
            if (options2.debug) {
              op["x-s2o-consumes"] = op.consumes || [];
              op["x-s2o-produces"] = op.produces || [];
            }
            if (op) {
              delete op.consumes;
              delete op.produces;
              delete op.schemes;
              if (op["x-ms-examples"]) {
                for (let e in op["x-ms-examples"]) {
                  let example = op["x-ms-examples"][e];
                  let se = common.sanitiseAll(e);
                  if (example.parameters) {
                    for (let p2 in example.parameters) {
                      let value = example.parameters[p2];
                      for (let param of (op.parameters || []).concat(path.parameters || [])) {
                        if (param.$ref) {
                          param = jptr.jptr(openapi, param.$ref);
                        }
                        if (param.name === p2 && !param.example) {
                          if (!param.examples) {
                            param.examples = {};
                          }
                          param.examples[e] = { value };
                        }
                      }
                    }
                  }
                  if (example.responses) {
                    for (let r in example.responses) {
                      if (example.responses[r].headers) {
                        for (let h in example.responses[r].headers) {
                          let value = example.responses[r].headers[h];
                          for (let rh in op.responses[r].headers) {
                            if (rh === h) {
                              let header = op.responses[r].headers[rh];
                              header.example = value;
                            }
                          }
                        }
                      }
                      if (example.responses[r].body) {
                        openapi.components.examples[se] = { value: clone2(example.responses[r].body) };
                        if (op.responses[r] && op.responses[r].content) {
                          for (let ct in op.responses[r].content) {
                            let contentType = op.responses[r].content[ct];
                            if (!contentType.examples) {
                              contentType.examples = {};
                            }
                            contentType.examples[e] = { $ref: "#/components/examples/" + se };
                          }
                        }
                      }
                    }
                  }
                }
                delete op["x-ms-examples"];
              }
              if (op.parameters && op.parameters.length === 0) delete op.parameters;
              if (op.requestBody) {
                let effectiveOperationId = op.operationId ? common.sanitiseAll(op.operationId) : common.sanitiseAll(method + p).toCamelCase();
                let rbName = common.sanitise(op.requestBody["x-s2o-name"] || effectiveOperationId || "");
                delete op.requestBody["x-s2o-name"];
                let rbStr = JSON.stringify(op.requestBody);
                let rbHash = common.hash(rbStr);
                if (!requestBodyCache[rbHash]) {
                  let entry = {};
                  entry.name = rbName;
                  entry.body = op.requestBody;
                  entry.refs = [];
                  requestBodyCache[rbHash] = entry;
                }
                let ptr = "#/" + containerName + "/" + encodeURIComponent(jptr.jpescape(p)) + "/" + method + "/requestBody";
                requestBodyCache[rbHash].refs.push(ptr);
              }
            }
          }
        }
        if (path && path.parameters) {
          for (let p2 in path.parameters) {
            let param = path.parameters[p2];
            processParameter(param, null, path, null, p, openapi, options2);
          }
          if (!options2.debug && Array.isArray(path.parameters)) {
            path.parameters = path.parameters.filter(keepParameters);
          }
        }
      }
    }
    function main(openapi, options2) {
      let requestBodyCache = {};
      componentNames = { schemas: {} };
      if (openapi.security) processSecurity(openapi.security);
      for (let s in openapi.components.securitySchemes) {
        let sname = common.sanitise(s);
        if (s !== sname) {
          if (openapi.components.securitySchemes[sname]) {
            throwError("Duplicate sanitised securityScheme name " + sname, options2);
          }
          openapi.components.securitySchemes[sname] = openapi.components.securitySchemes[s];
          delete openapi.components.securitySchemes[s];
        }
        processSecurityScheme(openapi.components.securitySchemes[sname], options2);
      }
      for (let s in openapi.components.schemas) {
        let sname = common.sanitiseAll(s);
        let suffix = "";
        if (s !== sname) {
          while (openapi.components.schemas[sname + suffix]) {
            suffix = suffix ? ++suffix : 2;
          }
          openapi.components.schemas[sname + suffix] = openapi.components.schemas[s];
          delete openapi.components.schemas[s];
        }
        componentNames.schemas[s] = sname + suffix;
        fixUpSchema(openapi.components.schemas[sname + suffix], options2);
      }
      options2.refmap = {};
      recurse(openapi, { payload: { options: options2 } }, fixupRefs);
      dedupeRefs(openapi, options2);
      for (let p in openapi.components.parameters) {
        let sname = common.sanitise(p);
        if (p !== sname) {
          if (openapi.components.parameters[sname]) {
            throwError("Duplicate sanitised parameter name " + sname, options2);
          }
          openapi.components.parameters[sname] = openapi.components.parameters[p];
          delete openapi.components.parameters[p];
        }
        let param = openapi.components.parameters[sname];
        processParameter(param, null, null, null, sname, openapi, options2);
      }
      for (let r in openapi.components.responses) {
        let sname = common.sanitise(r);
        if (r !== sname) {
          if (openapi.components.responses[sname]) {
            throwError("Duplicate sanitised response name " + sname, options2);
          }
          openapi.components.responses[sname] = openapi.components.responses[r];
          delete openapi.components.responses[r];
        }
        let response = openapi.components.responses[sname];
        processResponse(response, sname, null, openapi, options2);
        if (response.headers) {
          for (let h in response.headers) {
            if (h.toLowerCase() === "status code") {
              if (options2.patch) {
                options2.patches++;
                delete response.headers[h];
              } else {
                throwError('(Patchable) "Status Code" is not a valid header', options2);
              }
            } else {
              processHeader(response.headers[h], options2);
            }
          }
        }
      }
      for (let r in openapi.components.requestBodies) {
        let rb = openapi.components.requestBodies[r];
        let rbStr = JSON.stringify(rb);
        let rbHash = common.hash(rbStr);
        let entry = {};
        entry.name = r;
        entry.body = rb;
        entry.refs = [];
        requestBodyCache[rbHash] = entry;
      }
      processPaths(openapi.paths, "paths", options2, requestBodyCache, openapi);
      if (openapi["x-ms-paths"]) {
        processPaths(openapi["x-ms-paths"], "x-ms-paths", options2, requestBodyCache, openapi);
      }
      if (!options2.debug) {
        for (let p in openapi.components.parameters) {
          let param = openapi.components.parameters[p];
          if (param["x-s2o-delete"]) {
            delete openapi.components.parameters[p];
          }
        }
      }
      if (options2.debug) {
        openapi["x-s2o-consumes"] = openapi.consumes || [];
        openapi["x-s2o-produces"] = openapi.produces || [];
      }
      delete openapi.consumes;
      delete openapi.produces;
      delete openapi.schemes;
      let rbNamesGenerated = [];
      openapi.components.requestBodies = {};
      if (!options2.resolveInternal) {
        let counter = 1;
        for (let e in requestBodyCache) {
          let entry = requestBodyCache[e];
          if (entry.refs.length > 1) {
            let suffix = "";
            if (!entry.name) {
              entry.name = "requestBody";
              suffix = counter++;
            }
            while (rbNamesGenerated.indexOf(entry.name + suffix) >= 0) {
              suffix = suffix ? ++suffix : 2;
            }
            entry.name = entry.name + suffix;
            rbNamesGenerated.push(entry.name);
            openapi.components.requestBodies[entry.name] = clone2(entry.body);
            for (let r in entry.refs) {
              let ref = {};
              ref.$ref = "#/components/requestBodies/" + entry.name;
              jptr.jptr(openapi, entry.refs[r], ref);
            }
          }
        }
      }
      if (openapi.components.responses && Object.keys(openapi.components.responses).length === 0) {
        delete openapi.components.responses;
      }
      if (openapi.components.parameters && Object.keys(openapi.components.parameters).length === 0) {
        delete openapi.components.parameters;
      }
      if (openapi.components.examples && Object.keys(openapi.components.examples).length === 0) {
        delete openapi.components.examples;
      }
      if (openapi.components.requestBodies && Object.keys(openapi.components.requestBodies).length === 0) {
        delete openapi.components.requestBodies;
      }
      if (openapi.components.securitySchemes && Object.keys(openapi.components.securitySchemes).length === 0) {
        delete openapi.components.securitySchemes;
      }
      if (openapi.components.headers && Object.keys(openapi.components.headers).length === 0) {
        delete openapi.components.headers;
      }
      if (openapi.components.schemas && Object.keys(openapi.components.schemas).length === 0) {
        delete openapi.components.schemas;
      }
      if (openapi.components && Object.keys(openapi.components).length === 0) {
        delete openapi.components;
      }
      return openapi;
    }
    function extractServerParameters(server) {
      if (!server || !server.url || typeof server.url !== "string") return server;
      server.url = server.url.split("{{").join("{");
      server.url = server.url.split("}}").join("}");
      server.url.replace(/\{(.+?)\}/g, function(match, group1) {
        if (!server.variables) {
          server.variables = {};
        }
        server.variables[group1] = { default: "unknown" };
      });
      return server;
    }
    function fixInfo(openapi, options2, reject) {
      if (typeof openapi.info === "undefined" || openapi.info === null) {
        if (options2.patch) {
          options2.patches++;
          openapi.info = { version: "", title: "" };
        } else {
          return reject(new S2OError("(Patchable) info object is mandatory"));
        }
      }
      if (typeof openapi.info !== "object" || Array.isArray(openapi.info)) {
        return reject(new S2OError("info must be an object"));
      }
      if (typeof openapi.info.title === "undefined" || openapi.info.title === null) {
        if (options2.patch) {
          options2.patches++;
          openapi.info.title = "";
        } else {
          return reject(new S2OError("(Patchable) info.title cannot be null"));
        }
      }
      if (typeof openapi.info.version === "undefined" || openapi.info.version === null) {
        if (options2.patch) {
          options2.patches++;
          openapi.info.version = "";
        } else {
          return reject(new S2OError("(Patchable) info.version cannot be null"));
        }
      }
      if (typeof openapi.info.version !== "string") {
        if (options2.patch) {
          options2.patches++;
          openapi.info.version = openapi.info.version.toString();
        } else {
          return reject(new S2OError("(Patchable) info.version must be a string"));
        }
      }
      if (typeof openapi.info.logo !== "undefined") {
        if (options2.patch) {
          options2.patches++;
          openapi.info["x-logo"] = openapi.info.logo;
          delete openapi.info.logo;
        } else return reject(new S2OError("(Patchable) info should not have logo property"));
      }
      if (typeof openapi.info.termsOfService !== "undefined") {
        if (openapi.info.termsOfService === null) {
          if (options2.patch) {
            options2.patches++;
            openapi.info.termsOfService = "";
          } else {
            return reject(new S2OError("(Patchable) info.termsOfService cannot be null"));
          }
        }
        try {
          let u = new URL(openapi.info.termsOfService);
        } catch (ex) {
          if (options2.patch) {
            options2.patches++;
            delete openapi.info.termsOfService;
          } else return reject(new S2OError("(Patchable) info.termsOfService must be a URL"));
        }
      }
    }
    function fixPaths(openapi, options2, reject) {
      if (typeof openapi.paths === "undefined") {
        if (options2.patch) {
          options2.patches++;
          openapi.paths = {};
        } else {
          return reject(new S2OError("(Patchable) paths object is mandatory"));
        }
      }
    }
    function detectObjectReferences(obj, options2) {
      const seen = /* @__PURE__ */ new WeakSet();
      recurse(obj, { identityDetection: true }, function(obj2, key2, state) {
        if (typeof obj2[key2] === "object" && obj2[key2] !== null) {
          if (seen.has(obj2[key2])) {
            if (options2.anchors) {
              obj2[key2] = clone2(obj2[key2]);
            } else {
              throwError("YAML anchor or merge key at " + state.path, options2);
            }
          } else {
            seen.add(obj2[key2]);
          }
        }
      });
    }
    function convertObj2(swagger, options2, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        if (!swagger) swagger = {};
        options2.original = swagger;
        if (!options2.text) options2.text = yaml.stringify(swagger);
        options2.externals = [];
        options2.externalRefs = {};
        options2.rewriteRefs = true;
        options2.preserveMiro = true;
        options2.promise = {};
        options2.promise.resolve = resolve;
        options2.promise.reject = reject;
        options2.patches = 0;
        if (!options2.cache) options2.cache = {};
        if (options2.source) options2.cache[options2.source] = options2.original;
        detectObjectReferences(swagger, options2);
        if (swagger.openapi && typeof swagger.openapi === "string" && swagger.openapi.startsWith("3.")) {
          options2.openapi = cclone(swagger);
          fixInfo(options2.openapi, options2, reject);
          fixPaths(options2.openapi, options2, reject);
          resolver.optionalResolve(options2).then(function() {
            if (options2.direct) {
              return resolve(options2.openapi);
            } else {
              return resolve(options2);
            }
          }).catch(function(ex) {
            console.warn(ex);
            reject(ex);
          });
          return;
        }
        if (!swagger.swagger || swagger.swagger != "2.0") {
          return reject(new S2OError("Unsupported swagger/OpenAPI version: " + (swagger.openapi ? swagger.openapi : swagger.swagger)));
        }
        let openapi = options2.openapi = {};
        openapi.openapi = typeof options2.targetVersion === "string" && options2.targetVersion.startsWith("3.") ? options2.targetVersion : targetVersion;
        if (options2.origin) {
          if (!openapi["x-origin"]) {
            openapi["x-origin"] = [];
          }
          let origin = {};
          origin.url = options2.source || options2.origin;
          origin.format = "swagger";
          origin.version = swagger.swagger;
          origin.converter = {};
          origin.converter.url = "https://github.com/mermade/oas-kit";
          origin.converter.version = ourVersion;
          openapi["x-origin"].push(origin);
        }
        openapi = Object.assign(openapi, cclone(swagger));
        delete openapi.swagger;
        recurse(openapi, {}, function(obj, key2, state) {
          if (obj[key2] === null && !key2.startsWith("x-") && key2 !== "default" && state.path.indexOf("/example") < 0) delete obj[key2];
        });
        if (swagger.host) {
          for (let s of Array.isArray(swagger.schemes) ? swagger.schemes : [""]) {
            let server = {};
            let basePath = (swagger.basePath || "").replace(/\/$/, "");
            server.url = (s ? s + ":" : "") + "//" + swagger.host + basePath;
            extractServerParameters(server);
            if (!openapi.servers) openapi.servers = [];
            openapi.servers.push(server);
          }
        } else if (swagger.basePath) {
          let server = {};
          server.url = swagger.basePath;
          extractServerParameters(server);
          if (!openapi.servers) openapi.servers = [];
          openapi.servers.push(server);
        }
        delete openapi.host;
        delete openapi.basePath;
        if (openapi["x-servers"] && Array.isArray(openapi["x-servers"])) {
          openapi.servers = openapi["x-servers"];
          delete openapi["x-servers"];
        }
        if (swagger["x-ms-parameterized-host"]) {
          let xMsPHost = swagger["x-ms-parameterized-host"];
          let server = {};
          server.url = xMsPHost.hostTemplate + (swagger.basePath ? swagger.basePath : "");
          server.variables = {};
          const paramNames = server.url.match(/\{\w+\}/g);
          for (let msp in xMsPHost.parameters) {
            let param = xMsPHost.parameters[msp];
            if (param.$ref) {
              param = clone2(resolveInternal(openapi, param.$ref));
            }
            if (!msp.startsWith("x-")) {
              delete param.required;
              delete param.type;
              delete param.in;
              if (typeof param.default === "undefined") {
                if (param.enum) {
                  param.default = param.enum[0];
                } else {
                  param.default = "none";
                }
              }
              if (!param.name) {
                param.name = paramNames[msp].replace("{", "").replace("}", "");
              }
              server.variables[param.name] = param;
              delete param.name;
            }
          }
          if (!openapi.servers) openapi.servers = [];
          if (xMsPHost.useSchemePrefix === false) {
            openapi.servers.push(server);
          } else {
            swagger.schemes.forEach((scheme) => {
              openapi.servers.push(
                Object.assign({}, server, { url: scheme + "://" + server.url })
              );
            });
          }
          delete openapi["x-ms-parameterized-host"];
        }
        fixInfo(openapi, options2, reject);
        fixPaths(openapi, options2, reject);
        if (typeof openapi.consumes === "string") {
          openapi.consumes = [openapi.consumes];
        }
        if (typeof openapi.produces === "string") {
          openapi.produces = [openapi.produces];
        }
        openapi.components = {};
        if (openapi["x-callbacks"]) {
          openapi.components.callbacks = openapi["x-callbacks"];
          delete openapi["x-callbacks"];
        }
        openapi.components.examples = {};
        openapi.components.headers = {};
        if (openapi["x-links"]) {
          openapi.components.links = openapi["x-links"];
          delete openapi["x-links"];
        }
        openapi.components.parameters = openapi.parameters || {};
        openapi.components.responses = openapi.responses || {};
        openapi.components.requestBodies = {};
        openapi.components.securitySchemes = openapi.securityDefinitions || {};
        openapi.components.schemas = openapi.definitions || {};
        delete openapi.definitions;
        delete openapi.responses;
        delete openapi.parameters;
        delete openapi.securityDefinitions;
        resolver.optionalResolve(options2).then(function() {
          main(options2.openapi, options2);
          if (options2.direct) {
            resolve(options2.openapi);
          } else {
            resolve(options2);
          }
        }).catch(function(ex) {
          console.warn(ex);
          reject(ex);
        });
      }));
    }
    function convertStr(str, options2, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        let obj = null;
        let error = null;
        try {
          obj = JSON.parse(str);
          options2.text = JSON.stringify(obj, null, 2);
        } catch (ex) {
          error = ex;
          try {
            obj = yaml.parse(str, { schema: "core", prettyErrors: true });
            options2.sourceYaml = true;
            options2.text = str;
          } catch (ex2) {
            error = ex2;
          }
        }
        if (obj) {
          convertObj2(obj, options2).then((options3) => resolve(options3)).catch((ex) => reject(ex));
        } else {
          reject(new S2OError(error ? error.message : "Could not parse string"));
        }
      }));
    }
    function convertUrl(url2, options2, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        options2.origin = true;
        if (!options2.source) {
          options2.source = url2;
        }
        if (options2.verbose) {
          console.warn("GET " + url2);
        }
        if (!options2.fetch) {
          options2.fetch = fetch2;
        }
        const fetchOptions = Object.assign({}, options2.fetchOptions, { agent: options2.agent });
        options2.fetch(url2, fetchOptions).then(function(res) {
          if (res.status !== 200) throw new S2OError(`Received status code ${res.status}: ${url2}`);
          return res.text();
        }).then(function(body) {
          convertStr(body, options2).then((options3) => resolve(options3)).catch((ex) => reject(ex));
        }).catch(function(err) {
          reject(err);
        });
      }));
    }
    function convertFile(filename, options2, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        fs.readFile(filename, options2.encoding || "utf8", function(err, s) {
          if (err) {
            reject(err);
          } else {
            options2.sourceFile = filename;
            convertStr(s, options2).then((options3) => resolve(options3)).catch((ex) => reject(ex));
          }
        });
      }));
    }
    function convertStream(readable, options2, callback) {
      return maybe(callback, new Promise(function(resolve, reject) {
        let data = "";
        readable.on("data", function(chunk) {
          data += chunk;
        }).on("end", function() {
          convertStr(data, options2).then((options3) => resolve(options3)).catch((ex) => reject(ex));
        });
      }));
    }
    module.exports = {
      S2OError,
      targetVersion,
      convert: convertObj2,
      convertObj: convertObj2,
      convertUrl,
      convertStr,
      convertFile,
      convertStream
    };
  }
});

// node_modules/decko/dist/decko.js
var require_decko = __commonJS({
  "node_modules/decko/dist/decko.js"(exports) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports !== "undefined") {
        factory(exports);
      } else {
        var mod = { exports: {} };
        factory(mod.exports);
        global2.decko = mod.exports;
      }
    })(exports, function(exports2) {
      "use strict";
      exports2.__esModule = true;
      var EMPTY = {};
      var HOP = Object.prototype.hasOwnProperty;
      var fns = { memoize: function memoize3(fn) {
        var opt = arguments.length <= 1 || arguments[1] === void 0 ? EMPTY : arguments[1];
        var cache = opt.cache || {};
        return function() {
          for (var _len = arguments.length, a = Array(_len), _key = 0; _key < _len; _key++) {
            a[_key] = arguments[_key];
          }
          var k = String(a[0]);
          if (opt.caseSensitive === false) k = k.toLowerCase();
          return HOP.call(cache, k) ? cache[k] : cache[k] = fn.apply(this, a);
        };
      }, debounce: function debounce4(fn, opts2) {
        if (typeof opts2 === "function") {
          var p = fn;
          fn = opts2;
          opts2 = p;
        }
        var delay = opts2 && opts2.delay || opts2 || 0, args = void 0, context = void 0, timer = void 0;
        return function() {
          for (var _len2 = arguments.length, a = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            a[_key2] = arguments[_key2];
          }
          args = a;
          context = this;
          if (!timer) timer = setTimeout(function() {
            fn.apply(context, args);
            args = context = timer = null;
          }, delay);
        };
      }, bind: function bind5(target, key2, _ref) {
        var fn = _ref.value;
        return { configurable: true, get: function get() {
          var value = fn.bind(this);
          Object.defineProperty(this, key2, { value, configurable: true, writable: true });
          return value;
        } };
      } };
      var memoize2 = multiMethod(fns.memoize), debounce3 = multiMethod(fns.debounce), bind4 = multiMethod(function(f, c) {
        return f.bind(c);
      }, function() {
        return fns.bind;
      });
      exports2.memoize = memoize2;
      exports2.debounce = debounce3;
      exports2.bind = bind4;
      exports2["default"] = { memoize: memoize2, debounce: debounce3, bind: bind4 };
      function multiMethod(inner, deco) {
        deco = deco || inner.decorate || decorator2(inner);
        var d = deco();
        return function() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          var l2 = args.length;
          return (l2 < 2 ? deco : l2 > 2 ? d : inner).apply(void 0, args);
        };
      }
      function decorator2(fn) {
        return function(opt) {
          return typeof opt === "function" ? fn(opt) : function(target, key2, desc) {
            desc.value = fn(desc.value, opt, target, key2, desc);
          };
        };
      }
    });
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i = 0, l2 = handlers2.length, ee = new Array(l2); i < l2; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/foreach/index.js
var require_foreach = __commonJS({
  "node_modules/foreach/index.js"(exports, module) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    module.exports = function forEach(obj, fn, ctx) {
      if (toString.call(fn) !== "[object Function]") {
        throw new TypeError("iterator must be a function");
      }
      var l2 = obj.length;
      if (l2 === +l2) {
        for (var i = 0; i < l2; i++) {
          fn.call(ctx, obj[i], i, obj);
        }
      } else {
        for (var k in obj) {
          if (hasOwn.call(obj, k)) {
            fn.call(ctx, obj[k], k, obj);
          }
        }
      }
    };
  }
});

// node_modules/json-pointer/index.js
var require_json_pointer = __commonJS({
  "node_modules/json-pointer/index.js"(exports, module) {
    "use strict";
    var each = require_foreach();
    module.exports = api;
    function api(obj, pointer, value) {
      if (arguments.length === 3) {
        return api.set(obj, pointer, value);
      }
      if (arguments.length === 2) {
        return api.get(obj, pointer);
      }
      var wrapped = api.bind(api, obj);
      for (var name2 in api) {
        if (api.hasOwnProperty(name2)) {
          wrapped[name2] = api[name2].bind(wrapped, obj);
        }
      }
      return wrapped;
    }
    api.get = function get(obj, pointer) {
      var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
      for (var i = 0; i < refTokens.length; ++i) {
        var tok = refTokens[i];
        if (!(typeof obj == "object" && tok in obj)) {
          throw new Error("Invalid reference token: " + tok);
        }
        obj = obj[tok];
      }
      return obj;
    };
    api.set = function set(obj, pointer, value) {
      var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer), nextTok = refTokens[0];
      if (refTokens.length === 0) {
        throw Error("Can not set the root object");
      }
      for (var i = 0; i < refTokens.length - 1; ++i) {
        var tok = refTokens[i];
        if (typeof tok !== "string" && typeof tok !== "number") {
          tok = String(tok);
        }
        if (tok === "__proto__" || tok === "constructor" || tok === "prototype") {
          continue;
        }
        if (tok === "-" && Array.isArray(obj)) {
          tok = obj.length;
        }
        nextTok = refTokens[i + 1];
        if (!(tok in obj)) {
          if (nextTok.match(/^(\d+|-)$/)) {
            obj[tok] = [];
          } else {
            obj[tok] = {};
          }
        }
        obj = obj[tok];
      }
      if (nextTok === "-" && Array.isArray(obj)) {
        nextTok = obj.length;
      }
      obj[nextTok] = value;
      return this;
    };
    api.remove = function(obj, pointer) {
      var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
      var finalToken = refTokens[refTokens.length - 1];
      if (finalToken === void 0) {
        throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
      }
      var parent = api.get(obj, refTokens.slice(0, -1));
      if (Array.isArray(parent)) {
        var index2 = +finalToken;
        if (finalToken === "" && isNaN(index2)) {
          throw new Error('Invalid array index: "' + finalToken + '"');
        }
        Array.prototype.splice.call(parent, index2, 1);
      } else {
        delete parent[finalToken];
      }
    };
    api.dict = function dict(obj, descend) {
      var results = {};
      api.walk(obj, function(value, pointer) {
        results[pointer] = value;
      }, descend);
      return results;
    };
    api.walk = function walk(obj, iterator, descend) {
      var refTokens = [];
      descend = descend || function(value) {
        var type = Object.prototype.toString.call(value);
        return type === "[object Object]" || type === "[object Array]";
      };
      (function next(cur2) {
        each(cur2, function(value, key2) {
          refTokens.push(String(key2));
          if (descend(value)) {
            next(value);
          } else {
            iterator(value, api.compile(refTokens));
          }
          refTokens.pop();
        });
      })(obj);
    };
    api.has = function has(obj, pointer) {
      try {
        api.get(obj, pointer);
      } catch (e) {
        return false;
      }
      return true;
    };
    api.escape = function escape2(str) {
      return str.toString().replace(/~/g, "~0").replace(/\//g, "~1");
    };
    api.unescape = function unescape2(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    };
    api.parse = function parse(pointer) {
      if (pointer === "") {
        return [];
      }
      if (pointer.charAt(0) !== "/") {
        throw new Error("Invalid JSON pointer: " + pointer);
      }
      return pointer.substring(1).split(/\//).map(api.unescape);
    };
    api.compile = function compile(refTokens) {
      if (refTokens.length === 0) {
        return "";
      }
      return "/" + refTokens.map(api.escape).join("/");
    };
  }
});

// node_modules/url-template/lib/url-template.js
var require_url_template = __commonJS({
  "node_modules/url-template/lib/url-template.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.urltemplate = factory();
      }
    })(exports, function() {
      function UrlTemplate() {
      }
      UrlTemplate.prototype.encodeReserved = function(str) {
        return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
          if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
          }
          return part;
        }).join("");
      };
      UrlTemplate.prototype.encodeUnreserved = function(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
          return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
      };
      UrlTemplate.prototype.encodeValue = function(operator2, value, key2) {
        value = operator2 === "+" || operator2 === "#" ? this.encodeReserved(value) : this.encodeUnreserved(value);
        if (key2) {
          return this.encodeUnreserved(key2) + "=" + value;
        } else {
          return value;
        }
      };
      UrlTemplate.prototype.isDefined = function(value) {
        return value !== void 0 && value !== null;
      };
      UrlTemplate.prototype.isKeyOperator = function(operator2) {
        return operator2 === ";" || operator2 === "&" || operator2 === "?";
      };
      UrlTemplate.prototype.getValues = function(context, operator2, key2, modifier) {
        var value = context[key2], result = [];
        if (this.isDefined(value) && value !== "") {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
              value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(this.encodeValue(operator2, value, this.isKeyOperator(operator2) ? key2 : null));
          } else {
            if (modifier === "*") {
              if (Array.isArray(value)) {
                value.filter(this.isDefined).forEach(function(value2) {
                  result.push(this.encodeValue(operator2, value2, this.isKeyOperator(operator2) ? key2 : null));
                }, this);
              } else {
                Object.keys(value).forEach(function(k) {
                  if (this.isDefined(value[k])) {
                    result.push(this.encodeValue(operator2, value[k], k));
                  }
                }, this);
              }
            } else {
              var tmp = [];
              if (Array.isArray(value)) {
                value.filter(this.isDefined).forEach(function(value2) {
                  tmp.push(this.encodeValue(operator2, value2));
                }, this);
              } else {
                Object.keys(value).forEach(function(k) {
                  if (this.isDefined(value[k])) {
                    tmp.push(this.encodeUnreserved(k));
                    tmp.push(this.encodeValue(operator2, value[k].toString()));
                  }
                }, this);
              }
              if (this.isKeyOperator(operator2)) {
                result.push(this.encodeUnreserved(key2) + "=" + tmp.join(","));
              } else if (tmp.length !== 0) {
                result.push(tmp.join(","));
              }
            }
          }
        } else {
          if (operator2 === ";") {
            if (this.isDefined(value)) {
              result.push(this.encodeUnreserved(key2));
            }
          } else if (value === "" && (operator2 === "&" || operator2 === "?")) {
            result.push(this.encodeUnreserved(key2) + "=");
          } else if (value === "") {
            result.push("");
          }
        }
        return result;
      };
      UrlTemplate.prototype.parse = function(template) {
        var that = this;
        var operators = ["+", "#", ".", "/", ";", "?", "&"];
        return {
          expand: function(context) {
            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal2) {
              if (expression) {
                var operator2 = null, values = [];
                if (operators.indexOf(expression.charAt(0)) !== -1) {
                  operator2 = expression.charAt(0);
                  expression = expression.substr(1);
                }
                expression.split(/,/g).forEach(function(variable) {
                  var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                  values.push.apply(values, that.getValues(context, operator2, tmp[1], tmp[2] || tmp[3]));
                });
                if (operator2 && operator2 !== "+") {
                  var separator = ",";
                  if (operator2 === "?") {
                    separator = "&";
                  } else if (operator2 !== "#") {
                    separator = operator2;
                  }
                  return (values.length !== 0 ? operator2 : "") + values.join(separator);
                } else {
                  return values.join(",");
                }
              } else {
                return that.encodeReserved(literal2);
              }
            });
          }
        };
      };
      return new UrlTemplate();
    });
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism3 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone2;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = /** @type {Record<string, any>} */
                {};
                visited[id] = clone2;
                for (var key2 in o) {
                  if (o.hasOwnProperty(key2)) {
                    clone2[key2] = deepClone(o[key2], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone2
                );
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = [];
                visited[id] = clone2;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v, i) {
                  clone2[i] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone2
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language2) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language2);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key2 in redef) {
              lang2[key2] = redef[key2];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside2, before, insert2, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside2];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert2) {
                    if (insert2.hasOwnProperty(newToken)) {
                      ret[newToken] = insert2[newToken];
                    }
                  }
                }
                if (!insert2.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside2];
            root[inside2] = ret;
            _.languages.DFS(_.languages, function(key2, value) {
              if (value === old && key2 != inside2) {
                this[key2] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language2 = _.util.getLanguage(element);
          var grammar = _.languages[language2];
          _.util.setLanguage(element, language2);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language2);
          }
          var code = element.textContent;
          var env = {
            element,
            language: language2,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text2, grammar, language2) {
          var env = {
            code: text2,
            grammar,
            language: language2
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text2, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text2);
          matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content2, alias, matchedStr) {
        this.type = type;
        this.content = content2;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language2) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language2);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language2),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language: language2
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text2, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text2);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside2 = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text2.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text2, lookbehind);
                if (!match || match.index >= text2.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text2.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside2 ? _.tokenize(matchStr, inside2) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism3;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism3;
    }
    Prism3.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism3.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism3.languages.markup["entity"];
    Prism3.languages.markup["doctype"].inside["internal-subset"].inside = Prism3.languages.markup;
    Prism3.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism3.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined2(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism3.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside2 = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside2["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism3.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside: inside2
        };
        Prism3.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism3.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism3.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism3.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism3.languages.html = Prism3.languages.markup;
    Prism3.languages.mathml = Prism3.languages.markup;
    Prism3.languages.svg = Prism3.languages.markup;
    Prism3.languages.xml = Prism3.languages.extend("markup", {});
    Prism3.languages.ssml = Prism3.languages.xml;
    Prism3.languages.atom = Prism3.languages.xml;
    Prism3.languages.rss = Prism3.languages.xml;
    (function(Prism4) {
      var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism4.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string2.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string2,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism4.languages.css["atrule"].inside.rest = Prism4.languages.css;
      var markup = Prism4.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism3);
    Prism3.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism3.languages.javascript = Prism3.languages.extend("clike", {
      "class-name": [
        Prism3.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism3.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism3.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism3.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism3.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism3.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism3.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism3.languages.markup) {
      Prism3.languages.markup.tag.addInlined("script", "javascript");
      Prism3.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism3.languages.js = Prism3.languages.javascript;
    (function() {
      if (typeof Prism3 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism3.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism3.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language2 = env.language;
          if (language2 === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language2 = EXTENSIONS[extension] || extension;
          }
          Prism3.util.setLanguage(code, language2);
          Prism3.util.setLanguage(pre, language2);
          var autoloader = Prism3.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language2);
          }
          loadFile(
            src,
            function(text2) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text2.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text2 = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text2;
              Prism3.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism3.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight2(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism3.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism3.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism3.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/mark.js/dist/mark.js
var require_mark = __commonJS({
  "node_modules/mark.js/dist/mark.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Mark = factory();
    })(exports, function() {
      "use strict";
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var _extends3 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key2 in source) {
            if (Object.prototype.hasOwnProperty.call(source, key2)) {
              target[key2] = source[key2];
            }
          }
        }
        return target;
      };
      var DOMIterator = function() {
        function DOMIterator2(ctx) {
          var iframes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var exclude = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          var iframesTimeout = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          classCallCheck(this, DOMIterator2);
          this.ctx = ctx;
          this.iframes = iframes;
          this.exclude = exclude;
          this.iframesTimeout = iframesTimeout;
        }
        createClass(DOMIterator2, [{
          key: "getContexts",
          value: function getContexts() {
            var ctx = void 0, filteredCtx = [];
            if (typeof this.ctx === "undefined" || !this.ctx) {
              ctx = [];
            } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {
              ctx = Array.prototype.slice.call(this.ctx);
            } else if (Array.isArray(this.ctx)) {
              ctx = this.ctx;
            } else if (typeof this.ctx === "string") {
              ctx = Array.prototype.slice.call(document.querySelectorAll(this.ctx));
            } else {
              ctx = [this.ctx];
            }
            ctx.forEach(function(ctx2) {
              var isDescendant = filteredCtx.filter(function(contexts) {
                return contexts.contains(ctx2);
              }).length > 0;
              if (filteredCtx.indexOf(ctx2) === -1 && !isDescendant) {
                filteredCtx.push(ctx2);
              }
            });
            return filteredCtx;
          }
        }, {
          key: "getIframeContents",
          value: function getIframeContents(ifr, successFn) {
            var errorFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            };
            var doc2 = void 0;
            try {
              var ifrWin = ifr.contentWindow;
              doc2 = ifrWin.document;
              if (!ifrWin || !doc2) {
                throw new Error("iframe inaccessible");
              }
            } catch (e) {
              errorFn();
            }
            if (doc2) {
              successFn(doc2);
            }
          }
        }, {
          key: "isIframeBlank",
          value: function isIframeBlank(ifr) {
            var bl = "about:blank", src = ifr.getAttribute("src").trim(), href = ifr.contentWindow.location.href;
            return href === bl && src !== bl && src;
          }
        }, {
          key: "observeIframeLoad",
          value: function observeIframeLoad(ifr, successFn, errorFn) {
            var _this = this;
            var called = false, tout = null;
            var listener = function listener2() {
              if (called) {
                return;
              }
              called = true;
              clearTimeout(tout);
              try {
                if (!_this.isIframeBlank(ifr)) {
                  ifr.removeEventListener("load", listener2);
                  _this.getIframeContents(ifr, successFn, errorFn);
                }
              } catch (e) {
                errorFn();
              }
            };
            ifr.addEventListener("load", listener);
            tout = setTimeout(listener, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function onIframeReady(ifr, successFn, errorFn) {
            try {
              if (ifr.contentWindow.document.readyState === "complete") {
                if (this.isIframeBlank(ifr)) {
                  this.observeIframeLoad(ifr, successFn, errorFn);
                } else {
                  this.getIframeContents(ifr, successFn, errorFn);
                }
              } else {
                this.observeIframeLoad(ifr, successFn, errorFn);
              }
            } catch (e) {
              errorFn();
            }
          }
        }, {
          key: "waitForIframes",
          value: function waitForIframes(ctx, done2) {
            var _this2 = this;
            var eachCalled = 0;
            this.forEachIframe(ctx, function() {
              return true;
            }, function(ifr) {
              eachCalled++;
              _this2.waitForIframes(ifr.querySelector("html"), function() {
                if (!--eachCalled) {
                  done2();
                }
              });
            }, function(handled) {
              if (!handled) {
                done2();
              }
            });
          }
        }, {
          key: "forEachIframe",
          value: function forEachIframe(ctx, filter, each) {
            var _this3 = this;
            var end = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            };
            var ifr = ctx.querySelectorAll("iframe"), open = ifr.length, handled = 0;
            ifr = Array.prototype.slice.call(ifr);
            var checkEnd = function checkEnd2() {
              if (--open <= 0) {
                end(handled);
              }
            };
            if (!open) {
              checkEnd();
            }
            ifr.forEach(function(ifr2) {
              if (DOMIterator2.matches(ifr2, _this3.exclude)) {
                checkEnd();
              } else {
                _this3.onIframeReady(ifr2, function(con) {
                  if (filter(ifr2)) {
                    handled++;
                    each(con);
                  }
                  checkEnd();
                }, checkEnd);
              }
            });
          }
        }, {
          key: "createIterator",
          value: function createIterator(ctx, whatToShow, filter) {
            return document.createNodeIterator(ctx, whatToShow, filter, false);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function createInstanceOnIframe(contents) {
            return new DOMIterator2(contents.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function compareNodeIframe(node, prevNode, ifr) {
            var compCurr = node.compareDocumentPosition(ifr), prev = Node.DOCUMENT_POSITION_PRECEDING;
            if (compCurr & prev) {
              if (prevNode !== null) {
                var compPrev = prevNode.compareDocumentPosition(ifr), after = Node.DOCUMENT_POSITION_FOLLOWING;
                if (compPrev & after) {
                  return true;
                }
              } else {
                return true;
              }
            }
            return false;
          }
        }, {
          key: "getIteratorNode",
          value: function getIteratorNode(itr) {
            var prevNode = itr.previousNode();
            var node = void 0;
            if (prevNode === null) {
              node = itr.nextNode();
            } else {
              node = itr.nextNode() && itr.nextNode();
            }
            return {
              prevNode,
              node
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function checkIframeFilter(node, prevNode, currIfr, ifr) {
            var key2 = false, handled = false;
            ifr.forEach(function(ifrDict, i) {
              if (ifrDict.val === currIfr) {
                key2 = i;
                handled = ifrDict.handled;
              }
            });
            if (this.compareNodeIframe(node, prevNode, currIfr)) {
              if (key2 === false && !handled) {
                ifr.push({
                  val: currIfr,
                  handled: true
                });
              } else if (key2 !== false && !handled) {
                ifr[key2].handled = true;
              }
              return true;
            }
            if (key2 === false) {
              ifr.push({
                val: currIfr,
                handled: false
              });
            }
            return false;
          }
        }, {
          key: "handleOpenIframes",
          value: function handleOpenIframes(ifr, whatToShow, eCb, fCb) {
            var _this4 = this;
            ifr.forEach(function(ifrDict) {
              if (!ifrDict.handled) {
                _this4.getIframeContents(ifrDict.val, function(con) {
                  _this4.createInstanceOnIframe(con).forEachNode(whatToShow, eCb, fCb);
                });
              }
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {
            var _this5 = this;
            var itr = this.createIterator(ctx, whatToShow, filterCb);
            var ifr = [], elements = [], node = void 0, prevNode = void 0, retrieveNodes = function retrieveNodes2() {
              var _getIteratorNode = _this5.getIteratorNode(itr);
              prevNode = _getIteratorNode.prevNode;
              node = _getIteratorNode.node;
              return node;
            };
            while (retrieveNodes()) {
              if (this.iframes) {
                this.forEachIframe(ctx, function(currIfr) {
                  return _this5.checkIframeFilter(node, prevNode, currIfr, ifr);
                }, function(con) {
                  _this5.createInstanceOnIframe(con).forEachNode(whatToShow, function(ifrNode) {
                    return elements.push(ifrNode);
                  }, filterCb);
                });
              }
              elements.push(node);
            }
            elements.forEach(function(node2) {
              eachCb(node2);
            });
            if (this.iframes) {
              this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);
            }
            doneCb();
          }
        }, {
          key: "forEachNode",
          value: function forEachNode(whatToShow, each, filter) {
            var _this6 = this;
            var done2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            };
            var contexts = this.getContexts();
            var open = contexts.length;
            if (!open) {
              done2();
            }
            contexts.forEach(function(ctx) {
              var ready = function ready2() {
                _this6.iterateThroughNodes(whatToShow, ctx, each, filter, function() {
                  if (--open <= 0) {
                    done2();
                  }
                });
              };
              if (_this6.iframes) {
                _this6.waitForIframes(ctx, ready);
              } else {
                ready();
              }
            });
          }
        }], [{
          key: "matches",
          value: function matches(element, selector) {
            var selectors = typeof selector === "string" ? [selector] : selector, fn = element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector;
            if (fn) {
              var match = false;
              selectors.every(function(sel) {
                if (fn.call(element, sel)) {
                  match = true;
                  return false;
                }
                return true;
              });
              return match;
            } else {
              return false;
            }
          }
        }]);
        return DOMIterator2;
      }();
      var Mark$1 = function() {
        function Mark3(ctx) {
          classCallCheck(this, Mark3);
          this.ctx = ctx;
          this.ie = false;
          var ua = window.navigator.userAgent;
          if (ua.indexOf("MSIE") > -1 || ua.indexOf("Trident") > -1) {
            this.ie = true;
          }
        }
        createClass(Mark3, [{
          key: "log",
          value: function log(msg) {
            var level2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug";
            var log2 = this.opt.log;
            if (!this.opt.debug) {
              return;
            }
            if ((typeof log2 === "undefined" ? "undefined" : _typeof(log2)) === "object" && typeof log2[level2] === "function") {
              log2[level2]("mark.js: " + msg);
            }
          }
        }, {
          key: "escapeStr",
          value: function escapeStr(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function createRegExp(str) {
            if (this.opt.wildcards !== "disabled") {
              str = this.setupWildcardsRegExp(str);
            }
            str = this.escapeStr(str);
            if (Object.keys(this.opt.synonyms).length) {
              str = this.createSynonymsRegExp(str);
            }
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str = this.setupIgnoreJoinersRegExp(str);
            }
            if (this.opt.diacritics) {
              str = this.createDiacriticsRegExp(str);
            }
            str = this.createMergedBlanksRegExp(str);
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str = this.createJoinersRegExp(str);
            }
            if (this.opt.wildcards !== "disabled") {
              str = this.createWildcardsRegExp(str);
            }
            str = this.createAccuracyRegExp(str);
            return str;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function createSynonymsRegExp(str) {
            var syn = this.opt.synonyms, sens = this.opt.caseSensitive ? "" : "i", joinerPlaceholder = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var index2 in syn) {
              if (syn.hasOwnProperty(index2)) {
                var value = syn[index2], k1 = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(index2) : this.escapeStr(index2), k2 = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(value) : this.escapeStr(value);
                if (k1 !== "" && k2 !== "") {
                  str = str.replace(new RegExp("(" + this.escapeStr(k1) + "|" + this.escapeStr(k2) + ")", "gm" + sens), joinerPlaceholder + ("(" + this.processSynomyms(k1) + "|") + (this.processSynomyms(k2) + ")") + joinerPlaceholder);
                }
              }
            }
            return str;
          }
        }, {
          key: "processSynomyms",
          value: function processSynomyms(str) {
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str = this.setupIgnoreJoinersRegExp(str);
            }
            return str;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function setupWildcardsRegExp(str) {
            str = str.replace(/(?:\\)*\?/g, function(val) {
              return val.charAt(0) === "\\" ? "?" : "";
            });
            return str.replace(/(?:\\)*\*/g, function(val) {
              return val.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function createWildcardsRegExp(str) {
            var spaces = this.opt.wildcards === "withSpaces";
            return str.replace(/\u0001/g, spaces ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, spaces ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function setupIgnoreJoinersRegExp(str) {
            return str.replace(/[^(|)\\]/g, function(val, indx, original) {
              var nextChar2 = original.charAt(indx + 1);
              if (/[(|)\\]/.test(nextChar2) || nextChar2 === "") {
                return val;
              } else {
                return val + "\0";
              }
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function createJoinersRegExp(str) {
            var joiner = [];
            var ignorePunctuation = this.opt.ignorePunctuation;
            if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {
              joiner.push(this.escapeStr(ignorePunctuation.join("")));
            }
            if (this.opt.ignoreJoiners) {
              joiner.push("\\u00ad\\u200b\\u200c\\u200d");
            }
            return joiner.length ? str.split(/\u0000+/).join("[" + joiner.join("") + "]*") : str;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function createDiacriticsRegExp(str) {
            var sens = this.opt.caseSensitive ? "" : "i", dct = this.opt.caseSensitive ? ["a\xE0\xE1\u1EA3\xE3\u1EA1\u0103\u1EB1\u1EAF\u1EB3\u1EB5\u1EB7\xE2\u1EA7\u1EA5\u1EA9\u1EAB\u1EAD\xE4\xE5\u0101\u0105", "A\xC0\xC1\u1EA2\xC3\u1EA0\u0102\u1EB0\u1EAE\u1EB2\u1EB4\u1EB6\xC2\u1EA6\u1EA4\u1EA8\u1EAA\u1EAC\xC4\xC5\u0100\u0104", "c\xE7\u0107\u010D", "C\xC7\u0106\u010C", "d\u0111\u010F", "D\u0110\u010E", "e\xE8\xE9\u1EBB\u1EBD\u1EB9\xEA\u1EC1\u1EBF\u1EC3\u1EC5\u1EC7\xEB\u011B\u0113\u0119", "E\xC8\xC9\u1EBA\u1EBC\u1EB8\xCA\u1EC0\u1EBE\u1EC2\u1EC4\u1EC6\xCB\u011A\u0112\u0118", "i\xEC\xED\u1EC9\u0129\u1ECB\xEE\xEF\u012B", "I\xCC\xCD\u1EC8\u0128\u1ECA\xCE\xCF\u012A", "l\u0142", "L\u0141", "n\xF1\u0148\u0144", "N\xD1\u0147\u0143", "o\xF2\xF3\u1ECF\xF5\u1ECD\xF4\u1ED3\u1ED1\u1ED5\u1ED7\u1ED9\u01A1\u1EDF\u1EE1\u1EDB\u1EDD\u1EE3\xF6\xF8\u014D", "O\xD2\xD3\u1ECE\xD5\u1ECC\xD4\u1ED2\u1ED0\u1ED4\u1ED6\u1ED8\u01A0\u1EDE\u1EE0\u1EDA\u1EDC\u1EE2\xD6\xD8\u014C", "r\u0159", "R\u0158", "s\u0161\u015B\u0219\u015F", "S\u0160\u015A\u0218\u015E", "t\u0165\u021B\u0163", "T\u0164\u021A\u0162", "u\xF9\xFA\u1EE7\u0169\u1EE5\u01B0\u1EEB\u1EE9\u1EED\u1EEF\u1EF1\xFB\xFC\u016F\u016B", "U\xD9\xDA\u1EE6\u0168\u1EE4\u01AF\u1EEA\u1EE8\u1EEC\u1EEE\u1EF0\xDB\xDC\u016E\u016A", "y\xFD\u1EF3\u1EF7\u1EF9\u1EF5\xFF", "Y\xDD\u1EF2\u1EF6\u1EF8\u1EF4\u0178", "z\u017E\u017C\u017A", "Z\u017D\u017B\u0179"] : ["a\xE0\xE1\u1EA3\xE3\u1EA1\u0103\u1EB1\u1EAF\u1EB3\u1EB5\u1EB7\xE2\u1EA7\u1EA5\u1EA9\u1EAB\u1EAD\xE4\xE5\u0101\u0105A\xC0\xC1\u1EA2\xC3\u1EA0\u0102\u1EB0\u1EAE\u1EB2\u1EB4\u1EB6\xC2\u1EA6\u1EA4\u1EA8\u1EAA\u1EAC\xC4\xC5\u0100\u0104", "c\xE7\u0107\u010DC\xC7\u0106\u010C", "d\u0111\u010FD\u0110\u010E", "e\xE8\xE9\u1EBB\u1EBD\u1EB9\xEA\u1EC1\u1EBF\u1EC3\u1EC5\u1EC7\xEB\u011B\u0113\u0119E\xC8\xC9\u1EBA\u1EBC\u1EB8\xCA\u1EC0\u1EBE\u1EC2\u1EC4\u1EC6\xCB\u011A\u0112\u0118", "i\xEC\xED\u1EC9\u0129\u1ECB\xEE\xEF\u012BI\xCC\xCD\u1EC8\u0128\u1ECA\xCE\xCF\u012A", "l\u0142L\u0141", "n\xF1\u0148\u0144N\xD1\u0147\u0143", "o\xF2\xF3\u1ECF\xF5\u1ECD\xF4\u1ED3\u1ED1\u1ED5\u1ED7\u1ED9\u01A1\u1EDF\u1EE1\u1EDB\u1EDD\u1EE3\xF6\xF8\u014DO\xD2\xD3\u1ECE\xD5\u1ECC\xD4\u1ED2\u1ED0\u1ED4\u1ED6\u1ED8\u01A0\u1EDE\u1EE0\u1EDA\u1EDC\u1EE2\xD6\xD8\u014C", "r\u0159R\u0158", "s\u0161\u015B\u0219\u015FS\u0160\u015A\u0218\u015E", "t\u0165\u021B\u0163T\u0164\u021A\u0162", "u\xF9\xFA\u1EE7\u0169\u1EE5\u01B0\u1EEB\u1EE9\u1EED\u1EEF\u1EF1\xFB\xFC\u016F\u016BU\xD9\xDA\u1EE6\u0168\u1EE4\u01AF\u1EEA\u1EE8\u1EEC\u1EEE\u1EF0\xDB\xDC\u016E\u016A", "y\xFD\u1EF3\u1EF7\u1EF9\u1EF5\xFFY\xDD\u1EF2\u1EF6\u1EF8\u1EF4\u0178", "z\u017E\u017C\u017AZ\u017D\u017B\u0179"];
            var handled = [];
            str.split("").forEach(function(ch) {
              dct.every(function(dct2) {
                if (dct2.indexOf(ch) !== -1) {
                  if (handled.indexOf(dct2) > -1) {
                    return false;
                  }
                  str = str.replace(new RegExp("[" + dct2 + "]", "gm" + sens), "[" + dct2 + "]");
                  handled.push(dct2);
                }
                return true;
              });
            });
            return str;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function createMergedBlanksRegExp(str) {
            return str.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function createAccuracyRegExp(str) {
            var _this = this;
            var chars = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\xA1\xBF";
            var acc = this.opt.accuracy, val = typeof acc === "string" ? acc : acc.value, ls = typeof acc === "string" ? [] : acc.limiters, lsJoin = "";
            ls.forEach(function(limiter) {
              lsJoin += "|" + _this.escapeStr(limiter);
            });
            switch (val) {
              case "partially":
              default:
                return "()(" + str + ")";
              case "complementary":
                lsJoin = "\\s" + (lsJoin ? lsJoin : this.escapeStr(chars));
                return "()([^" + lsJoin + "]*" + str + "[^" + lsJoin + "]*)";
              case "exactly":
                return "(^|\\s" + lsJoin + ")(" + str + ")(?=$|\\s" + lsJoin + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function getSeparatedKeywords(sv) {
            var _this2 = this;
            var stack = [];
            sv.forEach(function(kw) {
              if (!_this2.opt.separateWordSearch) {
                if (kw.trim() && stack.indexOf(kw) === -1) {
                  stack.push(kw);
                }
              } else {
                kw.split(" ").forEach(function(kwSplitted) {
                  if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {
                    stack.push(kwSplitted);
                  }
                });
              }
            });
            return {
              "keywords": stack.sort(function(a, b) {
                return b.length - a.length;
              }),
              "length": stack.length
            };
          }
        }, {
          key: "isNumeric",
          value: function isNumeric2(value) {
            return Number(parseFloat(value)) == value;
          }
        }, {
          key: "checkRanges",
          value: function checkRanges(array) {
            var _this3 = this;
            if (!Array.isArray(array) || Object.prototype.toString.call(array[0]) !== "[object Object]") {
              this.log("markRanges() will only accept an array of objects");
              this.opt.noMatch(array);
              return [];
            }
            var stack = [];
            var last = 0;
            array.sort(function(a, b) {
              return a.start - b.start;
            }).forEach(function(item) {
              var _callNoMatchOnInvalid = _this3.callNoMatchOnInvalidRanges(item, last), start = _callNoMatchOnInvalid.start, end = _callNoMatchOnInvalid.end, valid = _callNoMatchOnInvalid.valid;
              if (valid) {
                item.start = start;
                item.length = end - start;
                stack.push(item);
                last = end;
              }
            });
            return stack;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function callNoMatchOnInvalidRanges(range, last) {
            var start = void 0, end = void 0, valid = false;
            if (range && typeof range.start !== "undefined") {
              start = parseInt(range.start, 10);
              end = start + parseInt(range.length, 10);
              if (this.isNumeric(range.start) && this.isNumeric(range.length) && end - last > 0 && end - start > 0) {
                valid = true;
              } else {
                this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(range)));
                this.opt.noMatch(range);
              }
            } else {
              this.log("Ignoring invalid range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            }
            return {
              start,
              end,
              valid
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function checkWhitespaceRanges(range, originalLength, string2) {
            var end = void 0, valid = true, max = string2.length, offset = originalLength - max, start = parseInt(range.start, 10) - offset;
            start = start > max ? max : start;
            end = start + parseInt(range.length, 10);
            if (end > max) {
              end = max;
              this.log("End range automatically set to the max value of " + max);
            }
            if (start < 0 || end - start < 0 || start > max || end > max) {
              valid = false;
              this.log("Invalid range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            } else if (string2.substring(start, end).replace(/\s+/g, "") === "") {
              valid = false;
              this.log("Skipping whitespace only range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            }
            return {
              start,
              end,
              valid
            };
          }
        }, {
          key: "getTextNodes",
          value: function getTextNodes(cb) {
            var _this4 = this;
            var val = "", nodes = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(node) {
              nodes.push({
                start: val.length,
                end: (val += node.textContent).length,
                node
              });
            }, function(node) {
              if (_this4.matchesExclude(node.parentNode)) {
                return NodeFilter.FILTER_REJECT;
              } else {
                return NodeFilter.FILTER_ACCEPT;
              }
            }, function() {
              cb({
                value: val,
                nodes
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function matchesExclude(el) {
            return DOMIterator.matches(el, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function wrapRangeInTextNode(node, start, end) {
            var hEl = !this.opt.element ? "mark" : this.opt.element, startNode = node.splitText(start), ret = startNode.splitText(end - start);
            var repl = document.createElement(hEl);
            repl.setAttribute("data-markjs", "true");
            if (this.opt.className) {
              repl.setAttribute("class", this.opt.className);
            }
            repl.textContent = startNode.textContent;
            startNode.parentNode.replaceChild(repl, startNode);
            return ret;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {
            var _this5 = this;
            dict.nodes.every(function(n, i) {
              var sibl = dict.nodes[i + 1];
              if (typeof sibl === "undefined" || sibl.start > start) {
                if (!filterCb(n.node)) {
                  return false;
                }
                var s = start - n.start, e = (end > n.end ? n.end : end) - n.start, startStr = dict.value.substr(0, n.start), endStr = dict.value.substr(e + n.start);
                n.node = _this5.wrapRangeInTextNode(n.node, s, e);
                dict.value = startStr + endStr;
                dict.nodes.forEach(function(k, j) {
                  if (j >= i) {
                    if (dict.nodes[j].start > 0 && j !== i) {
                      dict.nodes[j].start -= e;
                    }
                    dict.nodes[j].end -= e;
                  }
                });
                end -= e;
                eachCb(n.node.previousSibling, n.start);
                if (end > n.end) {
                  start = n.end;
                } else {
                  return false;
                }
              }
              return true;
            });
          }
        }, {
          key: "wrapMatches",
          value: function wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {
            var _this6 = this;
            var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;
            this.getTextNodes(function(dict) {
              dict.nodes.forEach(function(node) {
                node = node.node;
                var match = void 0;
                while ((match = regex.exec(node.textContent)) !== null && match[matchIdx] !== "") {
                  if (!filterCb(match[matchIdx], node)) {
                    continue;
                  }
                  var pos = match.index;
                  if (matchIdx !== 0) {
                    for (var i = 1; i < matchIdx; i++) {
                      pos += match[i].length;
                    }
                  }
                  node = _this6.wrapRangeInTextNode(node, pos, pos + match[matchIdx].length);
                  eachCb(node.previousSibling);
                  regex.lastIndex = 0;
                }
              });
              endCb();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {
            var _this7 = this;
            var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;
            this.getTextNodes(function(dict) {
              var match = void 0;
              while ((match = regex.exec(dict.value)) !== null && match[matchIdx] !== "") {
                var start = match.index;
                if (matchIdx !== 0) {
                  for (var i = 1; i < matchIdx; i++) {
                    start += match[i].length;
                  }
                }
                var end = start + match[matchIdx].length;
                _this7.wrapRangeInMappedTextNode(dict, start, end, function(node) {
                  return filterCb(match[matchIdx], node);
                }, function(node, lastIndex) {
                  regex.lastIndex = lastIndex;
                  eachCb(node);
                });
              }
              endCb();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {
            var _this8 = this;
            this.getTextNodes(function(dict) {
              var originalLength = dict.value.length;
              ranges.forEach(function(range, counter) {
                var _checkWhitespaceRange = _this8.checkWhitespaceRanges(range, originalLength, dict.value), start = _checkWhitespaceRange.start, end = _checkWhitespaceRange.end, valid = _checkWhitespaceRange.valid;
                if (valid) {
                  _this8.wrapRangeInMappedTextNode(dict, start, end, function(node) {
                    return filterCb(node, range, dict.value.substring(start, end), counter);
                  }, function(node) {
                    eachCb(node, range);
                  });
                }
              });
              endCb();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function unwrapMatches(node) {
            var parent = node.parentNode;
            var docFrag = document.createDocumentFragment();
            while (node.firstChild) {
              docFrag.appendChild(node.removeChild(node.firstChild));
            }
            parent.replaceChild(docFrag, node);
            if (!this.ie) {
              parent.normalize();
            } else {
              this.normalizeTextNode(parent);
            }
          }
        }, {
          key: "normalizeTextNode",
          value: function normalizeTextNode(node) {
            if (!node) {
              return;
            }
            if (node.nodeType === 3) {
              while (node.nextSibling && node.nextSibling.nodeType === 3) {
                node.nodeValue += node.nextSibling.nodeValue;
                node.parentNode.removeChild(node.nextSibling);
              }
            } else {
              this.normalizeTextNode(node.firstChild);
            }
            this.normalizeTextNode(node.nextSibling);
          }
        }, {
          key: "markRegExp",
          value: function markRegExp(regexp, opt) {
            var _this9 = this;
            this.opt = opt;
            this.log('Searching with expression "' + regexp + '"');
            var totalMatches = 0, fn = "wrapMatches";
            var eachCb = function eachCb2(element) {
              totalMatches++;
              _this9.opt.each(element);
            };
            if (this.opt.acrossElements) {
              fn = "wrapMatchesAcrossElements";
            }
            this[fn](regexp, this.opt.ignoreGroups, function(match, node) {
              return _this9.opt.filter(node, match, totalMatches);
            }, eachCb, function() {
              if (totalMatches === 0) {
                _this9.opt.noMatch(regexp);
              }
              _this9.opt.done(totalMatches);
            });
          }
        }, {
          key: "mark",
          value: function mark(sv, opt) {
            var _this10 = this;
            this.opt = opt;
            var totalMatches = 0, fn = "wrapMatches";
            var _getSeparatedKeywords = this.getSeparatedKeywords(typeof sv === "string" ? [sv] : sv), kwArr = _getSeparatedKeywords.keywords, kwArrLen = _getSeparatedKeywords.length, sens = this.opt.caseSensitive ? "" : "i", handler = function handler2(kw) {
              var regex = new RegExp(_this10.createRegExp(kw), "gm" + sens), matches = 0;
              _this10.log('Searching with expression "' + regex + '"');
              _this10[fn](regex, 1, function(term, node) {
                return _this10.opt.filter(node, kw, totalMatches, matches);
              }, function(element) {
                matches++;
                totalMatches++;
                _this10.opt.each(element);
              }, function() {
                if (matches === 0) {
                  _this10.opt.noMatch(kw);
                }
                if (kwArr[kwArrLen - 1] === kw) {
                  _this10.opt.done(totalMatches);
                } else {
                  handler2(kwArr[kwArr.indexOf(kw) + 1]);
                }
              });
            };
            if (this.opt.acrossElements) {
              fn = "wrapMatchesAcrossElements";
            }
            if (kwArrLen === 0) {
              this.opt.done(totalMatches);
            } else {
              handler(kwArr[0]);
            }
          }
        }, {
          key: "markRanges",
          value: function markRanges(rawRanges, opt) {
            var _this11 = this;
            this.opt = opt;
            var totalMatches = 0, ranges = this.checkRanges(rawRanges);
            if (ranges && ranges.length) {
              this.log("Starting to mark with the following ranges: " + JSON.stringify(ranges));
              this.wrapRangeFromIndex(ranges, function(node, range, match, counter) {
                return _this11.opt.filter(node, range, match, counter);
              }, function(element, range) {
                totalMatches++;
                _this11.opt.each(element, range);
              }, function() {
                _this11.opt.done(totalMatches);
              });
            } else {
              this.opt.done(totalMatches);
            }
          }
        }, {
          key: "unmark",
          value: function unmark(opt) {
            var _this12 = this;
            this.opt = opt;
            var sel = this.opt.element ? this.opt.element : "*";
            sel += "[data-markjs]";
            if (this.opt.className) {
              sel += "." + this.opt.className;
            }
            this.log('Removal selector "' + sel + '"');
            this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(node) {
              _this12.unwrapMatches(node);
            }, function(node) {
              var matchesSel = DOMIterator.matches(node, sel), matchesExclude = _this12.matchesExclude(node);
              if (!matchesSel || matchesExclude) {
                return NodeFilter.FILTER_REJECT;
              } else {
                return NodeFilter.FILTER_ACCEPT;
              }
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function set$$1(val) {
            this._opt = _extends3({}, {
              "element": "",
              "className": "",
              "exclude": [],
              "iframes": false,
              "iframesTimeout": 5e3,
              "separateWordSearch": true,
              "diacritics": true,
              "synonyms": {},
              "accuracy": "partially",
              "acrossElements": false,
              "caseSensitive": false,
              "ignoreJoiners": false,
              "ignoreGroups": 0,
              "ignorePunctuation": [],
              "wildcards": "disabled",
              "each": function each() {
              },
              "noMatch": function noMatch() {
              },
              "filter": function filter() {
                return true;
              },
              "done": function done2() {
              },
              "debug": false,
              "log": window.console
            }, val);
          },
          get: function get$$1() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function get$$1() {
            return new DOMIterator(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]);
        return Mark3;
      }();
      function Mark2(ctx) {
        var _this = this;
        var instance = new Mark$1(ctx);
        this.mark = function(sv, opt) {
          instance.mark(sv, opt);
          return _this;
        };
        this.markRegExp = function(sv, opt) {
          instance.markRegExp(sv, opt);
          return _this;
        };
        this.markRanges = function(sv, opt) {
          instance.markRanges(sv, opt);
          return _this;
        };
        this.unmark = function(opt) {
          instance.unmark(opt);
          return _this;
        };
        return this;
      }
      return Mark2;
    });
  }
});

// node_modules/lunr/lunr.js
var require_lunr = __commonJS({
  "node_modules/lunr/lunr.js"(exports, module) {
    (function() {
      var lunr2 = function(config3) {
        var builder2 = new lunr2.Builder();
        builder2.pipeline.add(
          lunr2.trimmer,
          lunr2.stopWordFilter,
          lunr2.stemmer
        );
        builder2.searchPipeline.add(
          lunr2.stemmer
        );
        config3.call(builder2, builder2);
        return builder2.build();
      };
      lunr2.version = "2.3.9";
      lunr2.utils = {};
      lunr2.utils.warn = /* @__PURE__ */ function(global2) {
        return function(message) {
          if (global2.console && console.warn) {
            console.warn(message);
          }
        };
      }(this);
      lunr2.utils.asString = function(obj) {
        if (obj === void 0 || obj === null) {
          return "";
        } else {
          return obj.toString();
        }
      };
      lunr2.utils.clone = function(obj) {
        if (obj === null || obj === void 0) {
          return obj;
        }
        var clone2 = /* @__PURE__ */ Object.create(null), keys2 = Object.keys(obj);
        for (var i = 0; i < keys2.length; i++) {
          var key2 = keys2[i], val = obj[key2];
          if (Array.isArray(val)) {
            clone2[key2] = val.slice();
            continue;
          }
          if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
            clone2[key2] = val;
            continue;
          }
          throw new TypeError("clone is not deep and does not support nested objects");
        }
        return clone2;
      };
      lunr2.FieldRef = function(docRef, fieldName, stringValue) {
        this.docRef = docRef;
        this.fieldName = fieldName;
        this._stringValue = stringValue;
      };
      lunr2.FieldRef.joiner = "/";
      lunr2.FieldRef.fromString = function(s) {
        var n = s.indexOf(lunr2.FieldRef.joiner);
        if (n === -1) {
          throw "malformed field ref string";
        }
        var fieldRef = s.slice(0, n), docRef = s.slice(n + 1);
        return new lunr2.FieldRef(docRef, fieldRef, s);
      };
      lunr2.FieldRef.prototype.toString = function() {
        if (this._stringValue == void 0) {
          this._stringValue = this.fieldName + lunr2.FieldRef.joiner + this.docRef;
        }
        return this._stringValue;
      };
      lunr2.Set = function(elements) {
        this.elements = /* @__PURE__ */ Object.create(null);
        if (elements) {
          this.length = elements.length;
          for (var i = 0; i < this.length; i++) {
            this.elements[elements[i]] = true;
          }
        } else {
          this.length = 0;
        }
      };
      lunr2.Set.complete = {
        intersect: function(other) {
          return other;
        },
        union: function() {
          return this;
        },
        contains: function() {
          return true;
        }
      };
      lunr2.Set.empty = {
        intersect: function() {
          return this;
        },
        union: function(other) {
          return other;
        },
        contains: function() {
          return false;
        }
      };
      lunr2.Set.prototype.contains = function(object) {
        return !!this.elements[object];
      };
      lunr2.Set.prototype.intersect = function(other) {
        var a, b, elements, intersection = [];
        if (other === lunr2.Set.complete) {
          return this;
        }
        if (other === lunr2.Set.empty) {
          return other;
        }
        if (this.length < other.length) {
          a = this;
          b = other;
        } else {
          a = other;
          b = this;
        }
        elements = Object.keys(a.elements);
        for (var i = 0; i < elements.length; i++) {
          var element = elements[i];
          if (element in b.elements) {
            intersection.push(element);
          }
        }
        return new lunr2.Set(intersection);
      };
      lunr2.Set.prototype.union = function(other) {
        if (other === lunr2.Set.complete) {
          return lunr2.Set.complete;
        }
        if (other === lunr2.Set.empty) {
          return this;
        }
        return new lunr2.Set(Object.keys(this.elements).concat(Object.keys(other.elements)));
      };
      lunr2.idf = function(posting, documentCount) {
        var documentsWithTerm = 0;
        for (var fieldName in posting) {
          if (fieldName == "_index") continue;
          documentsWithTerm += Object.keys(posting[fieldName]).length;
        }
        var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5);
        return Math.log(1 + Math.abs(x));
      };
      lunr2.Token = function(str, metadata) {
        this.str = str || "";
        this.metadata = metadata || {};
      };
      lunr2.Token.prototype.toString = function() {
        return this.str;
      };
      lunr2.Token.prototype.update = function(fn) {
        this.str = fn(this.str, this.metadata);
        return this;
      };
      lunr2.Token.prototype.clone = function(fn) {
        fn = fn || function(s) {
          return s;
        };
        return new lunr2.Token(fn(this.str, this.metadata), this.metadata);
      };
      lunr2.tokenizer = function(obj, metadata) {
        if (obj == null || obj == void 0) {
          return [];
        }
        if (Array.isArray(obj)) {
          return obj.map(function(t2) {
            return new lunr2.Token(
              lunr2.utils.asString(t2).toLowerCase(),
              lunr2.utils.clone(metadata)
            );
          });
        }
        var str = obj.toString().toLowerCase(), len = str.length, tokens = [];
        for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
          var char = str.charAt(sliceEnd), sliceLength = sliceEnd - sliceStart;
          if (char.match(lunr2.tokenizer.separator) || sliceEnd == len) {
            if (sliceLength > 0) {
              var tokenMetadata = lunr2.utils.clone(metadata) || {};
              tokenMetadata["position"] = [sliceStart, sliceLength];
              tokenMetadata["index"] = tokens.length;
              tokens.push(
                new lunr2.Token(
                  str.slice(sliceStart, sliceEnd),
                  tokenMetadata
                )
              );
            }
            sliceStart = sliceEnd + 1;
          }
        }
        return tokens;
      };
      lunr2.tokenizer.separator = /[\s\-]+/;
      lunr2.Pipeline = function() {
        this._stack = [];
      };
      lunr2.Pipeline.registeredFunctions = /* @__PURE__ */ Object.create(null);
      lunr2.Pipeline.registerFunction = function(fn, label) {
        if (label in this.registeredFunctions) {
          lunr2.utils.warn("Overwriting existing registered function: " + label);
        }
        fn.label = label;
        lunr2.Pipeline.registeredFunctions[fn.label] = fn;
      };
      lunr2.Pipeline.warnIfFunctionNotRegistered = function(fn) {
        var isRegistered = fn.label && fn.label in this.registeredFunctions;
        if (!isRegistered) {
          lunr2.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n", fn);
        }
      };
      lunr2.Pipeline.load = function(serialised) {
        var pipeline = new lunr2.Pipeline();
        serialised.forEach(function(fnName) {
          var fn = lunr2.Pipeline.registeredFunctions[fnName];
          if (fn) {
            pipeline.add(fn);
          } else {
            throw new Error("Cannot load unregistered function: " + fnName);
          }
        });
        return pipeline;
      };
      lunr2.Pipeline.prototype.add = function() {
        var fns = Array.prototype.slice.call(arguments);
        fns.forEach(function(fn) {
          lunr2.Pipeline.warnIfFunctionNotRegistered(fn);
          this._stack.push(fn);
        }, this);
      };
      lunr2.Pipeline.prototype.after = function(existingFn, newFn) {
        lunr2.Pipeline.warnIfFunctionNotRegistered(newFn);
        var pos = this._stack.indexOf(existingFn);
        if (pos == -1) {
          throw new Error("Cannot find existingFn");
        }
        pos = pos + 1;
        this._stack.splice(pos, 0, newFn);
      };
      lunr2.Pipeline.prototype.before = function(existingFn, newFn) {
        lunr2.Pipeline.warnIfFunctionNotRegistered(newFn);
        var pos = this._stack.indexOf(existingFn);
        if (pos == -1) {
          throw new Error("Cannot find existingFn");
        }
        this._stack.splice(pos, 0, newFn);
      };
      lunr2.Pipeline.prototype.remove = function(fn) {
        var pos = this._stack.indexOf(fn);
        if (pos == -1) {
          return;
        }
        this._stack.splice(pos, 1);
      };
      lunr2.Pipeline.prototype.run = function(tokens) {
        var stackLength = this._stack.length;
        for (var i = 0; i < stackLength; i++) {
          var fn = this._stack[i];
          var memo = [];
          for (var j = 0; j < tokens.length; j++) {
            var result = fn(tokens[j], j, tokens);
            if (result === null || result === void 0 || result === "") continue;
            if (Array.isArray(result)) {
              for (var k = 0; k < result.length; k++) {
                memo.push(result[k]);
              }
            } else {
              memo.push(result);
            }
          }
          tokens = memo;
        }
        return tokens;
      };
      lunr2.Pipeline.prototype.runString = function(str, metadata) {
        var token = new lunr2.Token(str, metadata);
        return this.run([token]).map(function(t2) {
          return t2.toString();
        });
      };
      lunr2.Pipeline.prototype.reset = function() {
        this._stack = [];
      };
      lunr2.Pipeline.prototype.toJSON = function() {
        return this._stack.map(function(fn) {
          lunr2.Pipeline.warnIfFunctionNotRegistered(fn);
          return fn.label;
        });
      };
      lunr2.Vector = function(elements) {
        this._magnitude = 0;
        this.elements = elements || [];
      };
      lunr2.Vector.prototype.positionForIndex = function(index2) {
        if (this.elements.length == 0) {
          return 0;
        }
        var start = 0, end = this.elements.length / 2, sliceLength = end - start, pivotPoint = Math.floor(sliceLength / 2), pivotIndex = this.elements[pivotPoint * 2];
        while (sliceLength > 1) {
          if (pivotIndex < index2) {
            start = pivotPoint;
          }
          if (pivotIndex > index2) {
            end = pivotPoint;
          }
          if (pivotIndex == index2) {
            break;
          }
          sliceLength = end - start;
          pivotPoint = start + Math.floor(sliceLength / 2);
          pivotIndex = this.elements[pivotPoint * 2];
        }
        if (pivotIndex == index2) {
          return pivotPoint * 2;
        }
        if (pivotIndex > index2) {
          return pivotPoint * 2;
        }
        if (pivotIndex < index2) {
          return (pivotPoint + 1) * 2;
        }
      };
      lunr2.Vector.prototype.insert = function(insertIdx, val) {
        this.upsert(insertIdx, val, function() {
          throw "duplicate index";
        });
      };
      lunr2.Vector.prototype.upsert = function(insertIdx, val, fn) {
        this._magnitude = 0;
        var position = this.positionForIndex(insertIdx);
        if (this.elements[position] == insertIdx) {
          this.elements[position + 1] = fn(this.elements[position + 1], val);
        } else {
          this.elements.splice(position, 0, insertIdx, val);
        }
      };
      lunr2.Vector.prototype.magnitude = function() {
        if (this._magnitude) return this._magnitude;
        var sumOfSquares = 0, elementsLength = this.elements.length;
        for (var i = 1; i < elementsLength; i += 2) {
          var val = this.elements[i];
          sumOfSquares += val * val;
        }
        return this._magnitude = Math.sqrt(sumOfSquares);
      };
      lunr2.Vector.prototype.dot = function(otherVector) {
        var dotProduct = 0, a = this.elements, b = otherVector.elements, aLen = a.length, bLen = b.length, aVal = 0, bVal = 0, i = 0, j = 0;
        while (i < aLen && j < bLen) {
          aVal = a[i], bVal = b[j];
          if (aVal < bVal) {
            i += 2;
          } else if (aVal > bVal) {
            j += 2;
          } else if (aVal == bVal) {
            dotProduct += a[i + 1] * b[j + 1];
            i += 2;
            j += 2;
          }
        }
        return dotProduct;
      };
      lunr2.Vector.prototype.similarity = function(otherVector) {
        return this.dot(otherVector) / this.magnitude() || 0;
      };
      lunr2.Vector.prototype.toArray = function() {
        var output = new Array(this.elements.length / 2);
        for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
          output[j] = this.elements[i];
        }
        return output;
      };
      lunr2.Vector.prototype.toJSON = function() {
        return this.elements;
      };
      lunr2.stemmer = function() {
        var step2list = {
          "ational": "ate",
          "tional": "tion",
          "enci": "ence",
          "anci": "ance",
          "izer": "ize",
          "bli": "ble",
          "alli": "al",
          "entli": "ent",
          "eli": "e",
          "ousli": "ous",
          "ization": "ize",
          "ation": "ate",
          "ator": "ate",
          "alism": "al",
          "iveness": "ive",
          "fulness": "ful",
          "ousness": "ous",
          "aliti": "al",
          "iviti": "ive",
          "biliti": "ble",
          "logi": "log"
        }, step3list = {
          "icate": "ic",
          "ative": "",
          "alize": "al",
          "iciti": "ic",
          "ical": "ic",
          "ful": "",
          "ness": ""
        }, c = "[^aeiou]", v = "[aeiouy]", C2 = c + "[^aeiouy]*", V = v + "[aeiou]*", mgr0 = "^(" + C2 + ")?" + V + C2, meq1 = "^(" + C2 + ")?" + V + C2 + "(" + V + ")?$", mgr1 = "^(" + C2 + ")?" + V + C2 + V + C2, s_v = "^(" + C2 + ")?" + v;
        var re_mgr0 = new RegExp(mgr0);
        var re_mgr1 = new RegExp(mgr1);
        var re_meq1 = new RegExp(meq1);
        var re_s_v = new RegExp(s_v);
        var re_1a = /^(.+?)(ss|i)es$/;
        var re2_1a = /^(.+?)([^s])s$/;
        var re_1b = /^(.+?)eed$/;
        var re2_1b = /^(.+?)(ed|ing)$/;
        var re_1b_2 = /.$/;
        var re2_1b_2 = /(at|bl|iz)$/;
        var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
        var re4_1b_2 = new RegExp("^" + C2 + v + "[^aeiouwxy]$");
        var re_1c = /^(.+?[^aeiou])y$/;
        var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
        var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
        var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
        var re2_4 = /^(.+?)(s|t)(ion)$/;
        var re_5 = /^(.+?)e$/;
        var re_5_1 = /ll$/;
        var re3_5 = new RegExp("^" + C2 + v + "[^aeiouwxy]$");
        var porterStemmer = function porterStemmer2(w) {
          var stem, suffix, firstch, re, re2, re3, re4;
          if (w.length < 3) {
            return w;
          }
          firstch = w.substr(0, 1);
          if (firstch == "y") {
            w = firstch.toUpperCase() + w.substr(1);
          }
          re = re_1a;
          re2 = re2_1a;
          if (re.test(w)) {
            w = w.replace(re, "$1$2");
          } else if (re2.test(w)) {
            w = w.replace(re2, "$1$2");
          }
          re = re_1b;
          re2 = re2_1b;
          if (re.test(w)) {
            var fp = re.exec(w);
            re = re_mgr0;
            if (re.test(fp[1])) {
              re = re_1b_2;
              w = w.replace(re, "");
            }
          } else if (re2.test(w)) {
            var fp = re2.exec(w);
            stem = fp[1];
            re2 = re_s_v;
            if (re2.test(stem)) {
              w = stem;
              re2 = re2_1b_2;
              re3 = re3_1b_2;
              re4 = re4_1b_2;
              if (re2.test(w)) {
                w = w + "e";
              } else if (re3.test(w)) {
                re = re_1b_2;
                w = w.replace(re, "");
              } else if (re4.test(w)) {
                w = w + "e";
              }
            }
          }
          re = re_1c;
          if (re.test(w)) {
            var fp = re.exec(w);
            stem = fp[1];
            w = stem + "i";
          }
          re = re_2;
          if (re.test(w)) {
            var fp = re.exec(w);
            stem = fp[1];
            suffix = fp[2];
            re = re_mgr0;
            if (re.test(stem)) {
              w = stem + step2list[suffix];
            }
          }
          re = re_3;
          if (re.test(w)) {
            var fp = re.exec(w);
            stem = fp[1];
            suffix = fp[2];
            re = re_mgr0;
            if (re.test(stem)) {
              w = stem + step3list[suffix];
            }
          }
          re = re_4;
          re2 = re2_4;
          if (re.test(w)) {
            var fp = re.exec(w);
            stem = fp[1];
            re = re_mgr1;
            if (re.test(stem)) {
              w = stem;
            }
          } else if (re2.test(w)) {
            var fp = re2.exec(w);
            stem = fp[1] + fp[2];
            re2 = re_mgr1;
            if (re2.test(stem)) {
              w = stem;
            }
          }
          re = re_5;
          if (re.test(w)) {
            var fp = re.exec(w);
            stem = fp[1];
            re = re_mgr1;
            re2 = re_meq1;
            re3 = re3_5;
            if (re.test(stem) || re2.test(stem) && !re3.test(stem)) {
              w = stem;
            }
          }
          re = re_5_1;
          re2 = re_mgr1;
          if (re.test(w) && re2.test(w)) {
            re = re_1b_2;
            w = w.replace(re, "");
          }
          if (firstch == "y") {
            w = firstch.toLowerCase() + w.substr(1);
          }
          return w;
        };
        return function(token) {
          return token.update(porterStemmer);
        };
      }();
      lunr2.Pipeline.registerFunction(lunr2.stemmer, "stemmer");
      lunr2.generateStopWordFilter = function(stopWords) {
        var words = stopWords.reduce(function(memo, stopWord) {
          memo[stopWord] = stopWord;
          return memo;
        }, {});
        return function(token) {
          if (token && words[token.toString()] !== token.toString()) return token;
        };
      };
      lunr2.stopWordFilter = lunr2.generateStopWordFilter([
        "a",
        "able",
        "about",
        "across",
        "after",
        "all",
        "almost",
        "also",
        "am",
        "among",
        "an",
        "and",
        "any",
        "are",
        "as",
        "at",
        "be",
        "because",
        "been",
        "but",
        "by",
        "can",
        "cannot",
        "could",
        "dear",
        "did",
        "do",
        "does",
        "either",
        "else",
        "ever",
        "every",
        "for",
        "from",
        "get",
        "got",
        "had",
        "has",
        "have",
        "he",
        "her",
        "hers",
        "him",
        "his",
        "how",
        "however",
        "i",
        "if",
        "in",
        "into",
        "is",
        "it",
        "its",
        "just",
        "least",
        "let",
        "like",
        "likely",
        "may",
        "me",
        "might",
        "most",
        "must",
        "my",
        "neither",
        "no",
        "nor",
        "not",
        "of",
        "off",
        "often",
        "on",
        "only",
        "or",
        "other",
        "our",
        "own",
        "rather",
        "said",
        "say",
        "says",
        "she",
        "should",
        "since",
        "so",
        "some",
        "than",
        "that",
        "the",
        "their",
        "them",
        "then",
        "there",
        "these",
        "they",
        "this",
        "tis",
        "to",
        "too",
        "twas",
        "us",
        "wants",
        "was",
        "we",
        "were",
        "what",
        "when",
        "where",
        "which",
        "while",
        "who",
        "whom",
        "why",
        "will",
        "with",
        "would",
        "yet",
        "you",
        "your"
      ]);
      lunr2.Pipeline.registerFunction(lunr2.stopWordFilter, "stopWordFilter");
      lunr2.trimmer = function(token) {
        return token.update(function(s) {
          return s.replace(/^\W+/, "").replace(/\W+$/, "");
        });
      };
      lunr2.Pipeline.registerFunction(lunr2.trimmer, "trimmer");
      lunr2.TokenSet = function() {
        this.final = false;
        this.edges = {};
        this.id = lunr2.TokenSet._nextId;
        lunr2.TokenSet._nextId += 1;
      };
      lunr2.TokenSet._nextId = 1;
      lunr2.TokenSet.fromArray = function(arr) {
        var builder2 = new lunr2.TokenSet.Builder();
        for (var i = 0, len = arr.length; i < len; i++) {
          builder2.insert(arr[i]);
        }
        builder2.finish();
        return builder2.root;
      };
      lunr2.TokenSet.fromClause = function(clause) {
        if ("editDistance" in clause) {
          return lunr2.TokenSet.fromFuzzyString(clause.term, clause.editDistance);
        } else {
          return lunr2.TokenSet.fromString(clause.term);
        }
      };
      lunr2.TokenSet.fromFuzzyString = function(str, editDistance) {
        var root = new lunr2.TokenSet();
        var stack = [{
          node: root,
          editsRemaining: editDistance,
          str
        }];
        while (stack.length) {
          var frame = stack.pop();
          if (frame.str.length > 0) {
            var char = frame.str.charAt(0), noEditNode;
            if (char in frame.node.edges) {
              noEditNode = frame.node.edges[char];
            } else {
              noEditNode = new lunr2.TokenSet();
              frame.node.edges[char] = noEditNode;
            }
            if (frame.str.length == 1) {
              noEditNode.final = true;
            }
            stack.push({
              node: noEditNode,
              editsRemaining: frame.editsRemaining,
              str: frame.str.slice(1)
            });
          }
          if (frame.editsRemaining == 0) {
            continue;
          }
          if ("*" in frame.node.edges) {
            var insertionNode = frame.node.edges["*"];
          } else {
            var insertionNode = new lunr2.TokenSet();
            frame.node.edges["*"] = insertionNode;
          }
          if (frame.str.length == 0) {
            insertionNode.final = true;
          }
          stack.push({
            node: insertionNode,
            editsRemaining: frame.editsRemaining - 1,
            str: frame.str
          });
          if (frame.str.length > 1) {
            stack.push({
              node: frame.node,
              editsRemaining: frame.editsRemaining - 1,
              str: frame.str.slice(1)
            });
          }
          if (frame.str.length == 1) {
            frame.node.final = true;
          }
          if (frame.str.length >= 1) {
            if ("*" in frame.node.edges) {
              var substitutionNode = frame.node.edges["*"];
            } else {
              var substitutionNode = new lunr2.TokenSet();
              frame.node.edges["*"] = substitutionNode;
            }
            if (frame.str.length == 1) {
              substitutionNode.final = true;
            }
            stack.push({
              node: substitutionNode,
              editsRemaining: frame.editsRemaining - 1,
              str: frame.str.slice(1)
            });
          }
          if (frame.str.length > 1) {
            var charA = frame.str.charAt(0), charB = frame.str.charAt(1), transposeNode;
            if (charB in frame.node.edges) {
              transposeNode = frame.node.edges[charB];
            } else {
              transposeNode = new lunr2.TokenSet();
              frame.node.edges[charB] = transposeNode;
            }
            if (frame.str.length == 1) {
              transposeNode.final = true;
            }
            stack.push({
              node: transposeNode,
              editsRemaining: frame.editsRemaining - 1,
              str: charA + frame.str.slice(2)
            });
          }
        }
        return root;
      };
      lunr2.TokenSet.fromString = function(str) {
        var node = new lunr2.TokenSet(), root = node;
        for (var i = 0, len = str.length; i < len; i++) {
          var char = str[i], final = i == len - 1;
          if (char == "*") {
            node.edges[char] = node;
            node.final = final;
          } else {
            var next = new lunr2.TokenSet();
            next.final = final;
            node.edges[char] = next;
            node = next;
          }
        }
        return root;
      };
      lunr2.TokenSet.prototype.toArray = function() {
        var words = [];
        var stack = [{
          prefix: "",
          node: this
        }];
        while (stack.length) {
          var frame = stack.pop(), edges = Object.keys(frame.node.edges), len = edges.length;
          if (frame.node.final) {
            frame.prefix.charAt(0);
            words.push(frame.prefix);
          }
          for (var i = 0; i < len; i++) {
            var edge = edges[i];
            stack.push({
              prefix: frame.prefix.concat(edge),
              node: frame.node.edges[edge]
            });
          }
        }
        return words;
      };
      lunr2.TokenSet.prototype.toString = function() {
        if (this._str) {
          return this._str;
        }
        var str = this.final ? "1" : "0", labels2 = Object.keys(this.edges).sort(), len = labels2.length;
        for (var i = 0; i < len; i++) {
          var label = labels2[i], node = this.edges[label];
          str = str + label + node.id;
        }
        return str;
      };
      lunr2.TokenSet.prototype.intersect = function(b) {
        var output = new lunr2.TokenSet(), frame = void 0;
        var stack = [{
          qNode: b,
          output,
          node: this
        }];
        while (stack.length) {
          frame = stack.pop();
          var qEdges = Object.keys(frame.qNode.edges), qLen = qEdges.length, nEdges = Object.keys(frame.node.edges), nLen = nEdges.length;
          for (var q = 0; q < qLen; q++) {
            var qEdge = qEdges[q];
            for (var n = 0; n < nLen; n++) {
              var nEdge = nEdges[n];
              if (nEdge == qEdge || qEdge == "*") {
                var node = frame.node.edges[nEdge], qNode = frame.qNode.edges[qEdge], final = node.final && qNode.final, next = void 0;
                if (nEdge in frame.output.edges) {
                  next = frame.output.edges[nEdge];
                  next.final = next.final || final;
                } else {
                  next = new lunr2.TokenSet();
                  next.final = final;
                  frame.output.edges[nEdge] = next;
                }
                stack.push({
                  qNode,
                  output: next,
                  node
                });
              }
            }
          }
        }
        return output;
      };
      lunr2.TokenSet.Builder = function() {
        this.previousWord = "";
        this.root = new lunr2.TokenSet();
        this.uncheckedNodes = [];
        this.minimizedNodes = {};
      };
      lunr2.TokenSet.Builder.prototype.insert = function(word) {
        var node, commonPrefix = 0;
        if (word < this.previousWord) {
          throw new Error("Out of order word insertion");
        }
        for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
          if (word[i] != this.previousWord[i]) break;
          commonPrefix++;
        }
        this.minimize(commonPrefix);
        if (this.uncheckedNodes.length == 0) {
          node = this.root;
        } else {
          node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child;
        }
        for (var i = commonPrefix; i < word.length; i++) {
          var nextNode = new lunr2.TokenSet(), char = word[i];
          node.edges[char] = nextNode;
          this.uncheckedNodes.push({
            parent: node,
            char,
            child: nextNode
          });
          node = nextNode;
        }
        node.final = true;
        this.previousWord = word;
      };
      lunr2.TokenSet.Builder.prototype.finish = function() {
        this.minimize(0);
      };
      lunr2.TokenSet.Builder.prototype.minimize = function(downTo) {
        for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
          var node = this.uncheckedNodes[i], childKey = node.child.toString();
          if (childKey in this.minimizedNodes) {
            node.parent.edges[node.char] = this.minimizedNodes[childKey];
          } else {
            node.child._str = childKey;
            this.minimizedNodes[childKey] = node.child;
          }
          this.uncheckedNodes.pop();
        }
      };
      lunr2.Index = function(attrs) {
        this.invertedIndex = attrs.invertedIndex;
        this.fieldVectors = attrs.fieldVectors;
        this.tokenSet = attrs.tokenSet;
        this.fields = attrs.fields;
        this.pipeline = attrs.pipeline;
      };
      lunr2.Index.prototype.search = function(queryString) {
        return this.query(function(query) {
          var parser3 = new lunr2.QueryParser(queryString, query);
          parser3.parse();
        });
      };
      lunr2.Index.prototype.query = function(fn) {
        var query = new lunr2.Query(this.fields), matchingFields = /* @__PURE__ */ Object.create(null), queryVectors = /* @__PURE__ */ Object.create(null), termFieldCache = /* @__PURE__ */ Object.create(null), requiredMatches = /* @__PURE__ */ Object.create(null), prohibitedMatches = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < this.fields.length; i++) {
          queryVectors[this.fields[i]] = new lunr2.Vector();
        }
        fn.call(query, query);
        for (var i = 0; i < query.clauses.length; i++) {
          var clause = query.clauses[i], terms = null, clauseMatches = lunr2.Set.empty;
          if (clause.usePipeline) {
            terms = this.pipeline.runString(clause.term, {
              fields: clause.fields
            });
          } else {
            terms = [clause.term];
          }
          for (var m = 0; m < terms.length; m++) {
            var term = terms[m];
            clause.term = term;
            var termTokenSet = lunr2.TokenSet.fromClause(clause), expandedTerms = this.tokenSet.intersect(termTokenSet).toArray();
            if (expandedTerms.length === 0 && clause.presence === lunr2.Query.presence.REQUIRED) {
              for (var k = 0; k < clause.fields.length; k++) {
                var field = clause.fields[k];
                requiredMatches[field] = lunr2.Set.empty;
              }
              break;
            }
            for (var j = 0; j < expandedTerms.length; j++) {
              var expandedTerm = expandedTerms[j], posting = this.invertedIndex[expandedTerm], termIndex = posting._index;
              for (var k = 0; k < clause.fields.length; k++) {
                var field = clause.fields[k], fieldPosting = posting[field], matchingDocumentRefs = Object.keys(fieldPosting), termField = expandedTerm + "/" + field, matchingDocumentsSet = new lunr2.Set(matchingDocumentRefs);
                if (clause.presence == lunr2.Query.presence.REQUIRED) {
                  clauseMatches = clauseMatches.union(matchingDocumentsSet);
                  if (requiredMatches[field] === void 0) {
                    requiredMatches[field] = lunr2.Set.complete;
                  }
                }
                if (clause.presence == lunr2.Query.presence.PROHIBITED) {
                  if (prohibitedMatches[field] === void 0) {
                    prohibitedMatches[field] = lunr2.Set.empty;
                  }
                  prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet);
                  continue;
                }
                queryVectors[field].upsert(termIndex, clause.boost, function(a, b) {
                  return a + b;
                });
                if (termFieldCache[termField]) {
                  continue;
                }
                for (var l2 = 0; l2 < matchingDocumentRefs.length; l2++) {
                  var matchingDocumentRef = matchingDocumentRefs[l2], matchingFieldRef = new lunr2.FieldRef(matchingDocumentRef, field), metadata = fieldPosting[matchingDocumentRef], fieldMatch;
                  if ((fieldMatch = matchingFields[matchingFieldRef]) === void 0) {
                    matchingFields[matchingFieldRef] = new lunr2.MatchData(expandedTerm, field, metadata);
                  } else {
                    fieldMatch.add(expandedTerm, field, metadata);
                  }
                }
                termFieldCache[termField] = true;
              }
            }
          }
          if (clause.presence === lunr2.Query.presence.REQUIRED) {
            for (var k = 0; k < clause.fields.length; k++) {
              var field = clause.fields[k];
              requiredMatches[field] = requiredMatches[field].intersect(clauseMatches);
            }
          }
        }
        var allRequiredMatches = lunr2.Set.complete, allProhibitedMatches = lunr2.Set.empty;
        for (var i = 0; i < this.fields.length; i++) {
          var field = this.fields[i];
          if (requiredMatches[field]) {
            allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field]);
          }
          if (prohibitedMatches[field]) {
            allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field]);
          }
        }
        var matchingFieldRefs = Object.keys(matchingFields), results = [], matches = /* @__PURE__ */ Object.create(null);
        if (query.isNegated()) {
          matchingFieldRefs = Object.keys(this.fieldVectors);
          for (var i = 0; i < matchingFieldRefs.length; i++) {
            var matchingFieldRef = matchingFieldRefs[i];
            var fieldRef = lunr2.FieldRef.fromString(matchingFieldRef);
            matchingFields[matchingFieldRef] = new lunr2.MatchData();
          }
        }
        for (var i = 0; i < matchingFieldRefs.length; i++) {
          var fieldRef = lunr2.FieldRef.fromString(matchingFieldRefs[i]), docRef = fieldRef.docRef;
          if (!allRequiredMatches.contains(docRef)) {
            continue;
          }
          if (allProhibitedMatches.contains(docRef)) {
            continue;
          }
          var fieldVector = this.fieldVectors[fieldRef], score2 = queryVectors[fieldRef.fieldName].similarity(fieldVector), docMatch;
          if ((docMatch = matches[docRef]) !== void 0) {
            docMatch.score += score2;
            docMatch.matchData.combine(matchingFields[fieldRef]);
          } else {
            var match = {
              ref: docRef,
              score: score2,
              matchData: matchingFields[fieldRef]
            };
            matches[docRef] = match;
            results.push(match);
          }
        }
        return results.sort(function(a, b) {
          return b.score - a.score;
        });
      };
      lunr2.Index.prototype.toJSON = function() {
        var invertedIndex = Object.keys(this.invertedIndex).sort().map(function(term) {
          return [term, this.invertedIndex[term]];
        }, this);
        var fieldVectors = Object.keys(this.fieldVectors).map(function(ref) {
          return [ref, this.fieldVectors[ref].toJSON()];
        }, this);
        return {
          version: lunr2.version,
          fields: this.fields,
          fieldVectors,
          invertedIndex,
          pipeline: this.pipeline.toJSON()
        };
      };
      lunr2.Index.load = function(serializedIndex) {
        var attrs = {}, fieldVectors = {}, serializedVectors = serializedIndex.fieldVectors, invertedIndex = /* @__PURE__ */ Object.create(null), serializedInvertedIndex = serializedIndex.invertedIndex, tokenSetBuilder = new lunr2.TokenSet.Builder(), pipeline = lunr2.Pipeline.load(serializedIndex.pipeline);
        if (serializedIndex.version != lunr2.version) {
          lunr2.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + lunr2.version + "' does not match serialized index '" + serializedIndex.version + "'");
        }
        for (var i = 0; i < serializedVectors.length; i++) {
          var tuple = serializedVectors[i], ref = tuple[0], elements = tuple[1];
          fieldVectors[ref] = new lunr2.Vector(elements);
        }
        for (var i = 0; i < serializedInvertedIndex.length; i++) {
          var tuple = serializedInvertedIndex[i], term = tuple[0], posting = tuple[1];
          tokenSetBuilder.insert(term);
          invertedIndex[term] = posting;
        }
        tokenSetBuilder.finish();
        attrs.fields = serializedIndex.fields;
        attrs.fieldVectors = fieldVectors;
        attrs.invertedIndex = invertedIndex;
        attrs.tokenSet = tokenSetBuilder.root;
        attrs.pipeline = pipeline;
        return new lunr2.Index(attrs);
      };
      lunr2.Builder = function() {
        this._ref = "id";
        this._fields = /* @__PURE__ */ Object.create(null);
        this._documents = /* @__PURE__ */ Object.create(null);
        this.invertedIndex = /* @__PURE__ */ Object.create(null);
        this.fieldTermFrequencies = {};
        this.fieldLengths = {};
        this.tokenizer = lunr2.tokenizer;
        this.pipeline = new lunr2.Pipeline();
        this.searchPipeline = new lunr2.Pipeline();
        this.documentCount = 0;
        this._b = 0.75;
        this._k1 = 1.2;
        this.termIndex = 0;
        this.metadataWhitelist = [];
      };
      lunr2.Builder.prototype.ref = function(ref) {
        this._ref = ref;
      };
      lunr2.Builder.prototype.field = function(fieldName, attributes) {
        if (/\//.test(fieldName)) {
          throw new RangeError("Field '" + fieldName + "' contains illegal character '/'");
        }
        this._fields[fieldName] = attributes || {};
      };
      lunr2.Builder.prototype.b = function(number2) {
        if (number2 < 0) {
          this._b = 0;
        } else if (number2 > 1) {
          this._b = 1;
        } else {
          this._b = number2;
        }
      };
      lunr2.Builder.prototype.k1 = function(number2) {
        this._k1 = number2;
      };
      lunr2.Builder.prototype.add = function(doc2, attributes) {
        var docRef = doc2[this._ref], fields = Object.keys(this._fields);
        this._documents[docRef] = attributes || {};
        this.documentCount += 1;
        for (var i = 0; i < fields.length; i++) {
          var fieldName = fields[i], extractor = this._fields[fieldName].extractor, field = extractor ? extractor(doc2) : doc2[fieldName], tokens = this.tokenizer(field, {
            fields: [fieldName]
          }), terms = this.pipeline.run(tokens), fieldRef = new lunr2.FieldRef(docRef, fieldName), fieldTerms = /* @__PURE__ */ Object.create(null);
          this.fieldTermFrequencies[fieldRef] = fieldTerms;
          this.fieldLengths[fieldRef] = 0;
          this.fieldLengths[fieldRef] += terms.length;
          for (var j = 0; j < terms.length; j++) {
            var term = terms[j];
            if (fieldTerms[term] == void 0) {
              fieldTerms[term] = 0;
            }
            fieldTerms[term] += 1;
            if (this.invertedIndex[term] == void 0) {
              var posting = /* @__PURE__ */ Object.create(null);
              posting["_index"] = this.termIndex;
              this.termIndex += 1;
              for (var k = 0; k < fields.length; k++) {
                posting[fields[k]] = /* @__PURE__ */ Object.create(null);
              }
              this.invertedIndex[term] = posting;
            }
            if (this.invertedIndex[term][fieldName][docRef] == void 0) {
              this.invertedIndex[term][fieldName][docRef] = /* @__PURE__ */ Object.create(null);
            }
            for (var l2 = 0; l2 < this.metadataWhitelist.length; l2++) {
              var metadataKey = this.metadataWhitelist[l2], metadata = term.metadata[metadataKey];
              if (this.invertedIndex[term][fieldName][docRef][metadataKey] == void 0) {
                this.invertedIndex[term][fieldName][docRef][metadataKey] = [];
              }
              this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata);
            }
          }
        }
      };
      lunr2.Builder.prototype.calculateAverageFieldLengths = function() {
        var fieldRefs = Object.keys(this.fieldLengths), numberOfFields = fieldRefs.length, accumulator = {}, documentsWithField = {};
        for (var i = 0; i < numberOfFields; i++) {
          var fieldRef = lunr2.FieldRef.fromString(fieldRefs[i]), field = fieldRef.fieldName;
          documentsWithField[field] || (documentsWithField[field] = 0);
          documentsWithField[field] += 1;
          accumulator[field] || (accumulator[field] = 0);
          accumulator[field] += this.fieldLengths[fieldRef];
        }
        var fields = Object.keys(this._fields);
        for (var i = 0; i < fields.length; i++) {
          var fieldName = fields[i];
          accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName];
        }
        this.averageFieldLength = accumulator;
      };
      lunr2.Builder.prototype.createFieldVectors = function() {
        var fieldVectors = {}, fieldRefs = Object.keys(this.fieldTermFrequencies), fieldRefsLength = fieldRefs.length, termIdfCache = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < fieldRefsLength; i++) {
          var fieldRef = lunr2.FieldRef.fromString(fieldRefs[i]), fieldName = fieldRef.fieldName, fieldLength = this.fieldLengths[fieldRef], fieldVector = new lunr2.Vector(), termFrequencies = this.fieldTermFrequencies[fieldRef], terms = Object.keys(termFrequencies), termsLength = terms.length;
          var fieldBoost = this._fields[fieldName].boost || 1, docBoost = this._documents[fieldRef.docRef].boost || 1;
          for (var j = 0; j < termsLength; j++) {
            var term = terms[j], tf = termFrequencies[term], termIndex = this.invertedIndex[term]._index, idf, score2, scoreWithPrecision;
            if (termIdfCache[term] === void 0) {
              idf = lunr2.idf(this.invertedIndex[term], this.documentCount);
              termIdfCache[term] = idf;
            } else {
              idf = termIdfCache[term];
            }
            score2 = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf);
            score2 *= fieldBoost;
            score2 *= docBoost;
            scoreWithPrecision = Math.round(score2 * 1e3) / 1e3;
            fieldVector.insert(termIndex, scoreWithPrecision);
          }
          fieldVectors[fieldRef] = fieldVector;
        }
        this.fieldVectors = fieldVectors;
      };
      lunr2.Builder.prototype.createTokenSet = function() {
        this.tokenSet = lunr2.TokenSet.fromArray(
          Object.keys(this.invertedIndex).sort()
        );
      };
      lunr2.Builder.prototype.build = function() {
        this.calculateAverageFieldLengths();
        this.createFieldVectors();
        this.createTokenSet();
        return new lunr2.Index({
          invertedIndex: this.invertedIndex,
          fieldVectors: this.fieldVectors,
          tokenSet: this.tokenSet,
          fields: Object.keys(this._fields),
          pipeline: this.searchPipeline
        });
      };
      lunr2.Builder.prototype.use = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        args.unshift(this);
        fn.apply(this, args);
      };
      lunr2.MatchData = function(term, field, metadata) {
        var clonedMetadata = /* @__PURE__ */ Object.create(null), metadataKeys = Object.keys(metadata || {});
        for (var i = 0; i < metadataKeys.length; i++) {
          var key2 = metadataKeys[i];
          clonedMetadata[key2] = metadata[key2].slice();
        }
        this.metadata = /* @__PURE__ */ Object.create(null);
        if (term !== void 0) {
          this.metadata[term] = /* @__PURE__ */ Object.create(null);
          this.metadata[term][field] = clonedMetadata;
        }
      };
      lunr2.MatchData.prototype.combine = function(otherMatchData) {
        var terms = Object.keys(otherMatchData.metadata);
        for (var i = 0; i < terms.length; i++) {
          var term = terms[i], fields = Object.keys(otherMatchData.metadata[term]);
          if (this.metadata[term] == void 0) {
            this.metadata[term] = /* @__PURE__ */ Object.create(null);
          }
          for (var j = 0; j < fields.length; j++) {
            var field = fields[j], keys2 = Object.keys(otherMatchData.metadata[term][field]);
            if (this.metadata[term][field] == void 0) {
              this.metadata[term][field] = /* @__PURE__ */ Object.create(null);
            }
            for (var k = 0; k < keys2.length; k++) {
              var key2 = keys2[k];
              if (this.metadata[term][field][key2] == void 0) {
                this.metadata[term][field][key2] = otherMatchData.metadata[term][field][key2];
              } else {
                this.metadata[term][field][key2] = this.metadata[term][field][key2].concat(otherMatchData.metadata[term][field][key2]);
              }
            }
          }
        }
      };
      lunr2.MatchData.prototype.add = function(term, field, metadata) {
        if (!(term in this.metadata)) {
          this.metadata[term] = /* @__PURE__ */ Object.create(null);
          this.metadata[term][field] = metadata;
          return;
        }
        if (!(field in this.metadata[term])) {
          this.metadata[term][field] = metadata;
          return;
        }
        var metadataKeys = Object.keys(metadata);
        for (var i = 0; i < metadataKeys.length; i++) {
          var key2 = metadataKeys[i];
          if (key2 in this.metadata[term][field]) {
            this.metadata[term][field][key2] = this.metadata[term][field][key2].concat(metadata[key2]);
          } else {
            this.metadata[term][field][key2] = metadata[key2];
          }
        }
      };
      lunr2.Query = function(allFields) {
        this.clauses = [];
        this.allFields = allFields;
      };
      lunr2.Query.wildcard = new String("*");
      lunr2.Query.wildcard.NONE = 0;
      lunr2.Query.wildcard.LEADING = 1;
      lunr2.Query.wildcard.TRAILING = 2;
      lunr2.Query.presence = {
        /**
         * Term's presence in a document is optional, this is the default value.
         */
        OPTIONAL: 1,
        /**
         * Term's presence in a document is required, documents that do not contain
         * this term will not be returned.
         */
        REQUIRED: 2,
        /**
         * Term's presence in a document is prohibited, documents that do contain
         * this term will not be returned.
         */
        PROHIBITED: 3
      };
      lunr2.Query.prototype.clause = function(clause) {
        if (!("fields" in clause)) {
          clause.fields = this.allFields;
        }
        if (!("boost" in clause)) {
          clause.boost = 1;
        }
        if (!("usePipeline" in clause)) {
          clause.usePipeline = true;
        }
        if (!("wildcard" in clause)) {
          clause.wildcard = lunr2.Query.wildcard.NONE;
        }
        if (clause.wildcard & lunr2.Query.wildcard.LEADING && clause.term.charAt(0) != lunr2.Query.wildcard) {
          clause.term = "*" + clause.term;
        }
        if (clause.wildcard & lunr2.Query.wildcard.TRAILING && clause.term.slice(-1) != lunr2.Query.wildcard) {
          clause.term = "" + clause.term + "*";
        }
        if (!("presence" in clause)) {
          clause.presence = lunr2.Query.presence.OPTIONAL;
        }
        this.clauses.push(clause);
        return this;
      };
      lunr2.Query.prototype.isNegated = function() {
        for (var i = 0; i < this.clauses.length; i++) {
          if (this.clauses[i].presence != lunr2.Query.presence.PROHIBITED) {
            return false;
          }
        }
        return true;
      };
      lunr2.Query.prototype.term = function(term, options2) {
        if (Array.isArray(term)) {
          term.forEach(function(t2) {
            this.term(t2, lunr2.utils.clone(options2));
          }, this);
          return this;
        }
        var clause = options2 || {};
        clause.term = term.toString();
        this.clause(clause);
        return this;
      };
      lunr2.QueryParseError = function(message, start, end) {
        this.name = "QueryParseError";
        this.message = message;
        this.start = start;
        this.end = end;
      };
      lunr2.QueryParseError.prototype = new Error();
      lunr2.QueryLexer = function(str) {
        this.lexemes = [];
        this.str = str;
        this.length = str.length;
        this.pos = 0;
        this.start = 0;
        this.escapeCharPositions = [];
      };
      lunr2.QueryLexer.prototype.run = function() {
        var state = lunr2.QueryLexer.lexText;
        while (state) {
          state = state(this);
        }
      };
      lunr2.QueryLexer.prototype.sliceString = function() {
        var subSlices = [], sliceStart = this.start, sliceEnd = this.pos;
        for (var i = 0; i < this.escapeCharPositions.length; i++) {
          sliceEnd = this.escapeCharPositions[i];
          subSlices.push(this.str.slice(sliceStart, sliceEnd));
          sliceStart = sliceEnd + 1;
        }
        subSlices.push(this.str.slice(sliceStart, this.pos));
        this.escapeCharPositions.length = 0;
        return subSlices.join("");
      };
      lunr2.QueryLexer.prototype.emit = function(type) {
        this.lexemes.push({
          type,
          str: this.sliceString(),
          start: this.start,
          end: this.pos
        });
        this.start = this.pos;
      };
      lunr2.QueryLexer.prototype.escapeCharacter = function() {
        this.escapeCharPositions.push(this.pos - 1);
        this.pos += 1;
      };
      lunr2.QueryLexer.prototype.next = function() {
        if (this.pos >= this.length) {
          return lunr2.QueryLexer.EOS;
        }
        var char = this.str.charAt(this.pos);
        this.pos += 1;
        return char;
      };
      lunr2.QueryLexer.prototype.width = function() {
        return this.pos - this.start;
      };
      lunr2.QueryLexer.prototype.ignore = function() {
        if (this.start == this.pos) {
          this.pos += 1;
        }
        this.start = this.pos;
      };
      lunr2.QueryLexer.prototype.backup = function() {
        this.pos -= 1;
      };
      lunr2.QueryLexer.prototype.acceptDigitRun = function() {
        var char, charCode;
        do {
          char = this.next();
          charCode = char.charCodeAt(0);
        } while (charCode > 47 && charCode < 58);
        if (char != lunr2.QueryLexer.EOS) {
          this.backup();
        }
      };
      lunr2.QueryLexer.prototype.more = function() {
        return this.pos < this.length;
      };
      lunr2.QueryLexer.EOS = "EOS";
      lunr2.QueryLexer.FIELD = "FIELD";
      lunr2.QueryLexer.TERM = "TERM";
      lunr2.QueryLexer.EDIT_DISTANCE = "EDIT_DISTANCE";
      lunr2.QueryLexer.BOOST = "BOOST";
      lunr2.QueryLexer.PRESENCE = "PRESENCE";
      lunr2.QueryLexer.lexField = function(lexer2) {
        lexer2.backup();
        lexer2.emit(lunr2.QueryLexer.FIELD);
        lexer2.ignore();
        return lunr2.QueryLexer.lexText;
      };
      lunr2.QueryLexer.lexTerm = function(lexer2) {
        if (lexer2.width() > 1) {
          lexer2.backup();
          lexer2.emit(lunr2.QueryLexer.TERM);
        }
        lexer2.ignore();
        if (lexer2.more()) {
          return lunr2.QueryLexer.lexText;
        }
      };
      lunr2.QueryLexer.lexEditDistance = function(lexer2) {
        lexer2.ignore();
        lexer2.acceptDigitRun();
        lexer2.emit(lunr2.QueryLexer.EDIT_DISTANCE);
        return lunr2.QueryLexer.lexText;
      };
      lunr2.QueryLexer.lexBoost = function(lexer2) {
        lexer2.ignore();
        lexer2.acceptDigitRun();
        lexer2.emit(lunr2.QueryLexer.BOOST);
        return lunr2.QueryLexer.lexText;
      };
      lunr2.QueryLexer.lexEOS = function(lexer2) {
        if (lexer2.width() > 0) {
          lexer2.emit(lunr2.QueryLexer.TERM);
        }
      };
      lunr2.QueryLexer.termSeparator = lunr2.tokenizer.separator;
      lunr2.QueryLexer.lexText = function(lexer2) {
        while (true) {
          var char = lexer2.next();
          if (char == lunr2.QueryLexer.EOS) {
            return lunr2.QueryLexer.lexEOS;
          }
          if (char.charCodeAt(0) == 92) {
            lexer2.escapeCharacter();
            continue;
          }
          if (char == ":") {
            return lunr2.QueryLexer.lexField;
          }
          if (char == "~") {
            lexer2.backup();
            if (lexer2.width() > 0) {
              lexer2.emit(lunr2.QueryLexer.TERM);
            }
            return lunr2.QueryLexer.lexEditDistance;
          }
          if (char == "^") {
            lexer2.backup();
            if (lexer2.width() > 0) {
              lexer2.emit(lunr2.QueryLexer.TERM);
            }
            return lunr2.QueryLexer.lexBoost;
          }
          if (char == "+" && lexer2.width() === 1) {
            lexer2.emit(lunr2.QueryLexer.PRESENCE);
            return lunr2.QueryLexer.lexText;
          }
          if (char == "-" && lexer2.width() === 1) {
            lexer2.emit(lunr2.QueryLexer.PRESENCE);
            return lunr2.QueryLexer.lexText;
          }
          if (char.match(lunr2.QueryLexer.termSeparator)) {
            return lunr2.QueryLexer.lexTerm;
          }
        }
      };
      lunr2.QueryParser = function(str, query) {
        this.lexer = new lunr2.QueryLexer(str);
        this.query = query;
        this.currentClause = {};
        this.lexemeIdx = 0;
      };
      lunr2.QueryParser.prototype.parse = function() {
        this.lexer.run();
        this.lexemes = this.lexer.lexemes;
        var state = lunr2.QueryParser.parseClause;
        while (state) {
          state = state(this);
        }
        return this.query;
      };
      lunr2.QueryParser.prototype.peekLexeme = function() {
        return this.lexemes[this.lexemeIdx];
      };
      lunr2.QueryParser.prototype.consumeLexeme = function() {
        var lexeme = this.peekLexeme();
        this.lexemeIdx += 1;
        return lexeme;
      };
      lunr2.QueryParser.prototype.nextClause = function() {
        var completedClause = this.currentClause;
        this.query.clause(completedClause);
        this.currentClause = {};
      };
      lunr2.QueryParser.parseClause = function(parser3) {
        var lexeme = parser3.peekLexeme();
        if (lexeme == void 0) {
          return;
        }
        switch (lexeme.type) {
          case lunr2.QueryLexer.PRESENCE:
            return lunr2.QueryParser.parsePresence;
          case lunr2.QueryLexer.FIELD:
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.TERM:
            return lunr2.QueryParser.parseTerm;
          default:
            var errorMessage = "expected either a field or a term, found " + lexeme.type;
            if (lexeme.str.length >= 1) {
              errorMessage += " with value '" + lexeme.str + "'";
            }
            throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
      };
      lunr2.QueryParser.parsePresence = function(parser3) {
        var lexeme = parser3.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        switch (lexeme.str) {
          case "-":
            parser3.currentClause.presence = lunr2.Query.presence.PROHIBITED;
            break;
          case "+":
            parser3.currentClause.presence = lunr2.Query.presence.REQUIRED;
            break;
          default:
            var errorMessage = "unrecognised presence operator'" + lexeme.str + "'";
            throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        var nextLexeme = parser3.peekLexeme();
        if (nextLexeme == void 0) {
          var errorMessage = "expecting term or field, found nothing";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.FIELD:
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.TERM:
            return lunr2.QueryParser.parseTerm;
          default:
            var errorMessage = "expecting term or field, found '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseField = function(parser3) {
        var lexeme = parser3.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        if (parser3.query.allFields.indexOf(lexeme.str) == -1) {
          var possibleFields = parser3.query.allFields.map(function(f) {
            return "'" + f + "'";
          }).join(", "), errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields;
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        parser3.currentClause.fields = [lexeme.str];
        var nextLexeme = parser3.peekLexeme();
        if (nextLexeme == void 0) {
          var errorMessage = "expecting term, found nothing";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            return lunr2.QueryParser.parseTerm;
          default:
            var errorMessage = "expecting term, found '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseTerm = function(parser3) {
        var lexeme = parser3.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        parser3.currentClause.term = lexeme.str.toLowerCase();
        if (lexeme.str.indexOf("*") != -1) {
          parser3.currentClause.usePipeline = false;
        }
        var nextLexeme = parser3.peekLexeme();
        if (nextLexeme == void 0) {
          parser3.nextClause();
          return;
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            parser3.nextClause();
            return lunr2.QueryParser.parseTerm;
          case lunr2.QueryLexer.FIELD:
            parser3.nextClause();
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.EDIT_DISTANCE:
            return lunr2.QueryParser.parseEditDistance;
          case lunr2.QueryLexer.BOOST:
            return lunr2.QueryParser.parseBoost;
          case lunr2.QueryLexer.PRESENCE:
            parser3.nextClause();
            return lunr2.QueryParser.parsePresence;
          default:
            var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseEditDistance = function(parser3) {
        var lexeme = parser3.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        var editDistance = parseInt(lexeme.str, 10);
        if (isNaN(editDistance)) {
          var errorMessage = "edit distance must be numeric";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        parser3.currentClause.editDistance = editDistance;
        var nextLexeme = parser3.peekLexeme();
        if (nextLexeme == void 0) {
          parser3.nextClause();
          return;
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            parser3.nextClause();
            return lunr2.QueryParser.parseTerm;
          case lunr2.QueryLexer.FIELD:
            parser3.nextClause();
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.EDIT_DISTANCE:
            return lunr2.QueryParser.parseEditDistance;
          case lunr2.QueryLexer.BOOST:
            return lunr2.QueryParser.parseBoost;
          case lunr2.QueryLexer.PRESENCE:
            parser3.nextClause();
            return lunr2.QueryParser.parsePresence;
          default:
            var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseBoost = function(parser3) {
        var lexeme = parser3.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        var boost = parseInt(lexeme.str, 10);
        if (isNaN(boost)) {
          var errorMessage = "boost must be numeric";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        parser3.currentClause.boost = boost;
        var nextLexeme = parser3.peekLexeme();
        if (nextLexeme == void 0) {
          parser3.nextClause();
          return;
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            parser3.nextClause();
            return lunr2.QueryParser.parseTerm;
          case lunr2.QueryLexer.FIELD:
            parser3.nextClause();
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.EDIT_DISTANCE:
            return lunr2.QueryParser.parseEditDistance;
          case lunr2.QueryLexer.BOOST:
            return lunr2.QueryParser.parseBoost;
          case lunr2.QueryLexer.PRESENCE:
            parser3.nextClause();
            return lunr2.QueryParser.parsePresence;
          default:
            var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.lunr = factory();
        }
      })(this, function() {
        return lunr2;
      });
    })();
  }
});

// node_modules/perfect-scrollbar/dist/perfect-scrollbar.common.js
var require_perfect_scrollbar_common = __commonJS({
  "node_modules/perfect-scrollbar/dist/perfect-scrollbar.common.js"(exports, module) {
    "use strict";
    function get(element) {
      return getComputedStyle(element);
    }
    function set(element, obj) {
      for (var key2 in obj) {
        var val = obj[key2];
        if (typeof val === "number") {
          val = val + "px";
        }
        element.style[key2] = val;
      }
      return element;
    }
    function div(className) {
      var div2 = document.createElement("div");
      div2.className = className;
      return div2;
    }
    var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
    function matches(element, query) {
      if (!elMatches) {
        throw new Error("No element matching method supported");
      }
      return elMatches.call(element, query);
    }
    function remove2(element) {
      if (element.remove) {
        element.remove();
      } else {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      }
    }
    function queryChildren(element, selector) {
      return Array.prototype.filter.call(
        element.children,
        function(child) {
          return matches(child, selector);
        }
      );
    }
    var cls = {
      main: "ps",
      rtl: "ps__rtl",
      element: {
        thumb: function(x) {
          return "ps__thumb-" + x;
        },
        rail: function(x) {
          return "ps__rail-" + x;
        },
        consuming: "ps__child--consume"
      },
      state: {
        focus: "ps--focus",
        clicking: "ps--clicking",
        active: function(x) {
          return "ps--active-" + x;
        },
        scrolling: function(x) {
          return "ps--scrolling-" + x;
        }
      }
    };
    var scrollingClassTimeout = { x: null, y: null };
    function addScrollingClass(i, x) {
      var classList = i.element.classList;
      var className = cls.state.scrolling(x);
      if (classList.contains(className)) {
        clearTimeout(scrollingClassTimeout[x]);
      } else {
        classList.add(className);
      }
    }
    function removeScrollingClass(i, x) {
      scrollingClassTimeout[x] = setTimeout(
        function() {
          return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
        },
        i.settings.scrollingThreshold
      );
    }
    function setScrollingClassInstantly(i, x) {
      addScrollingClass(i, x);
      removeScrollingClass(i, x);
    }
    var EventElement = function EventElement2(element) {
      this.element = element;
      this.handlers = {};
    };
    var prototypeAccessors = { isEmpty: { configurable: true } };
    EventElement.prototype.bind = function bind4(eventName, handler) {
      if (typeof this.handlers[eventName] === "undefined") {
        this.handlers[eventName] = [];
      }
      this.handlers[eventName].push(handler);
      this.element.addEventListener(eventName, handler, false);
    };
    EventElement.prototype.unbind = function unbind(eventName, target) {
      var this$1 = this;
      this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
        if (target && handler !== target) {
          return true;
        }
        this$1.element.removeEventListener(eventName, handler, false);
        return false;
      });
    };
    EventElement.prototype.unbindAll = function unbindAll() {
      for (var name2 in this.handlers) {
        this.unbind(name2);
      }
    };
    prototypeAccessors.isEmpty.get = function() {
      var this$1 = this;
      return Object.keys(this.handlers).every(
        function(key2) {
          return this$1.handlers[key2].length === 0;
        }
      );
    };
    Object.defineProperties(EventElement.prototype, prototypeAccessors);
    var EventManager = function EventManager2() {
      this.eventElements = [];
    };
    EventManager.prototype.eventElement = function eventElement(element) {
      var ee = this.eventElements.filter(function(ee2) {
        return ee2.element === element;
      })[0];
      if (!ee) {
        ee = new EventElement(element);
        this.eventElements.push(ee);
      }
      return ee;
    };
    EventManager.prototype.bind = function bind4(element, eventName, handler) {
      this.eventElement(element).bind(eventName, handler);
    };
    EventManager.prototype.unbind = function unbind(element, eventName, handler) {
      var ee = this.eventElement(element);
      ee.unbind(eventName, handler);
      if (ee.isEmpty) {
        this.eventElements.splice(this.eventElements.indexOf(ee), 1);
      }
    };
    EventManager.prototype.unbindAll = function unbindAll() {
      this.eventElements.forEach(function(e) {
        return e.unbindAll();
      });
      this.eventElements = [];
    };
    EventManager.prototype.once = function once(element, eventName, handler) {
      var ee = this.eventElement(element);
      var onceHandler = function(evt) {
        ee.unbind(eventName, onceHandler);
        handler(evt);
      };
      ee.bind(eventName, onceHandler);
    };
    function createEvent(name2) {
      if (typeof window.CustomEvent === "function") {
        return new CustomEvent(name2);
      }
      var evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(name2, false, false, void 0);
      return evt;
    }
    function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent) {
      if (useScrollingClass === void 0) useScrollingClass = true;
      if (forceFireReachEvent === void 0) forceFireReachEvent = false;
      var fields;
      if (axis === "top") {
        fields = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
      } else if (axis === "left") {
        fields = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
      } else {
        throw new Error("A proper axis should be provided");
      }
      processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
    }
    function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent) {
      var contentHeight = ref[0];
      var containerHeight = ref[1];
      var scrollTop = ref[2];
      var y = ref[3];
      var up = ref[4];
      var down = ref[5];
      if (useScrollingClass === void 0) useScrollingClass = true;
      if (forceFireReachEvent === void 0) forceFireReachEvent = false;
      var element = i.element;
      i.reach[y] = null;
      if (element[scrollTop] < 1) {
        i.reach[y] = "start";
      }
      if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
        i.reach[y] = "end";
      }
      if (diff) {
        element.dispatchEvent(createEvent("ps-scroll-" + y));
        if (diff < 0) {
          element.dispatchEvent(createEvent("ps-scroll-" + up));
        } else if (diff > 0) {
          element.dispatchEvent(createEvent("ps-scroll-" + down));
        }
        if (useScrollingClass) {
          setScrollingClassInstantly(i, y);
        }
      }
      if (i.reach[y] && (diff || forceFireReachEvent)) {
        element.dispatchEvent(createEvent("ps-" + y + "-reach-" + i.reach[y]));
      }
    }
    function toInt(x) {
      return parseInt(x, 10) || 0;
    }
    function isEditable(el) {
      return matches(el, "input,[contenteditable]") || matches(el, "select,[contenteditable]") || matches(el, "textarea,[contenteditable]") || matches(el, "button,[contenteditable]");
    }
    function outerWidth(element) {
      var styles = get(element);
      return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
    }
    var env = {
      isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
      supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
      supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
      isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
    };
    function updateGeometry(i) {
      var element = i.element;
      var roundedScrollTop = Math.floor(element.scrollTop);
      var rect = element.getBoundingClientRect();
      i.containerWidth = Math.floor(rect.width);
      i.containerHeight = Math.floor(rect.height);
      i.contentWidth = element.scrollWidth;
      i.contentHeight = element.scrollHeight;
      if (!element.contains(i.scrollbarXRail)) {
        queryChildren(element, cls.element.rail("x")).forEach(function(el) {
          return remove2(el);
        });
        element.appendChild(i.scrollbarXRail);
      }
      if (!element.contains(i.scrollbarYRail)) {
        queryChildren(element, cls.element.rail("y")).forEach(function(el) {
          return remove2(el);
        });
        element.appendChild(i.scrollbarYRail);
      }
      if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
        i.scrollbarXActive = true;
        i.railXWidth = i.containerWidth - i.railXMarginWidth;
        i.railXRatio = i.containerWidth / i.railXWidth;
        i.scrollbarXWidth = getThumbSize(i, toInt(i.railXWidth * i.containerWidth / i.contentWidth));
        i.scrollbarXLeft = toInt(
          (i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
        );
      } else {
        i.scrollbarXActive = false;
      }
      if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
        i.scrollbarYActive = true;
        i.railYHeight = i.containerHeight - i.railYMarginHeight;
        i.railYRatio = i.containerHeight / i.railYHeight;
        i.scrollbarYHeight = getThumbSize(
          i,
          toInt(i.railYHeight * i.containerHeight / i.contentHeight)
        );
        i.scrollbarYTop = toInt(
          roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
        );
      } else {
        i.scrollbarYActive = false;
      }
      if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
        i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
      }
      if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
        i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
      }
      updateCss(element, i);
      if (i.scrollbarXActive) {
        element.classList.add(cls.state.active("x"));
      } else {
        element.classList.remove(cls.state.active("x"));
        i.scrollbarXWidth = 0;
        i.scrollbarXLeft = 0;
        element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
      }
      if (i.scrollbarYActive) {
        element.classList.add(cls.state.active("y"));
      } else {
        element.classList.remove(cls.state.active("y"));
        i.scrollbarYHeight = 0;
        i.scrollbarYTop = 0;
        element.scrollTop = 0;
      }
    }
    function getThumbSize(i, thumbSize) {
      if (i.settings.minScrollbarLength) {
        thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
      }
      if (i.settings.maxScrollbarLength) {
        thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
      }
      return thumbSize;
    }
    function updateCss(element, i) {
      var xRailOffset = { width: i.railXWidth };
      var roundedScrollTop = Math.floor(element.scrollTop);
      if (i.isRtl) {
        xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
      } else {
        xRailOffset.left = element.scrollLeft;
      }
      if (i.isScrollbarXUsingBottom) {
        xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
      } else {
        xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
      }
      set(i.scrollbarXRail, xRailOffset);
      var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
      if (i.isScrollbarYUsingRight) {
        if (i.isRtl) {
          yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
        } else {
          yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
        }
      } else {
        if (i.isRtl) {
          yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
        } else {
          yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
        }
      }
      set(i.scrollbarYRail, yRailOffset);
      set(i.scrollbarX, {
        left: i.scrollbarXLeft,
        width: i.scrollbarXWidth - i.railBorderXWidth
      });
      set(i.scrollbarY, {
        top: i.scrollbarYTop,
        height: i.scrollbarYHeight - i.railBorderYWidth
      });
    }
    function clickRail(i) {
      i.event.bind(i.scrollbarY, "mousedown", function(e) {
        return e.stopPropagation();
      });
      i.event.bind(i.scrollbarYRail, "mousedown", function(e) {
        var positionTop = e.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
        var direction = positionTop > i.scrollbarYTop ? 1 : -1;
        i.element.scrollTop += direction * i.containerHeight;
        updateGeometry(i);
        e.stopPropagation();
      });
      i.event.bind(i.scrollbarX, "mousedown", function(e) {
        return e.stopPropagation();
      });
      i.event.bind(i.scrollbarXRail, "mousedown", function(e) {
        var positionLeft = e.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
        var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
        i.element.scrollLeft += direction * i.containerWidth;
        updateGeometry(i);
        e.stopPropagation();
      });
    }
    var activeSlider = null;
    function setupScrollHandlers(i) {
      bindMouseScrollHandler(i, [
        "containerHeight",
        "contentHeight",
        "pageY",
        "railYHeight",
        "scrollbarY",
        "scrollbarYHeight",
        "scrollTop",
        "y",
        "scrollbarYRail"
      ]);
      bindMouseScrollHandler(i, [
        "containerWidth",
        "contentWidth",
        "pageX",
        "railXWidth",
        "scrollbarX",
        "scrollbarXWidth",
        "scrollLeft",
        "x",
        "scrollbarXRail"
      ]);
    }
    function bindMouseScrollHandler(i, ref) {
      var containerDimension = ref[0];
      var contentDimension = ref[1];
      var pageAxis = ref[2];
      var railDimension = ref[3];
      var scrollbarAxis = ref[4];
      var scrollbarDimension = ref[5];
      var scrollAxis = ref[6];
      var axis = ref[7];
      var scrollbarRail = ref[8];
      var element = i.element;
      var startingScrollPosition = null;
      var startingMousePagePosition = null;
      var scrollBy = null;
      function moveHandler(e) {
        if (e.touches && e.touches[0]) {
          e[pageAxis] = e.touches[0]["page" + axis.toUpperCase()];
        }
        if (activeSlider === scrollbarAxis) {
          element[scrollAxis] = startingScrollPosition + scrollBy * (e[pageAxis] - startingMousePagePosition);
          addScrollingClass(i, axis);
          updateGeometry(i);
          e.stopPropagation();
          e.preventDefault();
        }
      }
      function endHandler() {
        removeScrollingClass(i, axis);
        i[scrollbarRail].classList.remove(cls.state.clicking);
        document.removeEventListener("mousemove", moveHandler);
        document.removeEventListener("mouseup", endHandler);
        document.removeEventListener("touchmove", moveHandler);
        document.removeEventListener("touchend", endHandler);
        activeSlider = null;
      }
      function bindMoves(e) {
        if (activeSlider === null) {
          activeSlider = scrollbarAxis;
          startingScrollPosition = element[scrollAxis];
          if (e.touches) {
            e[pageAxis] = e.touches[0]["page" + axis.toUpperCase()];
          }
          startingMousePagePosition = e[pageAxis];
          scrollBy = (i[contentDimension] - i[containerDimension]) / (i[railDimension] - i[scrollbarDimension]);
          if (!e.touches) {
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", endHandler);
          } else {
            document.addEventListener("touchmove", moveHandler, { passive: false });
            document.addEventListener("touchend", endHandler);
          }
          i[scrollbarRail].classList.add(cls.state.clicking);
        }
        e.stopPropagation();
        if (e.cancelable) {
          e.preventDefault();
        }
      }
      i[scrollbarAxis].addEventListener("mousedown", bindMoves);
      i[scrollbarAxis].addEventListener("touchstart", bindMoves);
    }
    function keyboard(i) {
      var element = i.element;
      var elementHovered = function() {
        return matches(element, ":hover");
      };
      var scrollbarFocused = function() {
        return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
      };
      function shouldPreventDefault(deltaX, deltaY) {
        var scrollTop = Math.floor(element.scrollTop);
        if (deltaX === 0) {
          if (!i.scrollbarYActive) {
            return false;
          }
          if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
            return !i.settings.wheelPropagation;
          }
        }
        var scrollLeft = element.scrollLeft;
        if (deltaY === 0) {
          if (!i.scrollbarXActive) {
            return false;
          }
          if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
            return !i.settings.wheelPropagation;
          }
        }
        return true;
      }
      i.event.bind(i.ownerDocument, "keydown", function(e) {
        if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
          return;
        }
        if (!elementHovered() && !scrollbarFocused()) {
          return;
        }
        var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
        if (activeElement) {
          if (activeElement.tagName === "IFRAME") {
            activeElement = activeElement.contentDocument.activeElement;
          } else {
            while (activeElement.shadowRoot) {
              activeElement = activeElement.shadowRoot.activeElement;
            }
          }
          if (isEditable(activeElement)) {
            return;
          }
        }
        var deltaX = 0;
        var deltaY = 0;
        switch (e.which) {
          case 37:
            if (e.metaKey) {
              deltaX = -i.contentWidth;
            } else if (e.altKey) {
              deltaX = -i.containerWidth;
            } else {
              deltaX = -30;
            }
            break;
          case 38:
            if (e.metaKey) {
              deltaY = i.contentHeight;
            } else if (e.altKey) {
              deltaY = i.containerHeight;
            } else {
              deltaY = 30;
            }
            break;
          case 39:
            if (e.metaKey) {
              deltaX = i.contentWidth;
            } else if (e.altKey) {
              deltaX = i.containerWidth;
            } else {
              deltaX = 30;
            }
            break;
          case 40:
            if (e.metaKey) {
              deltaY = -i.contentHeight;
            } else if (e.altKey) {
              deltaY = -i.containerHeight;
            } else {
              deltaY = -30;
            }
            break;
          case 32:
            if (e.shiftKey) {
              deltaY = i.containerHeight;
            } else {
              deltaY = -i.containerHeight;
            }
            break;
          case 33:
            deltaY = i.containerHeight;
            break;
          case 34:
            deltaY = -i.containerHeight;
            break;
          case 36:
            deltaY = i.contentHeight;
            break;
          case 35:
            deltaY = -i.contentHeight;
            break;
          default:
            return;
        }
        if (i.settings.suppressScrollX && deltaX !== 0) {
          return;
        }
        if (i.settings.suppressScrollY && deltaY !== 0) {
          return;
        }
        element.scrollTop -= deltaY;
        element.scrollLeft += deltaX;
        updateGeometry(i);
        if (shouldPreventDefault(deltaX, deltaY)) {
          e.preventDefault();
        }
      });
    }
    function wheel(i) {
      var element = i.element;
      function shouldPreventDefault(deltaX, deltaY) {
        var roundedScrollTop = Math.floor(element.scrollTop);
        var isTop = element.scrollTop === 0;
        var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
        var isLeft = element.scrollLeft === 0;
        var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
        var hitsBound;
        if (Math.abs(deltaY) > Math.abs(deltaX)) {
          hitsBound = isTop || isBottom;
        } else {
          hitsBound = isLeft || isRight;
        }
        return hitsBound ? !i.settings.wheelPropagation : true;
      }
      function getDeltaFromEvent(e) {
        var deltaX = e.deltaX;
        var deltaY = -1 * e.deltaY;
        if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
          deltaX = -1 * e.wheelDeltaX / 6;
          deltaY = e.wheelDeltaY / 6;
        }
        if (e.deltaMode && e.deltaMode === 1) {
          deltaX *= 10;
          deltaY *= 10;
        }
        if (deltaX !== deltaX && deltaY !== deltaY) {
          deltaX = 0;
          deltaY = e.wheelDelta;
        }
        if (e.shiftKey) {
          return [-deltaY, -deltaX];
        }
        return [deltaX, deltaY];
      }
      function shouldBeConsumedByChild(target, deltaX, deltaY) {
        if (!env.isWebKit && element.querySelector("select:focus")) {
          return true;
        }
        if (!element.contains(target)) {
          return false;
        }
        var cursor2 = target;
        while (cursor2 && cursor2 !== element) {
          if (cursor2.classList.contains(cls.element.consuming)) {
            return true;
          }
          var style = get(cursor2);
          if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
            var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
            if (maxScrollTop > 0) {
              if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
                return true;
              }
            }
          }
          if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
            var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
            if (maxScrollLeft > 0) {
              if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
                return true;
              }
            }
          }
          cursor2 = cursor2.parentNode;
        }
        return false;
      }
      function mousewheelHandler(e) {
        var ref = getDeltaFromEvent(e);
        var deltaX = ref[0];
        var deltaY = ref[1];
        if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
          return;
        }
        var shouldPrevent = false;
        if (!i.settings.useBothWheelAxes) {
          element.scrollTop -= deltaY * i.settings.wheelSpeed;
          element.scrollLeft += deltaX * i.settings.wheelSpeed;
        } else if (i.scrollbarYActive && !i.scrollbarXActive) {
          if (deltaY) {
            element.scrollTop -= deltaY * i.settings.wheelSpeed;
          } else {
            element.scrollTop += deltaX * i.settings.wheelSpeed;
          }
          shouldPrevent = true;
        } else if (i.scrollbarXActive && !i.scrollbarYActive) {
          if (deltaX) {
            element.scrollLeft += deltaX * i.settings.wheelSpeed;
          } else {
            element.scrollLeft -= deltaY * i.settings.wheelSpeed;
          }
          shouldPrevent = true;
        }
        updateGeometry(i);
        shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
        if (shouldPrevent && !e.ctrlKey) {
          e.stopPropagation();
          e.preventDefault();
        }
      }
      if (typeof window.onwheel !== "undefined") {
        i.event.bind(element, "wheel", mousewheelHandler);
      } else if (typeof window.onmousewheel !== "undefined") {
        i.event.bind(element, "mousewheel", mousewheelHandler);
      }
    }
    function touch(i) {
      if (!env.supportsTouch && !env.supportsIePointer) {
        return;
      }
      var element = i.element;
      var state = {
        startOffset: {},
        startTime: 0,
        speed: {},
        easingLoop: null
      };
      function shouldPrevent(deltaX, deltaY) {
        var scrollTop = Math.floor(element.scrollTop);
        var scrollLeft = element.scrollLeft;
        var magnitudeX = Math.abs(deltaX);
        var magnitudeY = Math.abs(deltaY);
        if (magnitudeY > magnitudeX) {
          if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
            return window.scrollY === 0 && deltaY > 0 && env.isChrome;
          }
        } else if (magnitudeX > magnitudeY) {
          if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
            return true;
          }
        }
        return true;
      }
      function applyTouchMove(differenceX, differenceY) {
        element.scrollTop -= differenceY;
        element.scrollLeft -= differenceX;
        updateGeometry(i);
      }
      function getTouch(e) {
        if (e.targetTouches) {
          return e.targetTouches[0];
        }
        return e;
      }
      function shouldHandle(e) {
        if (e.target === i.scrollbarX || e.target === i.scrollbarY) {
          return false;
        }
        if (e.pointerType && e.pointerType === "pen" && e.buttons === 0) {
          return false;
        }
        if (e.targetTouches && e.targetTouches.length === 1) {
          return true;
        }
        if (e.pointerType && e.pointerType !== "mouse" && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
          return true;
        }
        return false;
      }
      function touchStart(e) {
        if (!shouldHandle(e)) {
          return;
        }
        var touch2 = getTouch(e);
        state.startOffset.pageX = touch2.pageX;
        state.startOffset.pageY = touch2.pageY;
        state.startTime = (/* @__PURE__ */ new Date()).getTime();
        if (state.easingLoop !== null) {
          clearInterval(state.easingLoop);
        }
      }
      function shouldBeConsumedByChild(target, deltaX, deltaY) {
        if (!element.contains(target)) {
          return false;
        }
        var cursor2 = target;
        while (cursor2 && cursor2 !== element) {
          if (cursor2.classList.contains(cls.element.consuming)) {
            return true;
          }
          var style = get(cursor2);
          if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
            var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
            if (maxScrollTop > 0) {
              if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
                return true;
              }
            }
          }
          if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
            var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
            if (maxScrollLeft > 0) {
              if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
                return true;
              }
            }
          }
          cursor2 = cursor2.parentNode;
        }
        return false;
      }
      function touchMove(e) {
        if (shouldHandle(e)) {
          var touch2 = getTouch(e);
          var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
          var differenceX = currentOffset.pageX - state.startOffset.pageX;
          var differenceY = currentOffset.pageY - state.startOffset.pageY;
          if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
            return;
          }
          applyTouchMove(differenceX, differenceY);
          state.startOffset = currentOffset;
          var currentTime = (/* @__PURE__ */ new Date()).getTime();
          var timeGap = currentTime - state.startTime;
          if (timeGap > 0) {
            state.speed.x = differenceX / timeGap;
            state.speed.y = differenceY / timeGap;
            state.startTime = currentTime;
          }
          if (shouldPrevent(differenceX, differenceY)) {
            if (e.cancelable) {
              e.preventDefault();
            }
          }
        }
      }
      function touchEnd() {
        if (i.settings.swipeEasing) {
          clearInterval(state.easingLoop);
          state.easingLoop = setInterval(function() {
            if (i.isInitialized) {
              clearInterval(state.easingLoop);
              return;
            }
            if (!state.speed.x && !state.speed.y) {
              clearInterval(state.easingLoop);
              return;
            }
            if (Math.abs(state.speed.x) < 0.01 && Math.abs(state.speed.y) < 0.01) {
              clearInterval(state.easingLoop);
              return;
            }
            applyTouchMove(state.speed.x * 30, state.speed.y * 30);
            state.speed.x *= 0.8;
            state.speed.y *= 0.8;
          }, 10);
        }
      }
      if (env.supportsTouch) {
        i.event.bind(element, "touchstart", touchStart);
        i.event.bind(element, "touchmove", touchMove);
        i.event.bind(element, "touchend", touchEnd);
      } else if (env.supportsIePointer) {
        if (window.PointerEvent) {
          i.event.bind(element, "pointerdown", touchStart);
          i.event.bind(element, "pointermove", touchMove);
          i.event.bind(element, "pointerup", touchEnd);
        } else if (window.MSPointerEvent) {
          i.event.bind(element, "MSPointerDown", touchStart);
          i.event.bind(element, "MSPointerMove", touchMove);
          i.event.bind(element, "MSPointerUp", touchEnd);
        }
      }
    }
    var defaultSettings = function() {
      return {
        handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
        maxScrollbarLength: null,
        minScrollbarLength: null,
        scrollingThreshold: 1e3,
        scrollXMarginOffset: 0,
        scrollYMarginOffset: 0,
        suppressScrollX: false,
        suppressScrollY: false,
        swipeEasing: true,
        useBothWheelAxes: false,
        wheelPropagation: true,
        wheelSpeed: 1
      };
    };
    var handlers2 = {
      "click-rail": clickRail,
      "drag-thumb": setupScrollHandlers,
      keyboard,
      wheel,
      touch
    };
    var PerfectScrollbar2 = function PerfectScrollbar3(element, userSettings) {
      var this$1 = this;
      if (userSettings === void 0) userSettings = {};
      if (typeof element === "string") {
        element = document.querySelector(element);
      }
      if (!element || !element.nodeName) {
        throw new Error("no element is specified to initialize PerfectScrollbar");
      }
      this.element = element;
      element.classList.add(cls.main);
      this.settings = defaultSettings();
      for (var key2 in userSettings) {
        this.settings[key2] = userSettings[key2];
      }
      this.containerWidth = null;
      this.containerHeight = null;
      this.contentWidth = null;
      this.contentHeight = null;
      var focus = function() {
        return element.classList.add(cls.state.focus);
      };
      var blur = function() {
        return element.classList.remove(cls.state.focus);
      };
      this.isRtl = get(element).direction === "rtl";
      if (this.isRtl === true) {
        element.classList.add(cls.rtl);
      }
      this.isNegativeScroll = function() {
        var originalScrollLeft = element.scrollLeft;
        var result = null;
        element.scrollLeft = -1;
        result = element.scrollLeft < 0;
        element.scrollLeft = originalScrollLeft;
        return result;
      }();
      this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
      this.event = new EventManager();
      this.ownerDocument = element.ownerDocument || document;
      this.scrollbarXRail = div(cls.element.rail("x"));
      element.appendChild(this.scrollbarXRail);
      this.scrollbarX = div(cls.element.thumb("x"));
      this.scrollbarXRail.appendChild(this.scrollbarX);
      this.scrollbarX.setAttribute("tabindex", 0);
      this.event.bind(this.scrollbarX, "focus", focus);
      this.event.bind(this.scrollbarX, "blur", blur);
      this.scrollbarXActive = null;
      this.scrollbarXWidth = null;
      this.scrollbarXLeft = null;
      var railXStyle = get(this.scrollbarXRail);
      this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
      if (isNaN(this.scrollbarXBottom)) {
        this.isScrollbarXUsingBottom = false;
        this.scrollbarXTop = toInt(railXStyle.top);
      } else {
        this.isScrollbarXUsingBottom = true;
      }
      this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
      set(this.scrollbarXRail, { display: "block" });
      this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
      set(this.scrollbarXRail, { display: "" });
      this.railXWidth = null;
      this.railXRatio = null;
      this.scrollbarYRail = div(cls.element.rail("y"));
      element.appendChild(this.scrollbarYRail);
      this.scrollbarY = div(cls.element.thumb("y"));
      this.scrollbarYRail.appendChild(this.scrollbarY);
      this.scrollbarY.setAttribute("tabindex", 0);
      this.event.bind(this.scrollbarY, "focus", focus);
      this.event.bind(this.scrollbarY, "blur", blur);
      this.scrollbarYActive = null;
      this.scrollbarYHeight = null;
      this.scrollbarYTop = null;
      var railYStyle = get(this.scrollbarYRail);
      this.scrollbarYRight = parseInt(railYStyle.right, 10);
      if (isNaN(this.scrollbarYRight)) {
        this.isScrollbarYUsingRight = false;
        this.scrollbarYLeft = toInt(railYStyle.left);
      } else {
        this.isScrollbarYUsingRight = true;
      }
      this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
      this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
      set(this.scrollbarYRail, { display: "block" });
      this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
      set(this.scrollbarYRail, { display: "" });
      this.railYHeight = null;
      this.railYRatio = null;
      this.reach = {
        x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
        y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
      };
      this.isAlive = true;
      this.settings.handlers.forEach(function(handlerName) {
        return handlers2[handlerName](this$1);
      });
      this.lastScrollTop = Math.floor(element.scrollTop);
      this.lastScrollLeft = element.scrollLeft;
      this.event.bind(this.element, "scroll", function(e) {
        return this$1.onScroll(e);
      });
      updateGeometry(this);
    };
    PerfectScrollbar2.prototype.update = function update() {
      if (!this.isAlive) {
        return;
      }
      this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
      set(this.scrollbarXRail, { display: "block" });
      set(this.scrollbarYRail, { display: "block" });
      this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
      this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
      set(this.scrollbarXRail, { display: "none" });
      set(this.scrollbarYRail, { display: "none" });
      updateGeometry(this);
      processScrollDiff(this, "top", 0, false, true);
      processScrollDiff(this, "left", 0, false, true);
      set(this.scrollbarXRail, { display: "" });
      set(this.scrollbarYRail, { display: "" });
    };
    PerfectScrollbar2.prototype.onScroll = function onScroll(e) {
      if (!this.isAlive) {
        return;
      }
      updateGeometry(this);
      processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
      processScrollDiff(this, "left", this.element.scrollLeft - this.lastScrollLeft);
      this.lastScrollTop = Math.floor(this.element.scrollTop);
      this.lastScrollLeft = this.element.scrollLeft;
    };
    PerfectScrollbar2.prototype.destroy = function destroy() {
      if (!this.isAlive) {
        return;
      }
      this.event.unbindAll();
      remove2(this.scrollbarX);
      remove2(this.scrollbarY);
      remove2(this.scrollbarXRail);
      remove2(this.scrollbarYRail);
      this.removePsClasses();
      this.element = null;
      this.scrollbarX = null;
      this.scrollbarY = null;
      this.scrollbarXRail = null;
      this.scrollbarYRail = null;
      this.isAlive = false;
    };
    PerfectScrollbar2.prototype.removePsClasses = function removePsClasses() {
      this.element.className = this.element.className.split(" ").filter(function(name2) {
        return !name2.match(/^ps([-_].+|)$/);
      }).join(" ");
    };
    module.exports = PerfectScrollbar2;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key2 in arg) {
          if (hasOwn.call(arg, key2) && arg[key2]) {
            classes = appendClass(classes, key2);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
    function _objectWithoutPropertiesLoose2(r, e) {
      if (null == r) return {};
      var t2 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t2[n] = r[n];
      }
      return t2;
    }
    module.exports = _objectWithoutPropertiesLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/stickyfill/index.js
var require_stickyfill = __commonJS({
  "node_modules/stickyfill/index.js"(exports, module) {
    module.exports = function(doc2, win) {
      if (!doc2) {
        doc2 = document;
      }
      if (!win) {
        win = window;
      }
      var watchArray = [], scroll, initialized = false, html2 = doc2.documentElement, noop = function() {
      }, checkTimer, hiddenPropertyName = "hidden", visibilityChangeEventName = "visibilitychange";
      if (doc2.webkitHidden !== void 0) {
        hiddenPropertyName = "webkitHidden";
        visibilityChangeEventName = "webkitvisibilitychange";
      }
      if (!win.getComputedStyle) {
        seppuku();
      }
      var prefixes = ["", "-webkit-", "-moz-", "-ms-"], block2 = document.createElement("div");
      for (var i = prefixes.length - 1; i >= 0; i--) {
        try {
          block2.style.position = prefixes[i] + "sticky";
        } catch (e) {
        }
        if (block2.style.position != "") {
          seppuku();
        }
      }
      updateScrollPos();
      function seppuku() {
        init = add3 = rebuild = pause = stop = kill = noop;
      }
      function mergeObjects2(targetObj, sourceObject) {
        for (key in sourceObject) {
          if (sourceObject.hasOwnProperty(key)) {
            targetObj[key] = sourceObject[key];
          }
        }
      }
      function parseNumeric(val) {
        return parseFloat(val) || 0;
      }
      function updateScrollPos() {
        scroll = {
          top: win.pageYOffset,
          left: win.pageXOffset
        };
      }
      function onScroll() {
        if (win.pageXOffset != scroll.left) {
          updateScrollPos();
          rebuild();
          return;
        }
        if (win.pageYOffset != scroll.top) {
          updateScrollPos();
          recalcAllPos();
        }
      }
      function onWheel(event) {
        setTimeout(function() {
          if (win.pageYOffset != scroll.top) {
            scroll.top = win.pageYOffset;
            recalcAllPos();
          }
        }, 0);
      }
      function recalcAllPos() {
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          recalcElementPos(watchArray[i2]);
        }
      }
      function recalcElementPos(el) {
        if (!el.inited) return;
        var currentMode = scroll.top <= el.limit.start ? 0 : scroll.top >= el.limit.end ? 2 : 1;
        if (el.mode != currentMode) {
          switchElementMode(el, currentMode);
        }
      }
      function fastCheck() {
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          if (!watchArray[i2].inited) continue;
          var deltaTop = Math.abs(getDocOffsetTop(watchArray[i2].clone) - watchArray[i2].docOffsetTop), deltaHeight = Math.abs(watchArray[i2].parent.node.offsetHeight - watchArray[i2].parent.height);
          if (deltaTop >= 2 || deltaHeight >= 2) return false;
        }
        return true;
      }
      function initElement(el) {
        if (isNaN(parseFloat(el.computed.top)) || el.isCell) return;
        el.inited = true;
        if (!el.clone) clone2(el);
        if (el.parent.computed.position != "absolute" && el.parent.computed.position != "relative") el.parent.node.style.position = "relative";
        recalcElementPos(el);
        el.parent.height = el.parent.node.offsetHeight;
        el.docOffsetTop = getDocOffsetTop(el.clone);
      }
      function deinitElement(el) {
        var deinitParent = true;
        el.clone && killClone(el);
        mergeObjects2(el.node.style, el.css);
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          if (watchArray[i2].node !== el.node && watchArray[i2].parent.node === el.parent.node) {
            deinitParent = false;
            break;
          }
        }
        ;
        if (deinitParent) el.parent.node.style.position = el.parent.css.position;
        el.mode = -1;
      }
      function initAll() {
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          initElement(watchArray[i2]);
        }
      }
      function deinitAll() {
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          deinitElement(watchArray[i2]);
        }
      }
      function switchElementMode(el, mode) {
        var nodeStyle = el.node.style;
        switch (mode) {
          case 0:
            nodeStyle.position = "absolute";
            nodeStyle.left = el.offset.left + "px";
            nodeStyle.right = el.offset.right + "px";
            nodeStyle.top = el.offset.top + "px";
            nodeStyle.bottom = "auto";
            nodeStyle.width = "auto";
            nodeStyle.marginLeft = 0;
            nodeStyle.marginRight = 0;
            nodeStyle.marginTop = 0;
            break;
          case 1:
            nodeStyle.position = "fixed";
            nodeStyle.left = el.box.left + "px";
            nodeStyle.right = el.box.right + "px";
            nodeStyle.top = el.css.top;
            nodeStyle.bottom = "auto";
            nodeStyle.width = "auto";
            nodeStyle.marginLeft = 0;
            nodeStyle.marginRight = 0;
            nodeStyle.marginTop = 0;
            break;
          case 2:
            nodeStyle.position = "absolute";
            nodeStyle.left = el.offset.left + "px";
            nodeStyle.right = el.offset.right + "px";
            nodeStyle.top = "auto";
            nodeStyle.bottom = 0;
            nodeStyle.width = "auto";
            nodeStyle.marginLeft = 0;
            nodeStyle.marginRight = 0;
            break;
        }
        el.mode = mode;
      }
      function clone2(el) {
        el.clone = document.createElement("div");
        var refElement = el.node.nextSibling || el.node, cloneStyle = el.clone.style;
        cloneStyle.height = el.height + "px";
        cloneStyle.width = el.width + "px";
        cloneStyle.marginTop = el.computed.marginTop;
        cloneStyle.marginBottom = el.computed.marginBottom;
        cloneStyle.marginLeft = el.computed.marginLeft;
        cloneStyle.marginRight = el.computed.marginRight;
        cloneStyle.padding = cloneStyle.border = cloneStyle.borderSpacing = 0;
        cloneStyle.fontSize = "1em";
        cloneStyle.position = "static";
        cloneStyle.cssFloat = el.computed.cssFloat;
        el.node.parentNode.insertBefore(el.clone, refElement);
      }
      function killClone(el) {
        el.clone.parentNode.removeChild(el.clone);
        el.clone = void 0;
      }
      function getElementParams(node) {
        var computedStyle = getComputedStyle(node), parentNode = node.parentNode, parentComputedStyle = getComputedStyle(parentNode), cachedPosition = node.style.position;
        node.style.position = "relative";
        var computed2 = {
          top: computedStyle.top,
          marginTop: computedStyle.marginTop,
          marginBottom: computedStyle.marginBottom,
          marginLeft: computedStyle.marginLeft,
          marginRight: computedStyle.marginRight,
          cssFloat: computedStyle.cssFloat
        }, numeric = {
          top: parseNumeric(computedStyle.top),
          marginBottom: parseNumeric(computedStyle.marginBottom),
          paddingLeft: parseNumeric(computedStyle.paddingLeft),
          paddingRight: parseNumeric(computedStyle.paddingRight),
          borderLeftWidth: parseNumeric(computedStyle.borderLeftWidth),
          borderRightWidth: parseNumeric(computedStyle.borderRightWidth)
        };
        node.style.position = cachedPosition;
        var css2 = {
          position: node.style.position,
          top: node.style.top,
          bottom: node.style.bottom,
          left: node.style.left,
          right: node.style.right,
          width: node.style.width,
          marginTop: node.style.marginTop,
          marginLeft: node.style.marginLeft,
          marginRight: node.style.marginRight
        }, nodeOffset = getElementOffset(node), parentOffset = getElementOffset(parentNode), parent = {
          node: parentNode,
          css: {
            position: parentNode.style.position
          },
          computed: {
            position: parentComputedStyle.position
          },
          numeric: {
            borderLeftWidth: parseNumeric(parentComputedStyle.borderLeftWidth),
            borderRightWidth: parseNumeric(parentComputedStyle.borderRightWidth),
            borderTopWidth: parseNumeric(parentComputedStyle.borderTopWidth),
            borderBottomWidth: parseNumeric(parentComputedStyle.borderBottomWidth)
          }
        }, el = {
          node,
          box: {
            left: nodeOffset.win.left,
            right: html2.clientWidth - nodeOffset.win.right
          },
          offset: {
            top: nodeOffset.win.top - parentOffset.win.top - parent.numeric.borderTopWidth,
            left: nodeOffset.win.left - parentOffset.win.left - parent.numeric.borderLeftWidth,
            right: -nodeOffset.win.right + parentOffset.win.right - parent.numeric.borderRightWidth
          },
          css: css2,
          isCell: computedStyle.display == "table-cell",
          computed: computed2,
          numeric,
          width: nodeOffset.win.right - nodeOffset.win.left,
          height: nodeOffset.win.bottom - nodeOffset.win.top,
          mode: -1,
          inited: false,
          parent,
          limit: {
            start: nodeOffset.doc.top - numeric.top,
            end: parentOffset.doc.top + parentNode.offsetHeight - parent.numeric.borderBottomWidth - node.offsetHeight - numeric.top - numeric.marginBottom
          }
        };
        return el;
      }
      function getDocOffsetTop(node) {
        var docOffsetTop = 0;
        while (node) {
          docOffsetTop += node.offsetTop;
          node = node.offsetParent;
        }
        return docOffsetTop;
      }
      function getElementOffset(node) {
        var box = node.getBoundingClientRect();
        return {
          doc: {
            top: box.top + win.pageYOffset,
            left: box.left + win.pageXOffset
          },
          win: box
        };
      }
      function startFastCheckTimer() {
        checkTimer = setInterval(function() {
          !fastCheck() && rebuild();
        }, 500);
      }
      function stopFastCheckTimer() {
        clearInterval(checkTimer);
      }
      function handlePageVisibilityChange() {
        if (!initialized) return;
        if (document[hiddenPropertyName]) {
          stopFastCheckTimer();
        } else {
          startFastCheckTimer();
        }
      }
      function init() {
        if (initialized) return;
        updateScrollPos();
        initAll();
        win.addEventListener("scroll", onScroll);
        win.addEventListener("wheel", onWheel);
        win.addEventListener("resize", rebuild);
        win.addEventListener("orientationchange", rebuild);
        doc2.addEventListener(visibilityChangeEventName, handlePageVisibilityChange);
        startFastCheckTimer();
        initialized = true;
      }
      function rebuild() {
        if (!initialized) return;
        deinitAll();
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          watchArray[i2] = getElementParams(watchArray[i2].node);
        }
        initAll();
      }
      function pause() {
        win.removeEventListener("scroll", onScroll);
        win.removeEventListener("wheel", onWheel);
        win.removeEventListener("resize", rebuild);
        win.removeEventListener("orientationchange", rebuild);
        doc2.removeEventListener(visibilityChangeEventName, handlePageVisibilityChange);
        stopFastCheckTimer();
        initialized = false;
      }
      function stop() {
        pause();
        deinitAll();
      }
      function kill() {
        stop();
        while (watchArray.length) {
          watchArray.pop();
        }
      }
      function add3(node) {
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          if (watchArray[i2].node === node) return;
        }
        ;
        var el = getElementParams(node);
        watchArray.push(el);
        if (!initialized) {
          init();
        } else {
          initElement(el);
        }
      }
      function remove2(node) {
        for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
          if (watchArray[i2].node === node) {
            deinitElement(watchArray[i2]);
            watchArray.splice(i2, 1);
          }
        }
        ;
      }
      return {
        stickies: watchArray,
        add: add3,
        remove: remove2,
        init,
        rebuild,
        pause,
        stop,
        kill
      };
    };
  }
});

// src/theme.ts
var import_polished = __toESM(require_polished_cjs(), 1);
var defaultTheme = {
  spacing: {
    unit: 5,
    sectionHorizontal: ({ spacing }) => spacing.unit * 8,
    sectionVertical: ({ spacing }) => spacing.unit * 8
  },
  breakpoints: {
    small: "50rem",
    medium: "75rem",
    large: "105rem"
  },
  colors: {
    tonalOffset: 0.2,
    primary: {
      main: "rgb(0, 101, 251)",
      light: ({ colors }) => (0, import_polished.lighten)(colors.tonalOffset, colors.primary.main),
      dark: ({ colors }) => (0, import_polished.darken)(colors.tonalOffset, colors.primary.main),
      contrastText: ({ colors }) => (0, import_polished.readableColor)(colors.primary.main)
    },
    success: {
      main: "#1d8127",
      light: ({ colors }) => (0, import_polished.lighten)(colors.tonalOffset * 2, colors.success.main),
      dark: ({ colors }) => (0, import_polished.darken)(colors.tonalOffset, colors.success.main),
      contrastText: ({ colors }) => (0, import_polished.readableColor)(colors.success.main)
    },
    warning: {
      main: "#ffa500",
      light: ({ colors }) => (0, import_polished.lighten)(colors.tonalOffset, colors.warning.main),
      dark: ({ colors }) => (0, import_polished.darken)(colors.tonalOffset, colors.warning.main),
      contrastText: "#fff"
    },
    error: {
      main: "#d41f1c",
      light: ({ colors }) => (0, import_polished.lighten)(colors.tonalOffset, colors.error.main),
      dark: ({ colors }) => (0, import_polished.darken)(colors.tonalOffset, colors.error.main),
      contrastText: ({ colors }) => (0, import_polished.readableColor)(colors.error.main)
    },
    gray: {
      50: "#fafafa",
      100: "#f5f5f5"
    },
    text: {
      primary: "#333",
      secondary: ({ colors }) => (0, import_polished.lighten)(colors.tonalOffset, colors.text.primary)
    },
    border: {
      dark: "rgba(0,0,0, 0.1)",
      light: "#fff"
    },
    responses: {
      success: {
        color: ({ colors }) => colors.success.main,
        backgroundColor: ({ colors }) => (0, import_polished.transparentize)(0.93, colors.success.main),
        tabTextColor: ({ colors }) => colors.responses.success.color
      },
      error: {
        color: ({ colors }) => colors.error.main,
        backgroundColor: ({ colors }) => (0, import_polished.transparentize)(0.93, colors.error.main),
        tabTextColor: ({ colors }) => colors.responses.error.color
      },
      redirect: {
        color: ({ colors }) => colors.warning.main,
        backgroundColor: ({ colors }) => (0, import_polished.transparentize)(0.9, colors.responses.redirect.color),
        tabTextColor: ({ colors }) => colors.responses.redirect.color
      },
      info: {
        color: "#87ceeb",
        backgroundColor: ({ colors }) => (0, import_polished.transparentize)(0.9, colors.responses.info.color),
        tabTextColor: ({ colors }) => colors.responses.info.color
      }
    },
    http: {
      get: "#3a9601",
      post: "#186FAF",
      put: "#95507c",
      options: "#947014",
      patch: "#bf581d",
      delete: "#c33",
      basic: "#707070",
      link: "#07818f",
      head: "#a23dad"
    }
  },
  schema: {
    linesColor: (theme2) => (0, import_polished.lighten)(
      theme2.colors.tonalOffset,
      (0, import_polished.desaturate)(theme2.colors.tonalOffset, theme2.colors.primary.main)
    ),
    defaultDetailsWidth: "75%",
    typeNameColor: (theme2) => theme2.colors.text.secondary,
    typeTitleColor: (theme2) => theme2.schema.typeNameColor,
    requireLabelColor: (theme2) => theme2.colors.error.main,
    labelsTextSize: "0.9em",
    nestingSpacing: "1em",
    nestedBackground: "#fafafa",
    arrow: {
      size: "1.1em",
      color: (theme2) => theme2.colors.text.secondary
    }
  },
  typography: {
    fontSize: "14px",
    lineHeight: "1.5em",
    fontWeightRegular: "400",
    fontWeightBold: "600",
    fontWeightLight: "300",
    fontFamily: "Roboto, sans-serif",
    smoothing: "antialiased",
    optimizeSpeed: true,
    headings: {
      fontFamily: "Montserrat, sans-serif",
      fontWeight: "400",
      lineHeight: "1.6em"
    },
    code: {
      fontSize: "13px",
      fontFamily: "Courier, monospace",
      lineHeight: ({ typography }) => typography.lineHeight,
      fontWeight: ({ typography }) => typography.fontWeightRegular,
      color: "#e53935",
      backgroundColor: "rgba(38, 50, 56, 0.05)",
      wrap: false
    },
    links: {
      color: ({ colors }) => colors.primary.main,
      visited: ({ typography }) => typography.links.color,
      hover: ({ typography }) => (0, import_polished.lighten)(0.2, typography.links.color),
      textDecoration: "auto",
      hoverTextDecoration: "auto"
    }
  },
  sidebar: {
    width: "260px",
    backgroundColor: "#fafafa",
    textColor: "#333",
    activeTextColor: (theme2) => theme2.sidebar.textColor !== defaultTheme.sidebar.textColor ? theme2.sidebar.textColor : theme2.colors.primary.main,
    groupItems: {
      activeBackgroundColor: (theme2) => (0, import_polished.darken)(0.1, theme2.sidebar.backgroundColor),
      activeTextColor: (theme2) => theme2.sidebar.activeTextColor,
      textTransform: "uppercase"
    },
    level1Items: {
      activeBackgroundColor: (theme2) => (0, import_polished.darken)(0.05, theme2.sidebar.backgroundColor),
      activeTextColor: (theme2) => theme2.sidebar.activeTextColor,
      textTransform: "none"
    },
    arrow: {
      size: "1.5em",
      color: (theme2) => theme2.sidebar.textColor
    }
  },
  logo: {
    maxHeight: ({ sidebar }) => sidebar.width,
    maxWidth: ({ sidebar }) => sidebar.width,
    gutter: "2px"
  },
  rightPanel: {
    backgroundColor: "#263238",
    width: "40%",
    textColor: "#ffffff",
    servers: {
      overlay: {
        backgroundColor: "rgb(82, 96, 109)",
        textColor: "rgb(245, 247, 250)"
      },
      url: {
        backgroundColor: "#fff"
      }
    }
  },
  codeBlock: {
    backgroundColor: ({ rightPanel }) => (0, import_polished.darken)(0.1, rightPanel.backgroundColor)
  },
  fab: {
    backgroundColor: "#f2f2f2",
    color: "#0065fb"
  }
};
var theme_default = defaultTheme;
function resolveTheme(theme2) {
  const resolvedValues = {};
  let counter = 0;
  const setProxy = (obj, path) => {
    Object.keys(obj).forEach((k) => {
      const currentPath = (path ? path + "." : "") + k;
      const val = obj[k];
      if (typeof val === "function") {
        Object.defineProperty(obj, k, {
          get() {
            if (!resolvedValues[currentPath]) {
              counter++;
              if (counter > 1e3) {
                throw new Error(
                  `Theme probably contains circular dependency at ${currentPath}: ${val.toString()}`
                );
              }
              resolvedValues[currentPath] = val(theme2);
            }
            return resolvedValues[currentPath];
          },
          enumerable: true
        });
      } else if (typeof val === "object") {
        setProxy(val, currentPath);
      }
    });
  };
  setProxy(theme2, "");
  return JSON.parse(JSON.stringify(theme2));
}

// src/utils/dom.ts
var IS_BROWSER = typeof window !== "undefined" && "HTMLElement" in window;
function querySelector(selector) {
  if (typeof document !== "undefined") {
    return document.querySelector(selector);
  }
  return null;
}
function html2Str(html2) {
  return html2.split(/<[^>]+>/).map((chunk) => {
    return chunk.trim();
  }).filter((trimmedChunk) => {
    return trimmedChunk.length > 0;
  }).join(" ");
}
function scrollIntoViewIfNeeded(el, centerIfNeeded = true) {
  const parent = el.parentNode;
  if (!parent) {
    return;
  }
  const parentComputedStyle = window.getComputedStyle(parent, void 0);
  const parentBorderTopWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-top-width"),
    10
  );
  const parentBorderLeftWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-left-width"),
    10
  );
  const overTop = el.offsetTop - parent.offsetTop < parent.scrollTop;
  const overBottom = el.offsetTop - parent.offsetTop + el.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight;
  const overLeft = el.offsetLeft - parent.offsetLeft < parent.scrollLeft;
  const overRight = el.offsetLeft - parent.offsetLeft + el.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth;
  const alignWithTop = overTop && !overBottom;
  if ((overTop || overBottom) && centerIfNeeded) {
    parent.scrollTop = el.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + el.clientHeight / 2;
  }
  if ((overLeft || overRight) && centerIfNeeded) {
    parent.scrollLeft = el.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + el.clientWidth / 2;
  }
  if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
    el.scrollIntoView(alignWithTop);
  }
}

// src/utils/helpers.ts
var import_slugify = __toESM(require_slugify(), 1);
function mapWithLast(array, iteratee) {
  const res = [];
  for (let i = 0; i < array.length - 1; i++) {
    res.push(iteratee(array[i], false));
  }
  if (array.length !== 0) {
    res.push(iteratee(array[array.length - 1], true));
  }
  return res;
}
function mapValues(object, iteratee) {
  const res = {};
  for (const key2 in object) {
    if (object.hasOwnProperty(key2)) {
      res[key2] = iteratee(object[key2], key2, object);
    }
  }
  return res;
}
function flattenByProp(collectionItems, prop) {
  const res = [];
  const iterate = (items) => {
    for (const item of items) {
      res.push(item);
      if (item[prop]) {
        iterate(item[prop]);
      }
    }
  };
  iterate(collectionItems);
  return res;
}
function stripTrailingSlash(path) {
  if (path.endsWith("/")) {
    return path.substring(0, path.length - 1);
  }
  return path;
}
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function appendToMdHeading(md, heading2, content2) {
  const testRegex = new RegExp(`(^|\\n)#\\s?${heading2}\\s*\\n`, "i");
  const replaceRegex = new RegExp(`((\\n|^)#\\s*${heading2}\\s*(\\n|$)(?:.|\\n)*?)(\\n#|$)`, "i");
  if (testRegex.test(md)) {
    return md.replace(replaceRegex, `$1

${content2}
$4`);
  } else {
    const br = md === "" || md.endsWith("\n\n") ? "" : md.endsWith("\n") ? "\n" : "\n\n";
    return `${md}${br}# ${heading2}

${content2}`;
  }
}
var mergeObjects = (target, ...sources) => {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (source === void 0) {
    return target;
  }
  if (isMergebleObject(target) && isMergebleObject(source)) {
    Object.keys(source).forEach((key2) => {
      if (Object.prototype.hasOwnProperty.call(source, key2) && key2 !== "__proto__") {
        if (isMergebleObject(source[key2])) {
          if (!target[key2]) {
            target[key2] = {};
          }
          mergeObjects(target[key2], source[key2]);
        } else {
          target[key2] = source[key2];
        }
      }
    });
  }
  return mergeObjects(target, ...sources);
};
var isObject = (item) => {
  return item !== null && typeof item === "object";
};
var isMergebleObject = (item) => {
  return isObject(item) && !isArray(item);
};
function safeSlugify(value) {
  return (0, import_slugify.default)(value) || value.toString().toLowerCase().replace(/\s+/g, "-").replace(/&/g, "-and-").replace(/\--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
function isAbsoluteUrl(url) {
  return /(?:^[a-z][a-z0-9+.-]*:|\/\/)/i.test(url);
}
function resolveUrl(url, to) {
  let res;
  if (to.startsWith("//")) {
    try {
      res = `${new URL(url).protocol || "https:"}${to}`;
    } catch {
      res = `https:${to}`;
    }
  } else if (isAbsoluteUrl(to)) {
    res = to;
  } else if (!to.startsWith("/")) {
    res = stripTrailingSlash(url) + "/" + to;
  } else {
    try {
      const urlObj = new URL(url);
      urlObj.pathname = to;
      res = urlObj.href;
    } catch {
      res = to;
    }
  }
  return stripTrailingSlash(res);
}
function getBasePath(serverUrl) {
  try {
    return parseURL(serverUrl).pathname;
  } catch (e) {
    return serverUrl;
  }
}
function titleize(text2) {
  return text2.charAt(0).toUpperCase() + text2.slice(1);
}
function removeQueryStringAndHash(serverUrl) {
  try {
    const url = parseURL(serverUrl);
    url.search = "";
    url.hash = "";
    return url.toString();
  } catch (e) {
    return serverUrl;
  }
}
function parseURL(url) {
  if (typeof globalThis.URL !== "undefined") {
    return new globalThis.URL(url);
  }
  const { URL: URL2 } = __require("url");
  return new URL2(url);
}
function escapeHTMLAttrChars(str) {
  return str.replace(/["\\]/g, "\\$&");
}
function unescapeHTMLChars(str) {
  return str.replace(/&#(\d+);/g, (_m, code) => String.fromCharCode(parseInt(code, 10))).replace(/&amp;/g, "&").replace(/&quot;/g, '"');
}
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}

// src/services/Labels.ts
var labels = {
  enum: "Enum",
  enumSingleValue: "Value",
  enumArray: "Items",
  default: "Default",
  deprecated: "Deprecated",
  example: "Example",
  examples: "Examples",
  recursive: "Recursive",
  arrayOf: "Array of ",
  webhook: "Event",
  const: "Value",
  noResultsFound: "No results found",
  download: "Download",
  downloadSpecification: "Download OpenAPI specification",
  responses: "Responses",
  callbackResponses: "Callback responses",
  requestSamples: "Request samples",
  responseSamples: "Response samples"
};
function setRedocLabels(_labels) {
  Object.assign(labels, _labels);
}
function l(key2, idx) {
  const label = labels[key2];
  if (idx !== void 0) {
    return label[idx];
  }
  return label;
}

// src/services/types.ts
var SideNavStyleEnum = /* @__PURE__ */ ((SideNavStyleEnum2) => {
  SideNavStyleEnum2["SummaryOnly"] = "summary-only";
  SideNavStyleEnum2["PathOnly"] = "path-only";
  SideNavStyleEnum2["IdOnly"] = "id-only";
  return SideNavStyleEnum2;
})(SideNavStyleEnum || {});

// src/services/RedocNormalizedOptions.ts
function argValueToBoolean(val, defaultValue) {
  if (val === void 0) {
    return defaultValue || false;
  }
  if (typeof val === "string") {
    return val !== "false";
  }
  return val;
}
function argValueToNumber(value) {
  if (typeof value === "string") {
    return parseInt(value, 10);
  }
  if (typeof value === "number") {
    return value;
  }
}
function argValueToExpandLevel(value, defaultValue = 0) {
  if (value === "all") return Infinity;
  return argValueToNumber(value) || defaultValue;
}
var RedocNormalizedOptions = class _RedocNormalizedOptions {
  static normalizeExpandResponses(value) {
    if (value === "all") {
      return "all";
    }
    if (typeof value === "string") {
      const res = {};
      value.split(",").forEach((code) => {
        res[code.trim()] = true;
      });
      return res;
    } else if (value !== void 0) {
      console.warn(
        `expandResponses must be a string but received value "${value}" of type ${typeof value}`
      );
    }
    return {};
  }
  static normalizeHideHostname(value) {
    return !!value;
  }
  static normalizeScrollYOffset(value) {
    if (typeof value === "string" && !isNumeric(value)) {
      const el = querySelector(value);
      if (!el) {
        console.warn(
          "scrollYOffset value is a selector to non-existing element. Using offset 0 by default"
        );
      }
      const bottom = el && el.getBoundingClientRect().bottom || 0;
      return () => bottom;
    } else if (typeof value === "number" || isNumeric(value)) {
      return () => typeof value === "number" ? value : parseFloat(value);
    } else if (typeof value === "function") {
      return () => {
        const res = value();
        if (typeof res !== "number") {
          console.warn(
            `scrollYOffset should return number but returned value "${res}" of type ${typeof res}`
          );
        }
        return res;
      };
    } else if (value !== void 0) {
      console.warn(
        "Wrong value for scrollYOffset ReDoc option: should be string, number or function"
      );
    }
    return () => 0;
  }
  static normalizeShowExtensions(value) {
    if (typeof value === "undefined") {
      return false;
    }
    if (value === "") {
      return true;
    }
    if (typeof value !== "string") {
      return value;
    }
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        return value.split(",").map((ext) => ext.trim());
    }
  }
  static normalizeSideNavStyle(value) {
    const defaultValue = "summary-only" /* SummaryOnly */;
    if (typeof value !== "string") {
      return defaultValue;
    }
    switch (value) {
      case defaultValue:
        return value;
      case "path-only" /* PathOnly */:
        return "path-only" /* PathOnly */;
      case "id-only" /* IdOnly */:
        return "id-only" /* IdOnly */;
      default:
        return defaultValue;
    }
  }
  static normalizePayloadSampleIdx(value) {
    if (typeof value === "number") {
      return Math.max(0, value);
    }
    if (typeof value === "string") {
      return isFinite(value) ? parseInt(value, 10) : 0;
    }
    return 0;
  }
  static normalizeJsonSampleExpandLevel(level2) {
    if (level2 === "all") {
      return Infinity;
    }
    if (!isNaN(Number(level2))) {
      return Math.ceil(Number(level2));
    }
    return 2;
  }
  static normalizeGeneratedPayloadSamplesMaxDepth(value) {
    if (!isNaN(Number(value))) {
      return Math.max(0, Number(value));
    }
    return 10;
  }
  constructor(raw, defaults4 = {}) {
    var _a2, _b, _c, _d, _e;
    raw = { ...defaults4, ...raw };
    const hook = raw.theme && raw.theme.extensionsHook;
    if (((_a2 = raw.theme) == null ? void 0 : _a2.menu) && !((_b = raw.theme) == null ? void 0 : _b.sidebar)) {
      console.warn('Theme setting "menu" is deprecated. Rename to "sidebar"');
      raw.theme.sidebar = raw.theme.menu;
    }
    if (((_c = raw.theme) == null ? void 0 : _c.codeSample) && !((_d = raw.theme) == null ? void 0 : _d.codeBlock)) {
      console.warn('Theme setting "codeSample" is deprecated. Rename to "codeBlock"');
      raw.theme.codeBlock = raw.theme.codeSample;
    }
    this.theme = resolveTheme(
      mergeObjects({}, theme_default, { ...raw.theme, extensionsHook: void 0 })
    );
    this.theme.extensionsHook = hook;
    setRedocLabels(raw.labels);
    this.scrollYOffset = _RedocNormalizedOptions.normalizeScrollYOffset(raw.scrollYOffset);
    this.hideHostname = _RedocNormalizedOptions.normalizeHideHostname(raw.hideHostname);
    this.expandResponses = _RedocNormalizedOptions.normalizeExpandResponses(raw.expandResponses);
    this.sortRequiredPropsFirst = argValueToBoolean(
      raw.sortRequiredPropsFirst || raw.requiredPropsFirst
    );
    this.sortPropsAlphabetically = argValueToBoolean(raw.sortPropsAlphabetically);
    this.sortEnumValuesAlphabetically = argValueToBoolean(raw.sortEnumValuesAlphabetically);
    this.sortOperationsAlphabetically = argValueToBoolean(raw.sortOperationsAlphabetically);
    this.sortTagsAlphabetically = argValueToBoolean(raw.sortTagsAlphabetically);
    this.nativeScrollbars = argValueToBoolean(raw.nativeScrollbars);
    this.pathInMiddlePanel = argValueToBoolean(raw.pathInMiddlePanel);
    this.sanitize = argValueToBoolean(raw.sanitize || raw.untrustedSpec);
    this.hideDownloadButtons = argValueToBoolean(raw.hideDownloadButtons || raw.hideDownloadButton);
    this.downloadFileName = raw.downloadFileName;
    this.downloadDefinitionUrl = raw.downloadDefinitionUrl;
    this.downloadUrls = raw.downloadUrls;
    this.disableSearch = argValueToBoolean(raw.disableSearch);
    this.onlyRequiredInSamples = argValueToBoolean(raw.onlyRequiredInSamples);
    this.showExtensions = _RedocNormalizedOptions.normalizeShowExtensions(raw.showExtensions);
    this.sideNavStyle = _RedocNormalizedOptions.normalizeSideNavStyle(raw.sideNavStyle);
    this.hideSingleRequestSampleTab = argValueToBoolean(raw.hideSingleRequestSampleTab);
    this.hideRequestPayloadSample = argValueToBoolean(raw.hideRequestPayloadSample);
    this.menuToggle = argValueToBoolean(raw.menuToggle, true);
    this.jsonSamplesExpandLevel = _RedocNormalizedOptions.normalizeJsonSampleExpandLevel(
      raw.jsonSamplesExpandLevel || raw.jsonSampleExpandLevel
    );
    this.enumSkipQuotes = argValueToBoolean(raw.enumSkipQuotes);
    this.hideSchemaTitles = argValueToBoolean(raw.hideSchemaTitles);
    this.simpleOneOfTypeLabel = argValueToBoolean(raw.simpleOneOfTypeLabel);
    this.payloadSampleIdx = _RedocNormalizedOptions.normalizePayloadSampleIdx(raw.payloadSampleIdx);
    this.expandSingleSchemaField = argValueToBoolean(raw.expandSingleSchemaField);
    this.schemasExpansionLevel = argValueToExpandLevel(
      raw.schemasExpansionLevel || raw.schemaExpansionLevel
    );
    this.schemaDefinitionsTagName = raw.schemaDefinitionsTagName;
    this.showObjectSchemaExamples = argValueToBoolean(raw.showObjectSchemaExamples);
    this.showSecuritySchemeType = argValueToBoolean(raw.showSecuritySchemeType);
    this.hideSecuritySection = argValueToBoolean(raw.hideSecuritySection);
    this.unstable_ignoreMimeParameters = argValueToBoolean(raw.unstable_ignoreMimeParameters);
    this.allowedMdComponents = raw.allowedMdComponents || {};
    this.expandDefaultServerVariables = argValueToBoolean(raw.expandDefaultServerVariables);
    this.maxDisplayedEnumValues = argValueToNumber(raw.maxDisplayedEnumValues);
    const ignoreNamedSchemas = isArray(raw.ignoreNamedSchemas) ? raw.ignoreNamedSchemas : (_e = raw.ignoreNamedSchemas) == null ? void 0 : _e.split(",").map((s) => s.trim());
    this.ignoreNamedSchemas = new Set(ignoreNamedSchemas);
    this.hideSchemaPattern = argValueToBoolean(raw.hideSchemaPattern);
    this.generatedSamplesMaxDepth = _RedocNormalizedOptions.normalizeGeneratedPayloadSamplesMaxDepth(
      raw.generatedSamplesMaxDepth || raw.generatedPayloadSamplesMaxDepth
    );
    this.nonce = raw.nonce;
    this.hideFab = argValueToBoolean(raw.hideFab);
    this.minCharacterLengthToInitSearch = argValueToNumber(raw.minCharacterLengthToInitSearch) || 3;
    this.showWebhookVerb = argValueToBoolean(raw.showWebhookVerb);
    this.hidePropertiesPrefix = argValueToBoolean(raw.hidePropertiesPrefix, true);
  }
};

// src/components/ErrorBoundary.tsx
import React from "react";

// src/styled-components.ts
import {
  styled,
  css,
  createGlobalStyle,
  keyframes,
  ThemeProvider
} from "styled-components";
var media = {
  lessThan(breakpoint, print, extra) {
    return (...args) => css`
      @media ${print ? "print, " : ""} screen and (max-width: ${(props) => props.theme.breakpoints[breakpoint]}) ${extra || ""} {
        ${css(...args)};
      }
    `;
  },
  greaterThan(breakpoint) {
    return (...args) => css`
      @media (min-width: ${(props) => props.theme.breakpoints[breakpoint]}) {
        ${css(...args)};
      }
    `;
  },
  between(firstBreakpoint, secondBreakpoint) {
    return (...args) => css`
      @media (min-width: ${(props) => props.theme.breakpoints[firstBreakpoint]}) and (max-width: ${(props) => props.theme.breakpoints[secondBreakpoint]}) {
        ${css(...args)};
      }
    `;
  }
};
var styled_components_default = styled;
function extensionsHook(styledName) {
  return (props) => {
    if (!props.theme.extensionsHook) {
      return;
    }
    return props.theme.extensionsHook(styledName, props);
  };
}

// src/components/ErrorBoundary.tsx
import { jsx, jsxs } from "react/jsx-runtime";
var ErrorWrapper = styled_components_default.div`
  padding: 20px;
  color: red;
`;
var ErrorBoundary = class extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: void 0 };
  }
  componentDidCatch(error) {
    this.setState({ error });
    return false;
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ jsxs(ErrorWrapper, { children: [
        /* @__PURE__ */ jsx("h1", { children: "Something went wrong..." }),
        /* @__PURE__ */ jsxs("small", { children: [
          " ",
          this.state.error.message,
          " "
        ] }),
        /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsxs("details", { children: [
          /* @__PURE__ */ jsx("summary", { children: "Stack trace" }),
          /* @__PURE__ */ jsx("pre", { children: this.state.error.stack })
        ] }) }),
        /* @__PURE__ */ jsxs("small", { children: [
          " ReDoc Version: ",
          "2.5.0"
        ] }),
        " ",
        /* @__PURE__ */ jsx("br", {}),
        /* @__PURE__ */ jsxs("small", { children: [
          " Commit: ",
          "d859658a"
        ] })
      ] });
    }
    return /* @__PURE__ */ jsx(React.Fragment, { children: React.Children.only(this.props.children) });
  }
};

// src/components/Loading/Loading.tsx
import React2 from "react";

// src/components/Loading/Spinner.svg.tsx
import { jsx as jsx2, jsxs as jsxs2 } from "react/jsx-runtime";
var _Spinner = (props) => /* @__PURE__ */ jsxs2("svg", { className: props.className, version: "1.1", width: "512", height: "512", viewBox: "0 0 512 512", children: [
  /* @__PURE__ */ jsx2("path", { d: "M275.682 147.999c0 10.864-8.837 19.661-19.682 19.661v0c-10.875 0-19.681-8.796-19.681-19.661v-96.635c0-10.885 8.806-19.661 19.681-19.661v0c10.844 0 19.682 8.776 19.682 19.661v96.635z" }),
  /* @__PURE__ */ jsx2("path", { d: "M275.682 460.615c0 10.865-8.837 19.682-19.682 19.682v0c-10.875 0-19.681-8.817-19.681-19.682v-96.604c0-10.885 8.806-19.681 19.681-19.681v0c10.844 0 19.682 8.796 19.682 19.682v96.604z" }),
  /* @__PURE__ */ jsx2("path", { d: "M147.978 236.339c10.885 0 19.681 8.755 19.681 19.641v0c0 10.885-8.796 19.702-19.681 19.702h-96.624c-10.864 0-19.661-8.817-19.661-19.702v0c0-10.885 8.796-19.641 19.661-19.641h96.624z" }),
  /* @__PURE__ */ jsx2("path", { d: "M460.615 236.339c10.865 0 19.682 8.755 19.682 19.641v0c0 10.885-8.817 19.702-19.682 19.702h-96.584c-10.885 0-19.722-8.817-19.722-19.702v0c0-10.885 8.837-19.641 19.722-19.641h96.584z" }),
  /* @__PURE__ */ jsx2("path", { d: "M193.546 165.703c7.69 7.66 7.68 20.142 0 27.822v0c-7.701 7.701-20.162 7.701-27.853 0.020l-68.311-68.322c-7.68-7.701-7.68-20.142 0-27.863v0c7.68-7.68 20.121-7.68 27.822 0l68.342 68.342z" }),
  /* @__PURE__ */ jsx2("path", { d: "M414.597 386.775c7.7 7.68 7.7 20.163 0.021 27.863v0c-7.7 7.659-20.142 7.659-27.843-0.062l-68.311-68.26c-7.68-7.7-7.68-20.204 0-27.863v0c7.68-7.7 20.163-7.7 27.842 0l68.291 68.322z" }),
  /* @__PURE__ */ jsx2("path", { d: "M165.694 318.464c7.69-7.7 20.153-7.7 27.853 0v0c7.68 7.659 7.69 20.163 0 27.863l-68.342 68.322c-7.67 7.659-20.142 7.659-27.822-0.062v0c-7.68-7.68-7.68-20.122 0-27.801l68.311-68.322z" }),
  /* @__PURE__ */ jsx2("path", { d: "M386.775 97.362c7.7-7.68 20.142-7.68 27.822 0v0c7.7 7.68 7.7 20.183 0.021 27.863l-68.322 68.311c-7.68 7.68-20.163 7.68-27.843-0.020v0c-7.68-7.68-7.68-20.162 0-27.822l68.322-68.332z" })
] });
var rotate = keyframes`
  0% {
    transform: rotate(0deg); }
  100% {
    transform: rotate(360deg);
  }
`;
var Spinner = styled_components_default(_Spinner)`
  animation: 2s ${rotate} linear infinite;
  width: 50px;
  height: 50px;
  content: '';
  display: inline-block;
  margin-left: -25px;

  path {
    fill: ${(props) => props.color};
  }
`;

// src/components/Loading/Loading.tsx
import { jsx as jsx3, jsxs as jsxs3 } from "react/jsx-runtime";
var LoadingMessage = styled_components_default.div`
  font-family: helvetica, sans;
  width: 100%;
  text-align: center;
  font-size: 25px;
  margin: 30px 0 20px 0;
  color: ${(props) => props.color};
`;
var Loading = class extends React2.PureComponent {
  render() {
    return /* @__PURE__ */ jsxs3("div", { style: { textAlign: "center" }, children: [
      /* @__PURE__ */ jsx3(LoadingMessage, { color: this.props.color, children: "Loading ..." }),
      /* @__PURE__ */ jsx3(Spinner, { color: this.props.color })
    ] });
  }
};

// src/components/Redoc/Redoc.tsx
var import_prop_types = __toESM(require_prop_types(), 1);
import React69 from "react";

// src/components/OptionsProvider.ts
import React3 from "react";
var OptionsContext = React3.createContext(new RedocNormalizedOptions({}));
var OptionsProvider = OptionsContext.Provider;
var OptionsConsumer = OptionsContext.Consumer;

// src/services/AppStore.ts
import { observe } from "mobx";

// src/utils/loadAndBundleSpec.ts
var import_bundle = __toESM(require_bundle(), 1);
var import_config = __toESM(require_config(), 1);
var import_swagger2openapi = __toESM(require_swagger2openapi(), 1);
async function loadAndBundleSpec(specUrlOrObject) {
  const config3 = new import_config.Config({});
  const bundleOpts = {
    config: config3,
    base: IS_BROWSER ? window.location.href : process.cwd()
  };
  if (IS_BROWSER) {
    config3.resolve.http.customFetch = globalThis.fetch;
  }
  if (typeof specUrlOrObject === "object" && specUrlOrObject !== null) {
    bundleOpts["doc"] = {
      source: { absoluteRef: "" },
      parsed: specUrlOrObject
    };
  } else {
    bundleOpts["ref"] = specUrlOrObject;
  }
  const {
    bundle: { parsed }
  } = await (0, import_bundle.bundle)(bundleOpts);
  return parsed.swagger !== void 0 ? convertSwagger2OpenAPI(parsed) : parsed;
}
function convertSwagger2OpenAPI(spec) {
  console.warn("[ReDoc Compatibility mode]: Converting OpenAPI 2.0 to OpenAPI 3.0");
  return new Promise(
    (resolve, reject) => (0, import_swagger2openapi.convertObj)(spec, { patch: true, warnOnly: true, text: "{}", anchors: true }, (err, res) => {
      if (err) {
        return reject(err);
      }
      resolve(res && res.openapi);
    })
  );
}

// src/services/HistoryService.ts
var import_decko = __toESM(require_decko(), 1);

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// src/utils/JsonPointer.ts
var import_json_pointer = __toESM(require_json_pointer(), 1);
var origParse = import_json_pointer.default.parse;
var JsonPointer = class _JsonPointer {
  /**
   * returns last JsonPointer token
   * if level > 1 returns levels last (second last/third last)
   * @example
   * // returns subpath
   * JsonPointerHelper.baseName('/path/0/subpath')
   * // returns foo
   * JsonPointerHelper.baseName('/path/foo/subpath', 2)
   */
  static baseName(pointer, level2 = 1) {
    const tokens = _JsonPointer.parse(pointer);
    return tokens[tokens.length - level2];
  }
  /**
   * returns dirname of pointer
   * if level > 1 returns corresponding dirname in the hierarchy
   * @example
   * // returns /path/0
   * JsonPointerHelper.dirName('/path/0/subpath')
   * // returns /path
   * JsonPointerHelper.dirName('/path/foo/subpath', 2)
   */
  static dirName(pointer, level2 = 1) {
    const tokens = _JsonPointer.parse(pointer);
    return import_json_pointer.default.compile(tokens.slice(0, tokens.length - level2));
  }
  /**
   * returns relative path tokens
   * @example
   * // returns ['subpath']
   * JsonPointerHelper.relative('/path/0', '/path/0/subpath')
   * // returns ['foo', 'subpath']
   * JsonPointerHelper.relative('/path', '/path/foo/subpath')
   */
  static relative(from, to) {
    const fromTokens = _JsonPointer.parse(from);
    const toTokens = _JsonPointer.parse(to);
    return toTokens.slice(fromTokens.length);
  }
  /**
   * overridden JsonPointer original parse to take care of prefixing '#' symbol
   * that is not valid JsonPointer
   */
  static parse(pointer) {
    let ptr = pointer;
    if (ptr.charAt(0) === "#") {
      ptr = ptr.substring(1);
    }
    return origParse(ptr);
  }
  /**
   * Creates a JSON pointer path, by joining one or more tokens to a base path.
   *
   * @param {string} base - The base path
   * @param {string|string[]} tokens - The token(s) to append (e.g. ["name", "first"])
   * @returns {string}
   */
  static join(base2, tokens) {
    const baseTokens = _JsonPointer.parse(base2);
    const resTokens = baseTokens.concat(tokens);
    return import_json_pointer.default.compile(resTokens);
  }
  static get(object, pointer) {
    return import_json_pointer.default.get(object, pointer);
  }
  static compile(tokens) {
    return import_json_pointer.default.compile(tokens);
  }
  static escape(pointer) {
    return import_json_pointer.default.escape(pointer);
  }
};
import_json_pointer.default.parse = JsonPointer.parse;
Object.assign(JsonPointer, import_json_pointer.default);

// src/utils/openapi.ts
var import_url_template = __toESM(require_url_template(), 1);
import { dirname } from "path";
function isWildcardStatusCode(statusCode) {
  return typeof statusCode === "string" && /\dxx/i.test(statusCode);
}
function isStatusCode(statusCode) {
  return statusCode === "default" || isNumeric(statusCode) || isWildcardStatusCode(statusCode);
}
function getStatusCodeType(statusCode, defaultAsError = false) {
  if (statusCode === "default") {
    return defaultAsError ? "error" : "success";
  }
  let code = typeof statusCode === "string" ? parseInt(statusCode, 10) : statusCode;
  if (isWildcardStatusCode(statusCode)) {
    code *= 100;
  }
  if (code < 100 || code > 599) {
    throw new Error("invalid HTTP code");
  }
  let res = "success";
  if (code >= 300 && code < 400) {
    res = "redirect";
  } else if (code >= 400) {
    res = "error";
  } else if (code < 200) {
    res = "info";
  }
  return res;
}
var operationNames = {
  get: true,
  post: true,
  put: true,
  head: true,
  patch: true,
  delete: true,
  options: true,
  $ref: true
};
function isOperationName(key2) {
  return key2 in operationNames;
}
function getOperationSummary(operation) {
  return operation.summary || operation.operationId || operation.description && operation.description.substring(0, 50) || operation.pathName || "<no summary>";
}
var schemaKeywordTypes = {
  multipleOf: "number",
  maximum: "number",
  exclusiveMaximum: "number",
  minimum: "number",
  exclusiveMinimum: "number",
  maxLength: "string",
  minLength: "string",
  pattern: "string",
  contentEncoding: "string",
  contentMediaType: "string",
  items: "array",
  maxItems: "array",
  minItems: "array",
  uniqueItems: "array",
  maxProperties: "object",
  minProperties: "object",
  required: "object",
  additionalProperties: "object",
  unevaluatedProperties: "object",
  properties: "object",
  patternProperties: "object"
};
function detectType(schema) {
  if (schema.type !== void 0 && !isArray(schema.type)) {
    return schema.type;
  }
  const keywords = Object.keys(schemaKeywordTypes);
  for (const keyword2 of keywords) {
    const type = schemaKeywordTypes[keyword2];
    if (schema[keyword2] !== void 0) {
      return type;
    }
  }
  return "any";
}
function isPrimitiveType(schema, type = schema.type) {
  if (schema["x-circular-ref"]) {
    return true;
  }
  if (schema.oneOf !== void 0 || schema.anyOf !== void 0) {
    return false;
  }
  if (schema.if && schema.then || schema.if && schema.else) {
    return false;
  }
  let isPrimitive = true;
  const isArrayType = isArray(type);
  if (type === "object" || isArrayType && (type == null ? void 0 : type.includes("object"))) {
    isPrimitive = schema.properties !== void 0 ? Object.keys(schema.properties).length === 0 : schema.additionalProperties === void 0 && schema.unevaluatedProperties === void 0 && schema.patternProperties === void 0;
  }
  if (isArray(schema.items) || isArray(schema.prefixItems)) {
    return false;
  }
  if (schema.items !== void 0 && !isBoolean(schema.items) && (type === "array" || isArrayType && (type == null ? void 0 : type.includes("array")))) {
    isPrimitive = isPrimitiveType(schema.items, schema.items.type);
  }
  return isPrimitive;
}
function isJsonLike(contentType) {
  return contentType.search(/json/i) !== -1;
}
function isFormUrlEncoded(contentType) {
  return contentType === "application/x-www-form-urlencoded";
}
function delimitedEncodeField(fieldVal, fieldName, delimiter) {
  if (isArray(fieldVal)) {
    return fieldVal.map((v) => v.toString()).join(delimiter);
  } else if (typeof fieldVal === "object") {
    return Object.keys(fieldVal).map((k) => `${k}${delimiter}${fieldVal[k]}`).join(delimiter);
  } else {
    return fieldName + "=" + fieldVal.toString();
  }
}
function deepObjectEncodeField(fieldVal, fieldName) {
  if (isArray(fieldVal)) {
    console.warn("deepObject style cannot be used with array value:" + fieldVal.toString());
    return "";
  } else if (typeof fieldVal === "object") {
    return Object.keys(fieldVal).map((k) => `${fieldName}[${k}]=${fieldVal[k]}`).join("&");
  } else {
    console.warn("deepObject style cannot be used with non-object value:" + fieldVal.toString());
    return "";
  }
}
function serializeFormValue(name2, explode, value) {
  const safeName = "__redoc_param_name__";
  const suffix = explode ? "*" : "";
  const template = import_url_template.default.parse(`{?${safeName}${suffix}}`);
  return template.expand({ [safeName]: value }).substring(1).replace(/__redoc_param_name__/g, name2);
}
function urlFormEncodePayload(payload, encoding = {}) {
  if (isArray(payload)) {
    throw new Error("Payload must have fields: " + payload.toString());
  } else {
    return Object.keys(payload).map((fieldName) => {
      const fieldVal = payload[fieldName];
      const { style = "form", explode = true } = encoding[fieldName] || {};
      switch (style) {
        case "form":
          return serializeFormValue(fieldName, explode, fieldVal);
        case "spaceDelimited":
          return delimitedEncodeField(fieldVal, fieldName, "%20");
        case "pipeDelimited":
          return delimitedEncodeField(fieldVal, fieldName, "|");
        case "deepObject":
          return deepObjectEncodeField(fieldVal, fieldName);
        default:
          console.warn("Incorrect or unsupported encoding style: " + style);
          return "";
      }
    }).join("&");
  }
}
function serializePathParameter(name2, style, explode, value) {
  const suffix = explode ? "*" : "";
  let prefix = "";
  if (style === "label") {
    prefix = ".";
  } else if (style === "matrix") {
    prefix = ";";
  }
  const safeName = "__redoc_param_name__";
  const template = import_url_template.default.parse(`{${prefix}${safeName}${suffix}}`);
  return template.expand({ [safeName]: value }).replace(/__redoc_param_name__/g, name2);
}
function serializeQueryParameter(name2, style, explode, value) {
  switch (style) {
    case "form":
      return serializeFormValue(name2, explode, value);
    case "spaceDelimited":
      if (!isArray(value)) {
        console.warn("The style spaceDelimited is only applicable to arrays");
        return "";
      }
      if (explode) {
        return serializeFormValue(name2, explode, value);
      }
      return `${name2}=${value.join("%20")}`;
    case "pipeDelimited":
      if (!isArray(value)) {
        console.warn("The style pipeDelimited is only applicable to arrays");
        return "";
      }
      if (explode) {
        return serializeFormValue(name2, explode, value);
      }
      return `${name2}=${value.join("|")}`;
    case "deepObject":
      if (!explode || isArray(value) || typeof value !== "object") {
        console.warn("The style deepObject is only applicable for objects with explode=true");
        return "";
      }
      return deepObjectEncodeField(value, name2);
    default:
      console.warn("Unexpected style for query: " + style);
      return "";
  }
}
function serializeHeaderParameter(style, explode, value) {
  switch (style) {
    case "simple":
      const suffix = explode ? "*" : "";
      const name2 = "__redoc_param_name__";
      const template = import_url_template.default.parse(`{${name2}${suffix}}`);
      return decodeURIComponent(template.expand({ [name2]: value }));
    default:
      console.warn("Unexpected style for header: " + style);
      return "";
  }
}
function serializeCookieParameter(name2, style, explode, value) {
  switch (style) {
    case "form":
      return serializeFormValue(name2, explode, value);
    default:
      console.warn("Unexpected style for cookie: " + style);
      return "";
  }
}
function serializeParameterValueWithMime(value, mime) {
  if (isJsonLike(mime)) {
    return JSON.stringify(value);
  } else {
    console.warn(`Parameter serialization as ${mime} is not supported`);
    return "";
  }
}
function serializeParameterValue(parameter, value) {
  const { name: name2, style, explode = false, serializationMime } = parameter;
  if (serializationMime) {
    switch (parameter.in) {
      case "path":
      case "header":
        return serializeParameterValueWithMime(value, serializationMime);
      case "cookie":
      case "query":
        return `${name2}=${serializeParameterValueWithMime(value, serializationMime)}`;
      default:
        console.warn("Unexpected parameter location: " + parameter.in);
        return "";
    }
  }
  if (!style) {
    console.warn(`Missing style attribute or content for parameter ${name2}`);
    return "";
  }
  switch (parameter.in) {
    case "path":
      return serializePathParameter(name2, style, explode, value);
    case "query":
      return serializeQueryParameter(name2, style, explode, value);
    case "header":
      return serializeHeaderParameter(style, explode, value);
    case "cookie":
      return serializeCookieParameter(name2, style, explode, value);
    default:
      console.warn("Unexpected parameter location: " + parameter.in);
      return "";
  }
}
function getSerializedValue(field, example) {
  if (field.in) {
    return decodeURIComponent(serializeParameterValue(field, example));
  } else {
    return typeof example === "object" ? example : String(example);
  }
}
function langFromMime(contentType) {
  if (contentType.search(/xml/i) !== -1) {
    return "xml";
  }
  if (contentType.search(/csv/i) !== -1) {
    return "csv";
  }
  if (contentType.search(/plain/i) !== -1) {
    return "tex";
  }
  return "clike";
}
var DEFINITION_NAME_REGEX = /^#\/components\/(schemas|pathItems)\/([^/]+)$/;
function isNamedDefinition(pointer) {
  return DEFINITION_NAME_REGEX.test(pointer || "");
}
function getDefinitionName(pointer) {
  var _a2;
  const [name2] = ((_a2 = pointer == null ? void 0 : pointer.match(DEFINITION_NAME_REGEX)) == null ? void 0 : _a2.reverse()) || [];
  return name2;
}
function humanizeMultipleOfConstraint(multipleOf) {
  if (multipleOf === void 0) {
    return;
  }
  const strigifiedMultipleOf = multipleOf.toString(10);
  if (!/^0\.0*1$/.test(strigifiedMultipleOf)) {
    return `multiple of ${strigifiedMultipleOf}`;
  }
  return `decimal places <= ${strigifiedMultipleOf.split(".")[1].length}`;
}
function humanizeRangeConstraint(description, min, max) {
  let stringRange;
  if (min !== void 0 && max !== void 0) {
    if (min === max) {
      stringRange = `= ${min} ${description}`;
    } else {
      stringRange = `[ ${min} .. ${max} ] ${description}`;
    }
  } else if (max !== void 0) {
    stringRange = `<= ${max} ${description}`;
  } else if (min !== void 0) {
    if (min === 1) {
      stringRange = "non-empty";
    } else {
      stringRange = `>= ${min} ${description}`;
    }
  }
  return stringRange;
}
function humanizeNumberRange(schema) {
  var _a2, _b;
  const minimum = typeof schema.exclusiveMinimum === "number" ? Math.min(schema.exclusiveMinimum, (_a2 = schema.minimum) != null ? _a2 : Infinity) : schema.minimum;
  const maximum = typeof schema.exclusiveMaximum === "number" ? Math.max(schema.exclusiveMaximum, (_b = schema.maximum) != null ? _b : -Infinity) : schema.maximum;
  const exclusiveMinimum = typeof schema.exclusiveMinimum === "number" || schema.exclusiveMinimum;
  const exclusiveMaximum = typeof schema.exclusiveMaximum === "number" || schema.exclusiveMaximum;
  if (minimum !== void 0 && maximum !== void 0) {
    return `${exclusiveMinimum ? "( " : "[ "}${minimum} .. ${maximum}${exclusiveMaximum ? " )" : " ]"}`;
  } else if (maximum !== void 0) {
    return `${exclusiveMaximum ? "< " : "<= "}${maximum}`;
  } else if (minimum !== void 0) {
    return `${exclusiveMinimum ? "> " : ">= "}${minimum}`;
  }
}
function humanizeConstraints(schema) {
  const res = [];
  const stringRange = humanizeRangeConstraint("characters", schema.minLength, schema.maxLength);
  if (stringRange !== void 0) {
    res.push(stringRange);
  }
  const arrayRange = humanizeRangeConstraint("items", schema.minItems, schema.maxItems);
  if (arrayRange !== void 0) {
    res.push(arrayRange);
  }
  const propertiesRange = humanizeRangeConstraint(
    "properties",
    schema.minProperties,
    schema.maxProperties
  );
  if (propertiesRange !== void 0) {
    res.push(propertiesRange);
  }
  const multipleOfConstraint = humanizeMultipleOfConstraint(schema.multipleOf);
  if (multipleOfConstraint !== void 0) {
    res.push(multipleOfConstraint);
  }
  const numberRange = humanizeNumberRange(schema);
  if (numberRange !== void 0) {
    res.push(numberRange);
  }
  if (schema.uniqueItems) {
    res.push("unique");
  }
  return res;
}
function sortByRequired(fields, order = []) {
  const unrequiredFields = [];
  const orderedFields = [];
  const unorderedFields = [];
  fields.forEach((field) => {
    if (field.required) {
      order.includes(field.name) ? orderedFields.push(field) : unorderedFields.push(field);
    } else {
      unrequiredFields.push(field);
    }
  });
  orderedFields.sort((a, b) => order.indexOf(a.name) - order.indexOf(b.name));
  return [...orderedFields, ...unorderedFields, ...unrequiredFields];
}
function sortByField(fields, param) {
  return [...fields].sort((a, b) => {
    return a[param].localeCompare(b[param]);
  });
}
function mergeParams(parser3, pathParams = [], operationParams = []) {
  const operationParamNames = {};
  operationParams.forEach((param) => {
    ({ resolved: param } = parser3.deref(param));
    operationParamNames[param.name + "_" + param.in] = true;
  });
  pathParams = pathParams.filter((param) => {
    ({ resolved: param } = parser3.deref(param));
    return !operationParamNames[param.name + "_" + param.in];
  });
  return pathParams.concat(operationParams);
}
function mergeSimilarMediaTypes(types2) {
  const mergedTypes = {};
  Object.keys(types2).forEach((name2) => {
    const mime = types2[name2];
    const normalizedMimeName = name2.split(";")[0].trim();
    if (!mergedTypes[normalizedMimeName]) {
      mergedTypes[normalizedMimeName] = mime;
      return;
    }
    mergedTypes[normalizedMimeName] = { ...mergedTypes[normalizedMimeName], ...mime };
  });
  return mergedTypes;
}
function expandDefaultServerVariables(url, variables = {}) {
  return url.replace(
    /(?:{)([\w-.]+)(?:})/g,
    (match, name2) => variables[name2] && variables[name2].default || match
  );
}
function normalizeServers(specUrl, servers) {
  const getHref = () => {
    if (!IS_BROWSER) {
      return "";
    }
    const href = window.location.href;
    return href.endsWith(".html") ? dirname(href) : href;
  };
  const baseUrl = specUrl === void 0 ? removeQueryStringAndHash(getHref()) : dirname(specUrl);
  if (servers.length === 0) {
    servers = [
      {
        url: "/"
      }
    ];
  }
  function normalizeUrl(url) {
    return resolveUrl(baseUrl, url);
  }
  return servers.map((server) => {
    return {
      ...server,
      url: normalizeUrl(server.url),
      description: server.description || ""
    };
  });
}
var SECURITY_DEFINITIONS_JSX_NAME = "SecurityDefinitions";
var OLD_SECURITY_DEFINITIONS_JSX_NAME = "security-definitions";
var SCHEMA_DEFINITION_JSX_NAME = "SchemaDefinition";
var SECURITY_SCHEMES_SECTION_PREFIX = "section/Authentication/";
function setSecuritySchemePrefix(prefix) {
  SECURITY_SCHEMES_SECTION_PREFIX = prefix;
}
var shortenHTTPVerb = (verb) => ({
  delete: "del",
  options: "opts"
})[verb] || verb;
function isRedocExtension(key2) {
  const redocExtensions = {
    "x-circular-ref": true,
    "x-parentRefs": true,
    "x-refsStack": true,
    "x-code-samples": true,
    // deprecated
    "x-codeSamples": true,
    "x-displayName": true,
    "x-examples": true,
    "x-enumDescriptions": true,
    "x-logo": true,
    "x-nullable": true,
    "x-servers": true,
    "x-tagGroups": true,
    "x-traitTag": true,
    "x-badges": true,
    "x-additionalPropertiesName": true,
    "x-explicitMappingOnly": true
  };
  return key2 in redocExtensions;
}
function extractExtensions(obj, showExtensions) {
  return Object.keys(obj).filter((key2) => {
    if (showExtensions === true) {
      return key2.startsWith("x-") && !isRedocExtension(key2);
    }
    return key2.startsWith("x-") && showExtensions.indexOf(key2) > -1;
  }).reduce((acc, key2) => {
    acc[key2] = obj[key2];
    return acc;
  }, {});
}
function pluralizeType(displayType) {
  return displayType.split(" or ").map((type) => type.replace(/^(string|object|number|integer|array|boolean)s?( ?.*)/, "$1s$2")).join(" or ");
}
function getContentWithLegacyExamples(info) {
  let mediaContent = info.content;
  const xExamples = info["x-examples"];
  const xExample = info["x-example"];
  if (xExamples) {
    mediaContent = { ...mediaContent };
    for (const mime of Object.keys(xExamples)) {
      const examples = xExamples[mime];
      mediaContent[mime] = {
        ...mediaContent[mime],
        examples
      };
    }
  } else if (xExample) {
    mediaContent = { ...mediaContent };
    for (const mime of Object.keys(xExample)) {
      const example = xExample[mime];
      mediaContent[mime] = {
        ...mediaContent[mime],
        example
      };
    }
  }
  return mediaContent;
}

// src/utils/highlight.ts
var import_prismjs = __toESM(require_prism(), 1);

// node_modules/prismjs/components/prism-bash.js
(function(Prism3) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism3.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism3.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside2 = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside2[toBeCopied[i]] = Prism3.languages.bash[toBeCopied[i]];
  }
  Prism3.languages.sh = Prism3.languages.bash;
  Prism3.languages.shell = Prism3.languages.bash;
})(Prism);

// node_modules/prismjs/components/prism-c.js
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: true
        },
        Prism.languages.c["string"]
      ],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: true
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];

// node_modules/prismjs/components/prism-clike.js
Prism.languages.clike = {
  "comment": [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }
  ],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};

// node_modules/prismjs/components/prism-coffeescript.js
(function(Prism3) {
  var comment2 = /#(?!\{).+/;
  var interpolation = {
    pattern: /#\{[^}]+\}/,
    alias: "variable"
  };
  Prism3.languages.coffeescript = Prism3.languages.extend("javascript", {
    "comment": comment2,
    "string": [
      // Strings are multiline
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        greedy: true
      },
      {
        // Strings are multiline
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        greedy: true,
        inside: {
          "interpolation": interpolation
        }
      }
    ],
    "keyword": /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
    "class-member": {
      pattern: /@(?!\d)\w+/,
      alias: "variable"
    }
  });
  Prism3.languages.insertBefore("coffeescript", "comment", {
    "multiline-comment": {
      pattern: /###[\s\S]+?###/,
      alias: "comment"
    },
    // Block regexp can contain comments and interpolation
    "block-regex": {
      pattern: /\/{3}[\s\S]*?\/{3}/,
      alias: "regex",
      inside: {
        "comment": comment2,
        "interpolation": interpolation
      }
    }
  });
  Prism3.languages.insertBefore("coffeescript", "string", {
    "inline-javascript": {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      inside: {
        "delimiter": {
          pattern: /^`|`$/,
          alias: "punctuation"
        },
        "script": {
          pattern: /[\s\S]+/,
          alias: "language-javascript",
          inside: Prism3.languages.javascript
        }
      }
    },
    // Block strings
    "multiline-string": [
      {
        pattern: /'''[\s\S]*?'''/,
        greedy: true,
        alias: "string"
      },
      {
        pattern: /"""[\s\S]*?"""/,
        greedy: true,
        alias: "string",
        inside: {
          interpolation
        }
      }
    ]
  });
  Prism3.languages.insertBefore("coffeescript", "keyword", {
    // Object property
    "property": /(?!\d)\w+(?=\s*:(?!:))/
  });
  delete Prism3.languages.coffeescript["template-string"];
  Prism3.languages.coffee = Prism3.languages.coffeescript;
})(Prism);

// node_modules/prismjs/components/prism-cpp.js
(function(Prism3) {
  var keyword2 = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword2.source;
  });
  Prism3.languages.cpp = Prism3.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword2.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword2,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism3.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return modName;
        }) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism3.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism3.languages.cpp
        }
      }
    }
  });
  Prism3.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism3.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism3.languages.extend("cpp", {})
    }
  });
  Prism3.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism3.languages.cpp["base-clause"]);
})(Prism);

// node_modules/prismjs/components/prism-csharp.js
(function(Prism3) {
  function replace2(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m, index2) {
      return "(?:" + replacements[+index2] + ")";
    });
  }
  function re(pattern, replacements, flags) {
    return RegExp(replace2(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i = 0; i < depthLog2; i++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace2(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier = replace2(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace2(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
  var tupleElement = replace2(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace2(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace2(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism3.languages.csharp = Prism3.languages.extend("clike", {
    "string": [
      {
        pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
        lookbehind: true,
        greedy: true
      }
    ],
    "class-name": [
      {
        // Using static
        // using static System.Math;
        pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Using alias (type)
        // using Project = PC.MyCompany.Project;
        pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Using alias (alias)
        // using Project = PC.MyCompany.Project;
        pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
        lookbehind: true
      },
      {
        // Type declarations
        // class Foo<A, B>
        // interface Foo<out A, B>
        pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Single catch exception declaration
        // catch(Foo)
        // (things like catch(Foo e) is covered by variable declaration)
        pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Name of the type parameter of generic constraints
        // where Foo : class
        pattern: re(/(\bwhere\s+)<<0>>/.source, [name2]),
        lookbehind: true
      },
      {
        // Casts and checks via as and is.
        // as Foo<A>, is Bar<B>
        // (things like if(a is Foo b) is covered by variable declaration)
        pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Variable, field and parameter declaration
        // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
        pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
        inside: typeInside
      }
    ],
    "keyword": keywords,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism3.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism3.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism3.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re(
        /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
        [typeDeclarationKeywords, genericName, name2, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]
      ),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism3.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace2(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace2(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
  Prism3.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism3.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace2(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism3.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism3.languages.insertBefore("csharp", "string", {
    "interpolation-string": [
      {
        pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(mInterpolation, mInterpolationRound)
      },
      {
        pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(sInterpolation, sInterpolationRound)
      }
    ],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism3.languages.dotnet = Prism3.languages.cs = Prism3.languages.csharp;
})(Prism);

// node_modules/prismjs/components/prism-go.js
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];

// node_modules/prismjs/components/prism-http.js
(function(Prism3) {
  function headerValueOf(name2) {
    return RegExp("(^(?:" + name2 + "):[ 	]*(?![ 	]))[^]+", "i");
  }
  Prism3.languages.http = {
    "request-line": {
      pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
      inside: {
        // HTTP Method
        "method": {
          pattern: /^[A-Z]+\b/,
          alias: "property"
        },
        // Request Target e.g. http://example.com, /path/to/file
        "request-target": {
          pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
          lookbehind: true,
          alias: "url",
          inside: Prism3.languages.uri
        },
        // HTTP Version
        "http-version": {
          pattern: /^(\s)HTTP\/[\d.]+/,
          lookbehind: true,
          alias: "property"
        }
      }
    },
    "response-status": {
      pattern: /^HTTP\/[\d.]+ \d+ .+/m,
      inside: {
        // HTTP Version
        "http-version": {
          pattern: /^HTTP\/[\d.]+/,
          alias: "property"
        },
        // Status Code
        "status-code": {
          pattern: /^(\s)\d+(?=\s)/,
          lookbehind: true,
          alias: "number"
        },
        // Reason Phrase
        "reason-phrase": {
          pattern: /^(\s).+/,
          lookbehind: true,
          alias: "string"
        }
      }
    },
    "header": {
      pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
      inside: {
        "header-value": [
          {
            pattern: headerValueOf(/Content-Security-Policy/.source),
            lookbehind: true,
            alias: ["csp", "languages-csp"],
            inside: Prism3.languages.csp
          },
          {
            pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
            lookbehind: true,
            alias: ["hpkp", "languages-hpkp"],
            inside: Prism3.languages.hpkp
          },
          {
            pattern: headerValueOf(/Strict-Transport-Security/.source),
            lookbehind: true,
            alias: ["hsts", "languages-hsts"],
            inside: Prism3.languages.hsts
          },
          {
            pattern: headerValueOf(/[^:]+/.source),
            lookbehind: true
          }
        ],
        "header-name": {
          pattern: /^[^:]+/,
          alias: "keyword"
        },
        "punctuation": /^:/
      }
    }
  };
  var langs = Prism3.languages;
  var httpLanguages = {
    "application/javascript": langs.javascript,
    "application/json": langs.json || langs.javascript,
    "application/xml": langs.xml,
    "text/xml": langs.xml,
    "text/html": langs.html,
    "text/css": langs.css,
    "text/plain": langs.plain
  };
  var suffixTypes = {
    "application/json": true,
    "application/xml": true
  };
  function getSuffixPattern(contentType2) {
    var suffix = contentType2.replace(/^[a-z]+\//, "");
    var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
    return "(?:" + contentType2 + "|" + suffixPattern + ")";
  }
  var options2;
  for (var contentType in httpLanguages) {
    if (httpLanguages[contentType]) {
      options2 = options2 || {};
      var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
      options2[contentType.replace(/\//g, "-")] = {
        pattern: RegExp(
          "(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
          // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
          // However, when writing code by hand (e.g. to display on a website) people can forget about this,
          // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
          // the body does not start with a [\w-] character (as headers do).
          /[^ \t\w-][\s\S]*/.source,
          "i"
        ),
        lookbehind: true,
        inside: httpLanguages[contentType]
      };
    }
  }
  if (options2) {
    Prism3.languages.insertBefore("http", "header", options2);
  }
})(Prism);

// node_modules/prismjs/components/prism-java.js
(function(Prism3) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism3.languages.java = Prism3.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "function": [
      Prism3.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism3.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism3.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);

// node_modules/prismjs/components/prism-lua.js
Prism.languages.lua = {
  "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
  // \z may be used to skip the following space
  "string": {
    pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
    greedy: true
  },
  "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
  "function": /(?!\d)\w+(?=\s*(?:[({]))/,
  "operator": [
    /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
    {
      // Match ".." but don't break "..."
      pattern: /(^|[^.])\.\.(?!\.)/,
      lookbehind: true
    }
  ],
  "punctuation": /[\[\](){},;]|\.+|:+/
};

// node_modules/prismjs/components/prism-markup-templating.js
(function(Prism3) {
  function getPlaceholder(language2, index2) {
    return "___" + language2.toUpperCase() + index2 + "___";
  }
  Object.defineProperties(Prism3.languages["markup-templating"] = {}, {
    buildPlaceholders: {
      /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */
      value: function(env, language2, placeholderPattern, replaceFilter) {
        if (env.language !== language2) {
          return;
        }
        var tokenStack = env.tokenStack = [];
        env.code = env.code.replace(placeholderPattern, function(match) {
          if (typeof replaceFilter === "function" && !replaceFilter(match)) {
            return match;
          }
          var i = tokenStack.length;
          var placeholder2;
          while (env.code.indexOf(placeholder2 = getPlaceholder(language2, i)) !== -1) {
            ++i;
          }
          tokenStack[i] = match;
          return placeholder2;
        });
        env.grammar = Prism3.languages.markup;
      }
    },
    tokenizePlaceholders: {
      /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */
      value: function(env, language2) {
        if (env.language !== language2 || !env.tokenStack) {
          return;
        }
        env.grammar = Prism3.languages[language2];
        var j = 0;
        var keys2 = Object.keys(env.tokenStack);
        function walkTokens2(tokens) {
          for (var i = 0; i < tokens.length; i++) {
            if (j >= keys2.length) {
              break;
            }
            var token = tokens[i];
            if (typeof token === "string" || token.content && typeof token.content === "string") {
              var k = keys2[j];
              var t2 = env.tokenStack[k];
              var s = typeof token === "string" ? token : token.content;
              var placeholder2 = getPlaceholder(language2, k);
              var index2 = s.indexOf(placeholder2);
              if (index2 > -1) {
                ++j;
                var before = s.substring(0, index2);
                var middle = new Prism3.Token(language2, Prism3.tokenize(t2, env.grammar), "language-" + language2, t2);
                var after = s.substring(index2 + placeholder2.length);
                var replacement = [];
                if (before) {
                  replacement.push.apply(replacement, walkTokens2([before]));
                }
                replacement.push(middle);
                if (after) {
                  replacement.push.apply(replacement, walkTokens2([after]));
                }
                if (typeof token === "string") {
                  tokens.splice.apply(tokens, [i, 1].concat(replacement));
                } else {
                  token.content = replacement;
                }
              }
            } else if (token.content) {
              walkTokens2(token.content);
            }
          }
          return tokens;
        }
        walkTokens2(env.tokens);
      }
    }
  });
})(Prism);

// node_modules/prismjs/components/prism-markup.js
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside2 = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside2["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside: inside2
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;

// node_modules/prismjs/components/prism-objectivec.js
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;

// node_modules/prismjs/components/prism-perl.js
(function(Prism3) {
  var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
  Prism3.languages.perl = {
    "comment": [
      {
        // POD
        pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\$])#.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    // TODO Could be nice to handle Heredoc too.
    "string": [
      {
        pattern: RegExp(
          /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            // q/.../
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            // q a...a
            // eslint-disable-next-line regexp/strict
            /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            // q(...)
            // q{...}
            // q[...]
            // q<...>
            brackets
          ].join("|") + ")"
        ),
        greedy: true
      },
      // "...", `...`
      {
        pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
        greedy: true
      },
      // '...'
      // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
      {
        pattern: /'(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      }
    ],
    "regex": [
      {
        pattern: RegExp(
          /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            // m/.../
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            // m a...a
            // eslint-disable-next-line regexp/strict
            /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            // m(...)
            // m{...}
            // m[...]
            // m<...>
            brackets
          ].join("|") + ")" + /[msixpodualngc]*/.source
        ),
        greedy: true
      },
      // The lookbehinds prevent -s from breaking
      {
        pattern: RegExp(
          /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            // s/.../.../
            // eslint-disable-next-line regexp/strict
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            // s a...a...a
            // eslint-disable-next-line regexp/strict
            /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
            // s(...)(...)
            // s{...}{...}
            // s[...][...]
            // s<...><...>
            // s(...)[...]
            brackets + /\s*/.source + brackets
          ].join("|") + ")" + /[msixpodualngcer]*/.source
        ),
        lookbehind: true,
        greedy: true
      },
      // /.../
      // The look-ahead tries to prevent two divisions on
      // the same line from being highlighted as regex.
      // This does not support multi-line regex.
      {
        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
        greedy: true
      }
    ],
    // FIXME Not sure about the handling of ::, ', and #
    "variable": [
      // ${^POSTMATCH}
      /[&*$@%]\{\^[A-Z]+\}/,
      // $^V
      /[&*$@%]\^[A-Z_]/,
      // ${...}
      /[&*$@%]#?(?=\{)/,
      // $foo
      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
      // $1
      /[&*$@%]\d+/,
      // $_, @_, %!
      // The negative lookahead prevents from breaking the %= operator
      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
    ],
    "filehandle": {
      // <>, <FOO>, _
      pattern: /<(?![<=])\S*?>|\b_\b/,
      alias: "symbol"
    },
    "v-string": {
      // v1.2, 1.2.3
      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
      alias: "string"
    },
    "function": {
      pattern: /(\bsub[ \t]+)\w+/,
      lookbehind: true
    },
    "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
    "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
    "punctuation": /[{}[\];(),:]/
  };
})(Prism);

// node_modules/prismjs/components/prism-php.js
(function(Prism3) {
  var comment2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
  var constant = [
    {
      pattern: /\b(?:false|true)\b/i,
      alias: "boolean"
    },
    {
      pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
      greedy: true,
      lookbehind: true
    },
    {
      pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
      greedy: true,
      lookbehind: true
    },
    /\b(?:null)\b/i,
    /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
  ];
  var number2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
  var operator2 = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
  var punctuation3 = /[{}\[\](),:;]/;
  Prism3.languages.php = {
    "delimiter": {
      pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
      alias: "important"
    },
    "comment": comment2,
    "variable": /\$+(?:\w+\b|(?=\{))/,
    "package": {
      pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "class-name-definition": {
      pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    "function-definition": {
      pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true,
      alias: "function"
    },
    "keyword": [
      {
        pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
        alias: "type-declaration",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        // yield from
        pattern: /(\byield\s+)from\b/i,
        lookbehind: true
      },
      // `class` is always a keyword unlike other keywords
      /\bclass\b/i,
      {
        // https://www.php.net/manual/en/reserved.keywords.php
        //
        // keywords cannot be preceded by "->"
        // the complex lookbehind means `(?<!(?:->|::)\s*)`
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
        lookbehind: true
      }
    ],
    "argument-name": {
      pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
      lookbehind: true
    },
    "class-name": [
      {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /\b[a-z_]\w*(?=\s*\$)/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-declaration"],
        greedy: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /\b[a-z_]\w*(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
        alias: ["class-name-fully-qualified", "static-context"],
        greedy: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-hint"],
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: ["class-name-fully-qualified", "return-type"],
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      }
    ],
    "constant": constant,
    "function": {
      pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "property": {
      pattern: /(->\s*)\w+/,
      lookbehind: true
    },
    "number": number2,
    "operator": operator2,
    "punctuation": punctuation3
  };
  var string_interpolation = {
    pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
    lookbehind: true,
    inside: Prism3.languages.php
  };
  var string2 = [
    {
      pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
      alias: "nowdoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: {
            "punctuation": /^<<<'?|[';]$/
          }
        }
      }
    },
    {
      pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: {
            "punctuation": /^<<<"?|[";]$/
          }
        },
        "interpolation": string_interpolation
      }
    },
    {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      alias: "backtick-quoted-string",
      greedy: true
    },
    {
      pattern: /'(?:\\[\s\S]|[^\\'])*'/,
      alias: "single-quoted-string",
      greedy: true
    },
    {
      pattern: /"(?:\\[\s\S]|[^\\"])*"/,
      alias: "double-quoted-string",
      greedy: true,
      inside: {
        "interpolation": string_interpolation
      }
    }
  ];
  Prism3.languages.insertBefore("php", "variable", {
    "string": string2,
    "attribute": {
      pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
      greedy: true,
      inside: {
        "attribute-content": {
          pattern: /^(#\[)[\s\S]+(?=\]$)/,
          lookbehind: true,
          // inside can appear subset of php
          inside: {
            "comment": comment2,
            "string": string2,
            "attribute-class-name": [
              {
                pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                alias: "class-name",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                alias: [
                  "class-name",
                  "class-name-fully-qualified"
                ],
                greedy: true,
                lookbehind: true,
                inside: {
                  "punctuation": /\\/
                }
              }
            ],
            "constant": constant,
            "number": number2,
            "operator": operator2,
            "punctuation": punctuation3
          }
        },
        "delimiter": {
          pattern: /^#\[|\]$/,
          alias: "punctuation"
        }
      }
    }
  });
  Prism3.hooks.add("before-tokenize", function(env) {
    if (!/<\?/.test(env.code)) {
      return;
    }
    var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
    Prism3.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
  });
  Prism3.hooks.add("after-tokenize", function(env) {
    Prism3.languages["markup-templating"].tokenizePlaceholders(env, "php");
  });
})(Prism);

// node_modules/prismjs/components/prism-python.js
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;

// node_modules/prismjs/components/prism-q.js
Prism.languages.q = {
  "string": /"(?:\\.|[^"\\\r\n])*"/,
  "comment": [
    // From http://code.kx.com/wiki/Reference/Slash:
    // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
    {
      pattern: /([\t )\]}])\/.*/,
      lookbehind: true,
      greedy: true
    },
    // From http://code.kx.com/wiki/Reference/Slash:
    // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
    // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
    // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
    // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
    {
      pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
      lookbehind: true,
      greedy: true
    },
    // From http://code.kx.com/wiki/Reference/Slash:
    // A \ on a line by itself with no preceding matching / will comment to end of file.
    {
      pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
      greedy: true
    },
    {
      pattern: /^#!.+/m,
      greedy: true
    }
  ],
  "symbol": /`(?::\S+|[\w.]*)/,
  "datetime": {
    pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
    alias: "number"
  },
  // The negative look-ahead prevents bad highlighting
  // of verbs 0: and 1:
  "number": /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
  "keyword": /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
  "adverb": {
    pattern: /['\/\\]:?|\beach\b/,
    alias: "function"
  },
  "verb": {
    pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
    alias: "operator"
  },
  "punctuation": /[(){}\[\];.]/
};

// node_modules/prismjs/components/prism-ruby.js
(function(Prism3) {
  Prism3.languages.ruby = Prism3.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism3.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism3.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism3.languages.ruby.function;
  var percentExpression = "(?:" + [
    /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
    /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
    /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
    /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
    /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
  ].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism3.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [
      {
        pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "regex": /[\s\S]+/
        }
      },
      {
        pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "regex": /[\s\S]+/
        }
      }
    ],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [
      {
        pattern: RegExp(/(^|[^:]):/.source + symbolName),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
        lookbehind: true,
        greedy: true
      }
    ],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism3.languages.insertBefore("ruby", "string", {
    "string-literal": [
      {
        pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
            inside: {
              "symbol": /\b\w+/,
              "punctuation": /^<<[-~]?/
            }
          },
          "interpolation": interpolation,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
            inside: {
              "symbol": /\b\w+/,
              "punctuation": /^<<[-~]?'|'$/
            }
          },
          "string": /[\s\S]+/
        }
      }
    ],
    "command-literal": [
      {
        pattern: RegExp(/%x/.source + percentExpression),
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "command": {
            pattern: /[\s\S]+/,
            alias: "string"
          }
        }
      },
      {
        pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "command": {
            pattern: /[\s\S]+/,
            alias: "string"
          }
        }
      }
    ]
  });
  delete Prism3.languages.ruby.string;
  Prism3.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism3.languages.rb = Prism3.languages.ruby;
})(Prism);

// node_modules/prismjs/components/prism-scala.js
Prism.languages.scala = Prism.languages.extend("java", {
  "triple-quoted-string": {
    pattern: /"""[\s\S]*?"""/,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "keyword": /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
  "number": /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
  "builtin": /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
  "symbol": /'[^\d\s\\]\w*/
});
Prism.languages.insertBefore("scala", "triple-quoted-string", {
  "string-interpolation": {
    pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
    greedy: true,
    inside: {
      "id": {
        pattern: /^\w+/,
        greedy: true,
        alias: "function"
      },
      "escape": {
        pattern: /\\\$"|\$[$"]/,
        greedy: true,
        alias: "symbol"
      },
      "interpolation": {
        pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
        greedy: true,
        inside: {
          "punctuation": /^\$\{?|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            inside: Prism.languages.scala
          }
        }
      },
      "string": /[\s\S]+/
    }
  }
});
delete Prism.languages.scala["class-name"];
delete Prism.languages.scala["function"];
delete Prism.languages.scala["constant"];

// node_modules/prismjs/components/prism-sql.js
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: true
    },
    /@[\w.$]+/
  ],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};

// node_modules/prismjs/components/prism-swift.js
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});

// node_modules/prismjs/components/prism-yaml.js
(function(Prism3) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism3.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string2 + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string2),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism3.languages.yml = Prism3.languages.yaml;
})(Prism);

// node_modules/prismjs/components/prism-csv.js
Prism.languages.csv = {
  "value": /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
  "punctuation": /,/
};

// src/utils/highlight.ts
var DEFAULT_LANG = "clike";
import_prismjs.default.languages.insertBefore(
  "javascript",
  "string",
  {
    "property string": {
      pattern: /([{,]\s*)"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,
      lookbehind: true
    }
  },
  void 0
);
import_prismjs.default.languages.insertBefore(
  "javascript",
  "punctuation",
  {
    property: {
      pattern: /([{,]\s*)[a-z]\w*(?=\s*:)/i,
      lookbehind: true
    }
  },
  void 0
);
function mapLang(lang) {
  return {
    json: "js",
    "c++": "cpp",
    "c#": "csharp",
    "objective-c": "objectivec",
    shell: "bash",
    viml: "vim"
  }[lang] || DEFAULT_LANG;
}
function highlight(source, lang = DEFAULT_LANG) {
  lang = lang.toLowerCase();
  let grammar = import_prismjs.default.languages[lang];
  if (!grammar) {
    grammar = import_prismjs.default.languages[mapLang(lang)];
  }
  return import_prismjs.default.highlight(source.toString(), grammar, lang);
}

// src/utils/decorators.ts
function throttle(func, wait) {
  let context;
  let args;
  let result;
  let timeout = null;
  let previous = 0;
  const later = () => {
    previous = (/* @__PURE__ */ new Date()).getTime();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) {
      context = args = null;
    }
  };
  return function() {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    } else if (!timeout) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}
function Throttle(delay) {
  return (_, _2, desc) => {
    desc.value = throttle(desc.value, delay);
  };
}

// src/utils/debug.ts
function debugTime(label) {
  if (false) {
    console.time(label);
  }
}
function debugTimeEnd(label) {
  if (false) {
    console.timeEnd(label);
  }
}

// src/utils/memoize.ts
var SENTINEL = {};
function memoize(target, name2, descriptor) {
  if (typeof descriptor.value === "function") {
    return _memoizeMethod(target, name2, descriptor);
  } else if (typeof descriptor.get === "function") {
    return _memoizeGetter(target, name2, descriptor);
  } else {
    throw new Error(
      "@memoize decorator can be applied to methods or getters, got " + String(descriptor.value) + " instead"
    );
  }
}
function _memoizeGetter(target, name2, descriptor) {
  const memoizedName = `_memoized_${name2}`;
  const get = descriptor.get;
  target[memoizedName] = SENTINEL;
  return {
    ...descriptor,
    get() {
      if (this[memoizedName] === SENTINEL) {
        this[memoizedName] = get.call(this);
      }
      return this[memoizedName];
    }
  };
}
function _memoizeMethod(target, name2, descriptor) {
  if (!descriptor.value || descriptor.value.length > 0) {
    throw new Error("@memoize decorator can only be applied to methods of zero arguments");
  }
  const memoizedName = `_memoized_${name2}`;
  const value = descriptor.value;
  target[memoizedName] = SENTINEL;
  return {
    ...descriptor,
    value() {
      if (this[memoizedName] === SENTINEL) {
        this[memoizedName] = value.call(this);
      }
      return this[memoizedName];
    }
  };
}

// src/utils/sort.ts
function alphabeticallyByProp(property) {
  let sortOrder = 1;
  if (property[0] === "-") {
    sortOrder = -1;
    property = property.substr(1);
  }
  return (a, b) => {
    if (sortOrder == -1) {
      return b[property].localeCompare(a[property]);
    } else {
      return a[property].localeCompare(b[property]);
    }
  };
}

// src/services/HistoryService.ts
var EVENT = "hashchange";
var HistoryService = class {
  constructor() {
    this.emit = () => {
      this._emiter.emit(EVENT, this.currentId);
    };
    this._emiter = new import_index.default();
    this.bind();
  }
  get currentId() {
    return IS_BROWSER ? decodeURIComponent(window.location.hash.substring(1)) : "";
  }
  linkForId(id) {
    if (!id) {
      return "";
    }
    return "#" + id;
  }
  subscribe(cb) {
    const emmiter = this._emiter.addListener(EVENT, cb);
    return () => emmiter.removeListener(EVENT, cb);
  }
  bind() {
    if (IS_BROWSER) {
      window.addEventListener("hashchange", this.emit, false);
    }
  }
  dispose() {
    if (IS_BROWSER) {
      window.removeEventListener("hashchange", this.emit);
    }
  }
  replace(id, rewriteHistory = false) {
    if (!IS_BROWSER) {
      return;
    }
    if (id == null || id === this.currentId) {
      return;
    }
    if (rewriteHistory) {
      window.history.replaceState(
        null,
        "",
        window.location.href.split("#")[0] + this.linkForId(id)
      );
      return;
    }
    window.history.pushState(null, "", window.location.href.split("#")[0] + this.linkForId(id));
    this.emit();
  }
};
__decorateClass([
  import_decko.bind,
  import_decko.debounce
], HistoryService.prototype, "replace", 1);
var history = new HistoryService();

// src/services/MarkerService.ts
var import_mark = __toESM(require_mark(), 1);
var MarkerService = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.prevTerm = "";
  }
  add(el) {
    this.map.set(el, new import_mark.default(el));
  }
  delete(el) {
    this.map.delete(el);
  }
  addOnly(elements) {
    this.map.forEach((inst, elem) => {
      if (elements.indexOf(elem) === -1) {
        inst.unmark();
        this.map.delete(elem);
      }
    });
    for (const el of elements) {
      if (!this.map.has(el)) {
        this.map.set(el, new import_mark.default(el));
      }
    }
  }
  clearAll() {
    this.unmark();
    this.map.clear();
  }
  mark(term) {
    if (!term && !this.prevTerm) {
      return;
    }
    this.map.forEach((val) => {
      val.unmark();
      val.mark(term || this.prevTerm);
    });
    this.prevTerm = term || this.prevTerm;
  }
  unmark() {
    this.map.forEach((val) => val.unmark());
    this.prevTerm = "";
  }
};

// src/services/MenuStore.ts
import { action as action8, observable as observable8, makeObservable as makeObservable8 } from "mobx";

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode) {
  if (encode) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html2) {
  return html2.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon") return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize2, base2, href) {
  if (sanitize2) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base2 && !originIndependentUrl.test(href)) {
    href = resolveUrl2(base2, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl2(base2, href) {
  if (!baseUrls[" " + base2]) {
    if (justDomain.test(base2)) {
      baseUrls[" " + base2] = base2 + "/";
    } else {
      baseUrls[" " + base2] = rtrim(base2, "/", true);
    }
  }
  base2 = baseUrls[" " + base2];
  const relativeBase = base2.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base2.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base2.replace(domain, "$1") + href;
  } else {
    return base2 + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l2 = str.length;
  let level2 = 0, i = 0;
  for (; i < l2; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level2++;
    } else if (str[i] === b[1]) {
      level2--;
      if (level2 < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer2.inlineTokens(text2)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top2 = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top2;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t2) => " ".repeat(3 * t2.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l2 = list.items.length;
      for (i = 0; i < l2; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t2) => t2.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t2) => /\n.*\n/.test(t2.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i = 0; i < l2; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = "paragraph";
        token.text = text2;
        token.tokens = this.lexer.inline(text2);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l2 = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l2; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l2 = item.rows.length;
        for (i = 0; i < l2; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l2 = item.header.length;
        for (j = 0; j < l2; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l2 = item.rows.length;
        for (j = 0; j < l2; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar2 = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;
    if (match[3] && prevChar2.match(/[\p{L}\p{N}]/u)) return;
    const nextChar2 = match[1] || match[2] || "";
    if (!nextChar2 || nextChar2 && (prevChar2 === "" || this.rules.inline.punctuation.exec(prevChar2))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim) continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0) continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text2) {
  return text2.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text2) {
  let out = "", i, ch;
  const l2 = text2.length;
  for (i = 0; i < l2; i++) {
    ch = text2.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class _Lexer {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar2;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar2 = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar2)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar2 = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html2) {
    return html2;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text2, level2, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level2} id="${id}">${text2}</h${level2}>
`;
    }
    return `<h${level2}>${text2}</h${level2}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text2) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body) body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content2) {
    return `<tr>
${content2}</tr>
`;
  }
  tablecell(content2, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content2 + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text2) {
    return `<em>${text2}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text2) {
    return `<del>${text2}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text2) {
    return text2;
  }
};
var TextRenderer = class {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class _Parser {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser3 = new _Parser(options2);
    return parser3.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser3 = new _Parser(options2);
    return parser3.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top2 = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l4 = tokens.length;
    for (i = 0; i < l4; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l4 && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top2 ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer2) {
    renderer2 = renderer2 || this.renderer;
    let out = "", i, token, ret;
    const l2 = tokens.length;
    for (i = 0; i < l2; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer2.text(token.text);
          break;
        }
        case "html": {
          out += renderer2.html(token.text);
          break;
        }
        case "link": {
          out += renderer2.link(token.href, token.title, this.parseInline(token.tokens, renderer2));
          break;
        }
        case "image": {
          out += renderer2.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer2.strong(this.parseInline(token.tokens, renderer2));
          break;
        }
        case "em": {
          out += renderer2.em(this.parseInline(token.tokens, renderer2));
          break;
        }
        case "codespan": {
          out += renderer2.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer2.br();
          break;
        }
        case "del": {
          out += renderer2.del(this.parseInline(token.tokens, renderer2));
          break;
        }
        case "text": {
          out += renderer2.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var Hooks = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
};
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
function onError(silent, async, callback) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    if (callback) {
      callback(e);
      return;
    }
    throw e;
  };
}
function parseMarkdown(lexer2, parser3) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...marked.defaults, ...origOpt };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight2 = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer2(src, opt);
      } catch (e) {
        return throwError(e);
      }
      const done2 = function(err) {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser3(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight2;
        return err ? throwError(err) : callback(null, out);
      };
      if (!highlight2 || highlight2.length < 3) {
        return done2();
      }
      delete opt.highlight;
      if (!tokens.length) return done2();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight2(token.text, token.lang, function(err, code) {
              if (err) {
                return done2(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done2();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done2();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser3(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer2(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html2 = parser3(tokens, opt);
      if (opt.hooks) {
        html2 = opt.hooks.postprocess(html2);
      }
      return html2;
    } catch (e) {
      return throwError(e);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  args.forEach((pack) => {
    const opts2 = { ...pack };
    opts2.async = marked.defaults.async || opts2.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts2.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer2 = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer2[prop];
        renderer2[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer2, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer2, args2);
          }
          return ret;
        };
      }
      opts2.renderer = renderer2;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts2.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts2.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts2.walkTokens = function(token) {
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens2) {
          values = values.concat(walkTokens2.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts2);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values = [];
  for (const token of tokens) {
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values = values.concat(marked.walkTokens(token.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            values = values.concat(marked.walkTokens(token[childTokens], callback));
          });
        } else if (token.tokens) {
          values = values.concat(marked.walkTokens(token.tokens, callback));
        }
      }
    }
  }
  return values;
};
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// src/services/MarkdownRenderer.ts
var renderer = new marked.Renderer();
marked.setOptions({
  renderer,
  highlight: (str, lang) => {
    return highlight(str, lang);
  }
});
var LEGACY_REGEXP = "^ {0,3}<!-- ReDoc-Inject:\\s+?<({component}).*?/?>\\s+?-->\\s*$";
var MDX_COMPONENT_REGEXP = "(?:^ {0,3}<({component})([\\s\\S]*?)>([\\s\\S]*?)</\\2>|^ {0,3}<({component})([\\s\\S]*?)(?:/>|\\n{2,}))";
var COMPONENT_REGEXP = "(?:" + LEGACY_REGEXP + "|" + MDX_COMPONENT_REGEXP + ")";
function buildComponentComment(name2) {
  return `<!-- ReDoc-Inject: <${name2}> -->`;
}
var MarkdownRenderer = class {
  constructor(options2, parentId) {
    this.options = options2;
    this.parentId = parentId;
    this.headings = [];
    this.headingRule = (text2, level2, raw, slugger) => {
      if (level2 === 1) {
        this.currentTopHeading = this.saveHeading(text2, level2);
      } else if (level2 === 2) {
        this.saveHeading(
          text2,
          level2,
          this.currentTopHeading && this.currentTopHeading.items,
          this.currentTopHeading && this.currentTopHeading.id
        );
      }
      return this.originalHeadingRule(text2, level2, raw, slugger);
    };
    this.parentId = parentId;
    this.parser = new marked.Parser();
    this.headingEnhanceRenderer = new marked.Renderer();
    this.originalHeadingRule = this.headingEnhanceRenderer.heading.bind(
      this.headingEnhanceRenderer
    );
    this.headingEnhanceRenderer.heading = this.headingRule;
  }
  static containsComponent(rawText, componentName) {
    const compRegexp = new RegExp(COMPONENT_REGEXP.replace(/{component}/g, componentName), "gmi");
    return compRegexp.test(rawText);
  }
  static getTextBeforeHading(md, heading2) {
    const headingLinePos = md.search(new RegExp(`^##?\\s+${heading2}`, "m"));
    if (headingLinePos > -1) {
      return md.substring(0, headingLinePos);
    }
    return md;
  }
  saveHeading(name2, level2, container = this.headings, parentId) {
    name2 = unescapeHTMLChars(name2);
    const item = {
      id: parentId ? `${parentId}/${safeSlugify(name2)}` : `${this.parentId || "section"}/${safeSlugify(name2)}`,
      name: name2,
      level: level2,
      items: []
    };
    container.push(item);
    return item;
  }
  flattenHeadings(container) {
    if (container === void 0) {
      return [];
    }
    const res = [];
    for (const heading2 of container) {
      res.push(heading2);
      res.push(...this.flattenHeadings(heading2.items));
    }
    return res;
  }
  attachHeadingsDescriptions(rawText) {
    const buildRegexp = (heading2) => {
      return new RegExp(
        `##?\\s+${heading2.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")}s*(
|\r
|$|s*)`
      );
    };
    const flatHeadings = this.flattenHeadings(this.headings);
    if (flatHeadings.length < 1) {
      return;
    }
    let prevHeading = flatHeadings[0];
    let prevRegexp = buildRegexp(prevHeading);
    let prevPos = rawText.search(prevRegexp);
    for (let i = 1; i < flatHeadings.length; i++) {
      const heading2 = flatHeadings[i];
      const regexp = buildRegexp(heading2);
      const currentPos = rawText.substr(prevPos + 1).search(regexp) + prevPos + 1;
      prevHeading.description = rawText.substring(prevPos, currentPos).replace(prevRegexp, "").trim();
      prevHeading = heading2;
      prevRegexp = regexp;
      prevPos = currentPos;
    }
    prevHeading.description = rawText.substring(prevPos).replace(prevRegexp, "").trim();
  }
  renderMd(rawText, extractHeadings = false) {
    const opts2 = extractHeadings ? { renderer: this.headingEnhanceRenderer } : void 0;
    const res = marked(rawText.toString(), opts2);
    return res;
  }
  extractHeadings(rawText) {
    this.renderMd(rawText, true);
    this.attachHeadingsDescriptions(rawText);
    const res = this.headings;
    this.headings = [];
    return res;
  }
  // regexp-based 👎: remark is slow and too big so for now using marked + regexps soup
  renderMdWithComponents(rawText) {
    const components = this.options && this.options.allowedMdComponents;
    if (!components || Object.keys(components).length === 0) {
      return [this.renderMd(rawText)];
    }
    const names = Object.keys(components).join("|");
    const componentsRegexp = new RegExp(COMPONENT_REGEXP.replace(/{component}/g, names), "mig");
    const htmlParts = [];
    const componentDefs = [];
    let match = componentsRegexp.exec(rawText);
    let lasxtIdx = 0;
    while (match) {
      htmlParts.push(rawText.substring(lasxtIdx, match.index));
      lasxtIdx = componentsRegexp.lastIndex;
      const compName = match[1] || match[2] || match[5];
      const componentMeta = components[compName];
      const props = match[3] || match[6];
      const children = match[4];
      if (componentMeta) {
        componentDefs.push({
          component: componentMeta.component,
          propsSelector: componentMeta.propsSelector,
          props: { ...parseProps(props), ...componentMeta.props, children }
        });
      }
      match = componentsRegexp.exec(rawText);
    }
    htmlParts.push(rawText.substring(lasxtIdx));
    const res = [];
    for (let i = 0; i < htmlParts.length; i++) {
      const htmlPart = htmlParts[i];
      if (htmlPart) {
        res.push(this.renderMd(htmlPart));
      }
      if (componentDefs[i]) {
        res.push(componentDefs[i]);
      }
    }
    return res;
  }
};
function parseProps(props) {
  if (!props) {
    return {};
  }
  const regex = /([\w-]+)\s*=\s*(?:{([^}]+?)}|"([^"]+?)")/gim;
  const parsed = {};
  let match;
  while ((match = regex.exec(props)) !== null) {
    if (match[3]) {
      parsed[match[1]] = match[3];
    } else if (match[2]) {
      let val;
      try {
        val = JSON.parse(match[2]);
      } catch (e) {
      }
      parsed[match[1]] = val;
    }
  }
  return parsed;
}

// src/services/models/ApiInfo.ts
var ApiInfoModel = class {
  constructor(parser3, options2 = new RedocNormalizedOptions({})) {
    this.parser = parser3;
    this.options = options2;
    Object.assign(this, parser3.spec.info);
    this.description = parser3.spec.info.description || "";
    this.summary = parser3.spec.info.summary || "";
    const firstHeadingLinePos = this.description.search(/^\s*##?\s+/m);
    if (firstHeadingLinePos > -1) {
      this.description = this.description.substring(0, firstHeadingLinePos);
    }
    this.downloadUrls = this.getDownloadUrls();
    this.downloadFileName = this.getDownloadFileName();
  }
  getDownloadUrls() {
    return (!this.options.downloadUrls ? [
      {
        title: l("download"),
        url: this.getDownloadLink(this.options.downloadDefinitionUrl)
      }
    ] : this.options.downloadUrls.map(({ title, url }) => ({
      title: title || l("download"),
      url: this.getDownloadLink(url)
    }))).filter(({ title, url }) => title && url);
  }
  getDownloadLink(url) {
    if (url) {
      return url;
    }
    if (this.parser.specUrl) {
      return this.parser.specUrl;
    }
    if (IS_BROWSER && window.Blob && window.URL && window.URL.createObjectURL) {
      const blob = new Blob([JSON.stringify(this.parser.spec, null, 2)], {
        type: "application/json"
      });
      return window.URL.createObjectURL(blob);
    }
  }
  getDownloadFileName() {
    if (!this.parser.specUrl && !this.options.downloadDefinitionUrl) {
      return this.options.downloadFileName || "openapi.json";
    }
    return this.options.downloadFileName;
  }
};

// src/services/models/Operation.ts
import { action as action6, observable as observable6, makeObservable as makeObservable6 } from "mobx";

// src/services/models/SecurityRequirement.ts
var SecurityRequirementModel = class {
  constructor(requirement, parser3) {
    const schemes = parser3.spec.components && parser3.spec.components.securitySchemes || {};
    this.schemes = Object.keys(requirement || {}).map((id) => {
      const { resolved: scheme } = parser3.deref(schemes[id]);
      const scopes = requirement[id] || [];
      if (!scheme) {
        console.warn(`Non existing security scheme referenced: ${id}. Skipping`);
        return void 0;
      }
      const displayName = scheme["x-displayName"] || id;
      return {
        ...scheme,
        id,
        sectionId: id,
        displayName,
        scopes
      };
    }).filter((scheme) => scheme !== void 0);
  }
};

// src/services/models/Callback.ts
import { action, observable, makeObservable } from "mobx";
var CallbackModel = class {
  constructor(parser3, name2, infoOrRef, pointer, options2) {
    this.expanded = false;
    this.operations = [];
    makeObservable(this);
    this.name = name2;
    const { resolved: paths } = parser3.deref(infoOrRef);
    for (const pathName of Object.keys(paths)) {
      const path = paths[pathName];
      const operations = Object.keys(path).filter(isOperationName);
      for (const operationName of operations) {
        const operationInfo = path[operationName];
        const operation = new OperationModel(
          parser3,
          {
            ...operationInfo,
            pathName,
            pointer: JsonPointer.compile([pointer, name2, pathName, operationName]),
            httpVerb: operationName,
            pathParameters: path.parameters || [],
            pathServers: path.servers
          },
          void 0,
          options2,
          true
        );
        this.operations.push(operation);
      }
    }
  }
  toggle() {
    this.expanded = !this.expanded;
  }
};
__decorateClass([
  observable
], CallbackModel.prototype, "expanded", 2);
__decorateClass([
  action
], CallbackModel.prototype, "toggle", 1);

// src/services/models/Field.ts
import { action as action3, observable as observable3, makeObservable as makeObservable3 } from "mobx";

// src/services/models/Schema.ts
import { action as action2, observable as observable2, makeObservable as makeObservable2 } from "mobx";

// src/services/OpenAPIParser.ts
var MAX_DEREF_DEPTH = 999;
function pushRef(stack, ref) {
  return ref && stack[stack.length - 1] !== ref ? [...stack, ref] : stack;
}
function concatRefStacks(base2, stack) {
  return stack ? base2.concat(stack) : base2;
}
var OpenAPIParser = class {
  constructor(spec, specUrl, options2 = new RedocNormalizedOptions({})) {
    this.options = options2;
    this.allowMergeRefs = false;
    /**
     * get spec part by JsonPointer ($ref)
     */
    this.byRef = (ref) => {
      let res;
      if (!this.spec) {
        return;
      }
      if (ref.charAt(0) !== "#") {
        ref = "#" + ref;
      }
      ref = decodeURIComponent(ref);
      try {
        res = JsonPointer.get(this.spec, ref);
      } catch (e) {
      }
      return res || {};
    };
    this.validate(spec);
    this.spec = spec;
    this.allowMergeRefs = spec.openapi.startsWith("3.1");
    const href = IS_BROWSER ? window.location.href : "";
    if (typeof specUrl === "string") {
      this.specUrl = href ? new URL(specUrl, href).href : specUrl;
    }
  }
  validate(spec) {
    if (spec.openapi === void 0) {
      throw new Error("Document must be valid OpenAPI 3.0.0 definition");
    }
  }
  /**
   * checks if the object is OpenAPI reference (contains $ref property)
   */
  isRef(obj) {
    if (!obj) {
      return false;
    }
    obj = obj;
    return obj.$ref !== void 0 && obj.$ref !== null;
  }
  /**
   * Resolve given reference object or return as is if it is not a reference
   * @param obj object to dereference
   * @param forceCircular whether to dereference even if it is circular ref
   * @param mergeAsAllOf
   */
  deref(obj, baseRefsStack = [], mergeAsAllOf = false) {
    const objRefsStack = obj == null ? void 0 : obj["x-refsStack"];
    baseRefsStack = concatRefStacks(baseRefsStack, objRefsStack);
    if (this.isRef(obj)) {
      const schemaName = getDefinitionName(obj.$ref);
      if (schemaName && this.options.ignoreNamedSchemas.has(schemaName)) {
        return { resolved: { type: "object", title: schemaName }, refsStack: baseRefsStack };
      }
      let resolved = this.byRef(obj.$ref);
      if (!resolved) {
        throw new Error(`Failed to resolve $ref "${obj.$ref}"`);
      }
      let refsStack = baseRefsStack;
      if (baseRefsStack.includes(obj.$ref) || baseRefsStack.length > MAX_DEREF_DEPTH) {
        resolved = Object.assign({}, resolved, { "x-circular-ref": true });
      } else if (this.isRef(resolved)) {
        const res = this.deref(resolved, baseRefsStack, mergeAsAllOf);
        refsStack = res.refsStack;
        resolved = res.resolved;
      }
      refsStack = pushRef(baseRefsStack, obj.$ref);
      resolved = this.allowMergeRefs ? this.mergeRefs(obj, resolved, mergeAsAllOf) : resolved;
      return { resolved, refsStack };
    }
    return {
      resolved: obj,
      refsStack: concatRefStacks(baseRefsStack, objRefsStack)
    };
  }
  mergeRefs(ref, resolved, mergeAsAllOf) {
    const { $ref, ...rest } = ref;
    const keys2 = Object.keys(rest);
    if (keys2.length === 0) {
      return resolved;
    }
    if (mergeAsAllOf && keys2.some(
      (k) => ![
        "description",
        "title",
        "externalDocs",
        "x-refsStack",
        "x-parentRefs",
        "readOnly",
        "writeOnly"
      ].includes(k)
    )) {
      const { description, title, readOnly: readOnly2, writeOnly, ...restSchema } = rest;
      return {
        allOf: [{ description, title, readOnly: readOnly2, writeOnly }, resolved, restSchema]
      };
    } else {
      return {
        ...resolved,
        ...rest
      };
    }
  }
  /**
   * Merge allOf constraints.
   * @param schema schema with allOF
   * @param $ref pointer of the schema
   * @param forceCircular whether to dereference children even if it is a circular ref
   * @param used$Refs
   */
  mergeAllOf(schema, $ref, refsStack) {
    var _a2;
    if (schema["x-circular-ref"]) {
      return schema;
    }
    schema = this.hoistOneOfs(schema, refsStack);
    if (schema.allOf === void 0) {
      return schema;
    }
    let receiver = {
      ...schema,
      "x-parentRefs": [],
      allOf: void 0,
      title: schema.title || getDefinitionName($ref)
    };
    if (receiver.properties !== void 0 && typeof receiver.properties === "object") {
      receiver.properties = { ...receiver.properties };
    }
    if (receiver.items !== void 0 && typeof receiver.items === "object") {
      receiver.items = { ...receiver.items };
    }
    const allOfSchemas = uniqByPropIncludeMissing(
      schema.allOf.map((subSchema) => {
        var _a3;
        const { resolved, refsStack: subRefsStack } = this.deref(subSchema, refsStack, true);
        const subRef = subSchema.$ref || void 0;
        const subMerged = this.mergeAllOf(resolved, subRef, subRefsStack);
        if (subMerged["x-circular-ref"] && subMerged.allOf) {
          return void 0;
        }
        if (subRef) {
          (_a3 = receiver["x-parentRefs"]) == null ? void 0 : _a3.push(...subMerged["x-parentRefs"] || [], subRef);
        }
        return {
          $ref: subRef,
          refsStack: pushRef(subRefsStack, subRef),
          schema: subMerged
        };
      }).filter((child) => child !== void 0),
      "$ref"
    );
    for (const { schema: subSchema, refsStack: subRefsStack } of allOfSchemas) {
      const {
        type,
        enum: enumProperty,
        properties,
        items,
        required: required3,
        title,
        description,
        readOnly: readOnly2,
        writeOnly,
        oneOf,
        anyOf,
        "x-circular-ref": isCircular,
        ...otherConstraints
      } = subSchema;
      if (receiver.type !== type && receiver.type !== void 0 && type !== void 0) {
        console.warn(`Incompatible types in allOf at "${$ref}": "${receiver.type}" and "${type}"`);
      }
      if (type !== void 0) {
        if (Array.isArray(type) && Array.isArray(receiver.type)) {
          receiver.type = [...type, ...receiver.type];
        } else {
          receiver.type = type;
        }
      }
      if (enumProperty !== void 0) {
        if (Array.isArray(enumProperty) && Array.isArray(receiver.enum)) {
          receiver.enum = Array.from(/* @__PURE__ */ new Set([...enumProperty, ...receiver.enum]));
        } else {
          receiver.enum = enumProperty;
        }
      }
      if (properties !== void 0 && typeof properties === "object") {
        receiver.properties = receiver.properties || {};
        for (const prop in properties) {
          const propRefsStack = concatRefStacks(subRefsStack, (_a2 = properties[prop]) == null ? void 0 : _a2["x-refsStack"]);
          if (!receiver.properties[prop]) {
            receiver.properties[prop] = {
              ...properties[prop],
              "x-refsStack": propRefsStack
            };
          } else if (!isCircular) {
            const mergedProp = this.mergeAllOf(
              {
                allOf: [
                  receiver.properties[prop],
                  { ...properties[prop], "x-refsStack": propRefsStack }
                ],
                "x-refsStack": propRefsStack
              },
              $ref + "/properties/" + prop,
              propRefsStack
            );
            receiver.properties[prop] = mergedProp;
          }
        }
      }
      if (items !== void 0 && !isCircular) {
        const receiverItems = typeof receiver.items === "boolean" ? {} : Object.assign({}, receiver.items);
        const subSchemaItems = typeof subSchema.items === "boolean" ? {} : Object.assign({}, subSchema.items);
        receiver.items = this.mergeAllOf(
          {
            allOf: [receiverItems, subSchemaItems]
          },
          $ref + "/items",
          subRefsStack
        );
      }
      if (oneOf !== void 0) {
        receiver.oneOf = oneOf;
      }
      if (anyOf !== void 0) {
        receiver.anyOf = anyOf;
      }
      if (required3 !== void 0) {
        receiver.required = [...receiver.required || [], ...required3];
      }
      receiver = {
        ...receiver,
        title: receiver.title || title,
        description: receiver.description || description,
        readOnly: receiver.readOnly !== void 0 ? receiver.readOnly : readOnly2,
        writeOnly: receiver.writeOnly !== void 0 ? receiver.writeOnly : writeOnly,
        "x-circular-ref": receiver["x-circular-ref"] || isCircular,
        ...otherConstraints
      };
    }
    return receiver;
  }
  /**
   * Find all derived definitions among #/components/schemas from any of $refs
   * returns map of definition pointer to definition name
   * @param $refs array of references to find derived from
   */
  findDerived($refs) {
    const res = {};
    const schemas = this.spec.components && this.spec.components.schemas || {};
    for (const defName in schemas) {
      const { resolved: def } = this.deref(schemas[defName]);
      if (def.allOf !== void 0 && def.allOf.find(
        (obj) => obj.$ref !== void 0 && $refs.indexOf(obj.$ref) > -1
      )) {
        res["#/components/schemas/" + defName] = [def["x-discriminator-value"] || defName];
      }
    }
    return res;
  }
  hoistOneOfs(schema, refsStack) {
    if (schema.allOf === void 0) {
      return schema;
    }
    const allOf = schema.allOf;
    for (let i = 0; i < allOf.length; i++) {
      const { oneOf, ...sub } = allOf[i];
      if (!oneOf) {
        continue;
      }
      if (Array.isArray(oneOf)) {
        const beforeAllOf = allOf.slice(0, i);
        const afterAllOf = allOf.slice(i + 1);
        const siblingValues = Object.keys(sub).length > 0 ? [sub] : [];
        return {
          oneOf: oneOf.map((part) => {
            return {
              allOf: [...beforeAllOf, ...siblingValues, part, ...afterAllOf],
              "x-refsStack": refsStack
            };
          })
        };
      }
    }
    return schema;
  }
};
function uniqByPropIncludeMissing(arr, prop) {
  const seen = /* @__PURE__ */ new Set();
  return arr.filter((item) => {
    const k = item[prop];
    if (!k) return true;
    return k && !seen.has(k) && seen.add(k);
  });
}

// src/services/models/Schema.ts
var _SchemaModel = class _SchemaModel {
  /**
   * @param isChild if schema discriminator Child
   * When true forces dereferencing in allOfs even if circular
   */
  constructor(parser3, schemaOrRef, pointer, options2, isChild = false, refsStack = []) {
    this.options = options2;
    this.refsStack = refsStack;
    this.typePrefix = "";
    this.isCircular = false;
    this.activeOneOf = 0;
    makeObservable2(this);
    this.pointer = schemaOrRef.$ref || pointer || "";
    const { resolved, refsStack: newRefsStack } = parser3.deref(schemaOrRef, refsStack, true);
    this.refsStack = pushRef(newRefsStack, this.pointer);
    this.rawSchema = resolved;
    this.schema = parser3.mergeAllOf(this.rawSchema, this.pointer, this.refsStack);
    this.init(parser3, isChild);
    if (options2.showExtensions) {
      this.extensions = extractExtensions(this.schema, options2.showExtensions);
    }
  }
  activateOneOf(idx) {
    this.activeOneOf = idx;
  }
  hasType(type) {
    return this.type === type || isArray(this.type) && this.type.includes(type);
  }
  init(parser3, isChild) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const schema = this.schema;
    this.isCircular = !!schema["x-circular-ref"];
    this.title = schema.title || isNamedDefinition(this.pointer) && JsonPointer.baseName(this.pointer) || "";
    this.description = schema.description || "";
    this.type = schema.type || detectType(schema);
    this.format = schema.format;
    this.enum = schema.enum || [];
    this["x-enumDescriptions"] = schema["x-enumDescriptions"];
    this.example = schema.example;
    this.examples = schema.examples;
    this.deprecated = !!schema.deprecated;
    this.pattern = schema.pattern;
    this.externalDocs = schema.externalDocs;
    this.constraints = humanizeConstraints(schema);
    this.displayFormat = this.format;
    this.isPrimitive = isPrimitiveType(schema, this.type);
    this.default = schema.default;
    this.readOnly = !!schema.readOnly;
    this.writeOnly = !!schema.writeOnly;
    this.const = schema.const || "";
    this.contentEncoding = schema.contentEncoding;
    this.contentMediaType = schema.contentMediaType;
    this.minItems = schema.minItems;
    this.maxItems = schema.maxItems;
    if (!!schema.nullable || schema["x-nullable"]) {
      if (isArray(this.type) && !this.type.some((value) => value === null || value === "null")) {
        this.type = [...this.type, "null"];
      } else if (!isArray(this.type) && (this.type !== null || this.type !== "null")) {
        this.type = [this.type, "null"];
      }
    }
    this.displayType = isArray(this.type) ? this.type.map((item) => item === null ? "null" : item).join(" or ") : this.type;
    if (this.isCircular) {
      return;
    }
    if (schema.if && schema.then || schema.if && schema.else) {
      this.initConditionalOperators(schema, parser3);
      return;
    }
    if (!isChild && getDiscriminator(schema) !== void 0) {
      this.initDiscriminator(schema, parser3);
      return;
    } else if (isChild && isArray(schema.oneOf) && schema.oneOf.find((s) => s.$ref === this.pointer)) {
      delete schema.oneOf;
    }
    if (schema.oneOf !== void 0) {
      this.initOneOf(schema.oneOf, parser3);
      this.oneOfType = "One of";
      if (schema.anyOf !== void 0) {
        console.warn(
          `oneOf and anyOf are not supported on the same level. Skipping anyOf at ${this.pointer}`
        );
      }
      return;
    }
    if (schema.anyOf !== void 0) {
      this.initOneOf(schema.anyOf, parser3);
      this.oneOfType = "Any of";
      return;
    }
    if (this.hasType("object")) {
      this.fields = buildFields(parser3, schema, this.pointer, this.options, this.refsStack);
    } else if (this.hasType("array")) {
      if (isArray(schema.items) || isArray(schema.prefixItems)) {
        this.fields = buildFields(parser3, schema, this.pointer, this.options, this.refsStack);
      } else if (schema.items) {
        this.items = new _SchemaModel(
          parser3,
          schema.items,
          this.pointer + "/items",
          this.options,
          false,
          this.refsStack
        );
      }
      this.displayType = schema.prefixItems || isArray(schema.items) ? "items" : pluralizeType(((_a2 = this.items) == null ? void 0 : _a2.displayType) || this.displayType);
      this.displayFormat = ((_b = this.items) == null ? void 0 : _b.format) || "";
      this.typePrefix = ((_c = this.items) == null ? void 0 : _c.typePrefix) || "" + l("arrayOf");
      this.title = this.title || ((_d = this.items) == null ? void 0 : _d.title) || "";
      this.isPrimitive = ((_e = this.items) == null ? void 0 : _e.isPrimitive) !== void 0 ? (_f = this.items) == null ? void 0 : _f.isPrimitive : this.isPrimitive;
      if (this.example === void 0 && ((_g = this.items) == null ? void 0 : _g.example) !== void 0) {
        this.example = [this.items.example];
      }
      if ((_h = this.items) == null ? void 0 : _h.isPrimitive) {
        this.enum = this.items.enum;
        this["x-enumDescriptions"] = this.items["x-enumDescriptions"];
      }
      if (isArray(this.type)) {
        const filteredType = this.type.filter((item) => item !== "array");
        if (filteredType.length) this.displayType += ` or ${filteredType.join(" or ")}`;
      }
    }
    if (this.enum.length && this.options.sortEnumValuesAlphabetically) {
      this.enum.sort();
    }
  }
  initOneOf(oneOf, parser3) {
    this.oneOf = oneOf.map((variant, idx) => {
      const { resolved: derefVariant, refsStack } = parser3.deref(variant, this.refsStack, true);
      const merged = parser3.mergeAllOf(derefVariant, this.pointer + "/oneOf/" + idx, refsStack);
      const title = isNamedDefinition(variant.$ref) && !merged.title ? JsonPointer.baseName(variant.$ref) : `${merged.title || ""}${typeof merged.const !== "undefined" && JSON.stringify(merged.const) || ""}`;
      const schema = new _SchemaModel(
        parser3,
        // merge base schema into each of oneOf's subschemas
        {
          // variant may already have allOf so merge it to not get overwritten
          ...merged,
          title,
          allOf: [{ ...this.schema, oneOf: void 0, anyOf: void 0 }],
          // if specific child schemas are listed in oneOf/anyOf, they are not supposed to be discriminated
          discriminator: derefVariant.allOf ? void 0 : merged.discriminator
        },
        variant.$ref || this.pointer + "/oneOf/" + idx,
        this.options,
        false,
        refsStack
      );
      return schema;
    });
    if (this.options.simpleOneOfTypeLabel) {
      const types2 = collectUniqueOneOfTypesDeep(this);
      this.displayType = types2.join(" or ");
    } else {
      this.displayType = this.oneOf.map((schema) => {
        let name2 = schema.typePrefix + (schema.title ? `${schema.title} (${schema.displayType})` : schema.displayType);
        if (name2.indexOf(" or ") > -1) {
          name2 = `(${name2})`;
        }
        return name2;
      }).join(" or ");
    }
  }
  initDiscriminator(schema, parser3) {
    const discriminator = getDiscriminator(schema);
    this.discriminatorProp = discriminator.propertyName;
    const implicitInversedMapping = parser3.findDerived([
      ...this.schema["x-parentRefs"] || [],
      this.pointer
    ]);
    if (schema.oneOf) {
      for (const variant of schema.oneOf) {
        if (variant.$ref === void 0) {
          continue;
        }
        const name2 = JsonPointer.baseName(variant.$ref);
        implicitInversedMapping[variant.$ref] = name2;
      }
    }
    const mapping = discriminator.mapping || {};
    let isLimitedToMapping = discriminator["x-explicitMappingOnly"] || false;
    if (Object.keys(mapping).length === 0) {
      isLimitedToMapping = false;
    }
    const explicitInversedMapping = {};
    for (const name2 in mapping) {
      const $ref = mapping[name2];
      if (isArray(explicitInversedMapping[$ref])) {
        explicitInversedMapping[$ref].push(name2);
      } else {
        explicitInversedMapping[$ref] = [name2];
      }
    }
    const inversedMapping = isLimitedToMapping ? { ...explicitInversedMapping } : { ...implicitInversedMapping, ...explicitInversedMapping };
    let refs = [];
    for (const $ref of Object.keys(inversedMapping)) {
      const names2 = inversedMapping[$ref];
      if (isArray(names2)) {
        for (const name2 of names2) {
          refs.push({ $ref, name: name2 });
        }
      } else {
        refs.push({ $ref, name: names2 });
      }
    }
    const names = Object.keys(mapping);
    if (names.length !== 0) {
      refs = refs.sort((left, right) => {
        const indexLeft = names.indexOf(left.name);
        const indexRight = names.indexOf(right.name);
        if (indexLeft < 0 && indexRight < 0) {
          return left.name.localeCompare(right.name);
        } else if (indexLeft < 0) {
          return 1;
        } else if (indexRight < 0) {
          return -1;
        } else {
          return indexLeft - indexRight;
        }
      });
    }
    this.oneOf = refs.map(({ $ref, name: name2 }) => {
      const innerSchema = new _SchemaModel(
        parser3,
        { $ref },
        $ref,
        this.options,
        true,
        this.refsStack.slice(0, -1)
      );
      innerSchema.title = name2;
      return innerSchema;
    });
  }
  initConditionalOperators(schema, parser3) {
    const {
      if: ifOperator,
      else: elseOperator = {},
      then: thenOperator = {},
      ...restSchema
    } = schema;
    const groupedOperators = [
      {
        allOf: [restSchema, thenOperator, ifOperator],
        title: ifOperator && ifOperator["x-displayName"] || (ifOperator == null ? void 0 : ifOperator.title) || "case 1"
      },
      {
        allOf: [restSchema, elseOperator],
        title: elseOperator && elseOperator["x-displayName"] || (elseOperator == null ? void 0 : elseOperator.title) || "case 2"
      }
    ];
    this.oneOf = groupedOperators.map(
      (variant, idx) => new _SchemaModel(
        parser3,
        {
          ...variant
        },
        this.pointer + "/oneOf/" + idx,
        this.options,
        false,
        this.refsStack
      )
    );
    this.oneOfType = "One of";
  }
};
__decorateClass([
  observable2
], _SchemaModel.prototype, "activeOneOf", 2);
__decorateClass([
  action2
], _SchemaModel.prototype, "activateOneOf", 1);
var SchemaModel = _SchemaModel;
function buildFields(parser3, schema, $ref, options2, refsStack) {
  const props = schema.properties || schema.prefixItems || schema.items || {};
  const patternProps = schema.patternProperties || {};
  const additionalProps = schema.additionalProperties || schema.unevaluatedProperties;
  const itemsProps = schema.prefixItems ? schema.items : schema.additionalItems;
  const defaults4 = schema.default;
  let fields = Object.keys(props || []).map((fieldName) => {
    let field = props[fieldName];
    if (!field) {
      console.warn(
        `Field "${fieldName}" is invalid, skipping.
 Field must be an object but got ${typeof field} at "${$ref}"`
      );
      field = {};
    }
    const required3 = schema.required === void 0 ? false : schema.required.indexOf(fieldName) > -1;
    return new FieldModel(
      parser3,
      {
        name: schema.properties ? fieldName : `[${fieldName}]`,
        required: required3,
        schema: {
          ...field,
          default: field.default === void 0 && defaults4 ? defaults4[fieldName] : field.default
        }
      },
      $ref + "/properties/" + fieldName,
      options2,
      refsStack
    );
  });
  if (options2.sortPropsAlphabetically) {
    fields = sortByField(fields, "name");
  }
  if (options2.sortRequiredPropsFirst) {
    fields = sortByRequired(fields, !options2.sortPropsAlphabetically ? schema.required : void 0);
  }
  fields.push(
    ...Object.keys(patternProps).map((fieldName) => {
      let field = patternProps[fieldName];
      if (!field) {
        console.warn(
          `Field "${fieldName}" is invalid, skipping.
 Field must be an object but got ${typeof field} at "${$ref}"`
        );
        field = {};
      }
      return new FieldModel(
        parser3,
        {
          name: fieldName,
          required: false,
          schema: field,
          kind: "patternProperties"
        },
        `${$ref}/patternProperties/${fieldName}`,
        options2,
        refsStack
      );
    })
  );
  if (typeof additionalProps === "object" || additionalProps === true) {
    fields.push(
      new FieldModel(
        parser3,
        {
          name: (typeof additionalProps === "object" ? additionalProps["x-additionalPropertiesName"] || "property name" : "property name").concat("*"),
          required: false,
          schema: additionalProps === true ? {} : additionalProps,
          kind: "additionalProperties"
        },
        $ref + "/additionalProperties",
        options2,
        refsStack
      )
    );
  }
  fields.push(
    ...buildAdditionalItems({
      parser: parser3,
      schema: itemsProps,
      fieldsCount: fields.length,
      $ref,
      options: options2,
      refsStack
    })
  );
  return fields;
}
function buildAdditionalItems({
  parser: parser3,
  schema = false,
  fieldsCount,
  $ref,
  options: options2,
  refsStack
}) {
  if (isBoolean(schema)) {
    return schema ? [
      new FieldModel(
        parser3,
        {
          name: `[${fieldsCount}...]`,
          schema: {}
        },
        `${$ref}/additionalItems`,
        options2,
        refsStack
      )
    ] : [];
  }
  if (isArray(schema)) {
    return [
      ...schema.map(
        (field, idx) => new FieldModel(
          parser3,
          {
            name: `[${fieldsCount + idx}]`,
            schema: field
          },
          `${$ref}/additionalItems`,
          options2,
          refsStack
        )
      )
    ];
  }
  if (isObject(schema)) {
    return [
      new FieldModel(
        parser3,
        {
          name: `[${fieldsCount}...]`,
          schema
        },
        `${$ref}/additionalItems`,
        options2,
        refsStack
      )
    ];
  }
  return [];
}
function getDiscriminator(schema) {
  return schema.discriminator || schema["x-discriminator"];
}
function collectUniqueOneOfTypesDeep(schema) {
  const uniqueTypes = /* @__PURE__ */ new Set();
  function crawl(schema2) {
    for (const oneOfType of schema2.oneOf || []) {
      if (oneOfType.oneOf) {
        crawl(oneOfType);
        continue;
      }
      if (oneOfType.type) {
        uniqueTypes.add(oneOfType.type);
      }
    }
  }
  crawl(schema);
  return Array.from(uniqueTypes.values());
}

// src/services/models/Example.ts
var externalExamplesCache = {};
var ExampleModel = class {
  constructor(parser3, infoOrRef, mime, encoding) {
    this.mime = mime;
    const { resolved: example } = parser3.deref(infoOrRef);
    this.value = example.value;
    this.summary = example.summary;
    this.description = example.description;
    if (example.externalValue) {
      this.externalValueUrl = new URL(example.externalValue, parser3.specUrl).href;
    }
    if (isFormUrlEncoded(mime) && this.value && typeof this.value === "object") {
      this.value = urlFormEncodePayload(this.value, encoding);
    }
  }
  getExternalValue(mimeType) {
    if (!this.externalValueUrl) {
      return Promise.resolve(void 0);
    }
    if (this.externalValueUrl in externalExamplesCache) {
      return externalExamplesCache[this.externalValueUrl];
    }
    externalExamplesCache[this.externalValueUrl] = fetch(this.externalValueUrl).then((res) => {
      return res.text().then((txt) => {
        if (!res.ok) {
          return Promise.reject(new Error(txt));
        }
        if (isJsonLike(mimeType)) {
          try {
            return JSON.parse(txt);
          } catch (e) {
            return txt;
          }
        } else {
          return txt;
        }
      });
    });
    return externalExamplesCache[this.externalValueUrl];
  }
};

// src/services/models/Field.ts
var DEFAULT_SERIALIZATION = {
  path: {
    style: "simple",
    explode: false
  },
  query: {
    style: "form",
    explode: true
  },
  header: {
    style: "simple",
    explode: false
  },
  cookie: {
    style: "form",
    explode: true
  }
};
var FieldModel = class {
  constructor(parser3, infoOrRef, pointer, options2, refsStack) {
    this.expanded = void 0;
    var _a2, _b, _c, _d, _e;
    makeObservable3(this);
    const { resolved: info } = parser3.deref(infoOrRef);
    this.kind = infoOrRef.kind || "field";
    this.name = infoOrRef.name || info.name;
    this.in = info.in;
    this.required = !!info.required;
    let fieldSchema = info.schema;
    let serializationMime = "";
    if (!fieldSchema && info.in && info.content) {
      serializationMime = Object.keys(info.content)[0];
      fieldSchema = info.content[serializationMime] && info.content[serializationMime].schema;
    }
    this.schema = new SchemaModel(parser3, fieldSchema || {}, pointer, options2, false, refsStack);
    this.description = info.description === void 0 ? this.schema.description || "" : info.description;
    this.example = info.example || this.schema.example;
    if (info.examples !== void 0 || this.schema.examples !== void 0) {
      const exampleValue = info.examples || this.schema.examples;
      this.examples = isArray(exampleValue) ? exampleValue : mapValues(
        exampleValue,
        (example, name2) => new ExampleModel(parser3, example, name2, info.encoding)
      );
    }
    if (serializationMime) {
      this.serializationMime = serializationMime;
    } else if (info.style) {
      this.style = info.style;
    } else if (this.in) {
      this.style = (_b = (_a2 = DEFAULT_SERIALIZATION[this.in]) == null ? void 0 : _a2.style) != null ? _b : "form";
    }
    if (info.explode === void 0 && this.in) {
      this.explode = (_d = (_c = DEFAULT_SERIALIZATION[this.in]) == null ? void 0 : _c.explode) != null ? _d : true;
    } else {
      this.explode = !!info.explode;
    }
    this.deprecated = info.deprecated === void 0 ? !!this.schema.deprecated : info.deprecated;
    if (options2.showExtensions) {
      this.extensions = extractExtensions(info, options2.showExtensions);
    }
    this.const = ((_e = this.schema) == null ? void 0 : _e.const) || (info == null ? void 0 : info.const) || "";
  }
  toggle() {
    this.expanded = !this.expanded;
  }
  collapse() {
    this.expanded = false;
  }
  expand() {
    this.expanded = true;
  }
};
__decorateClass([
  observable3
], FieldModel.prototype, "expanded", 2);
__decorateClass([
  action3
], FieldModel.prototype, "toggle", 1);
__decorateClass([
  action3
], FieldModel.prototype, "collapse", 1);
__decorateClass([
  action3
], FieldModel.prototype, "expand", 1);

// src/services/models/MediaContent.ts
import { action as action4, computed, observable as observable4, makeObservable as makeObservable4 } from "mobx";

// src/services/models/MediaType.ts
import { sample } from "@har-sdk/openapi-sampler";
var MediaTypeModel = class {
  /**
   * @param isRequestType needed to know if skipe RO/RW fields in objects
   */
  constructor(parser3, name2, isRequestType, info, options2) {
    this.name = name2;
    this.isRequestType = isRequestType;
    this.schema = info.schema && new SchemaModel(parser3, info.schema, "", options2);
    this.onlyRequiredInSamples = options2.onlyRequiredInSamples;
    this.generatedSamplesMaxDepth = options2.generatedSamplesMaxDepth;
    if (info.examples !== void 0) {
      this.examples = mapValues(
        info.examples,
        (example) => new ExampleModel(parser3, example, name2, info.encoding)
      );
    } else if (info.example !== void 0) {
      this.examples = {
        default: new ExampleModel(
          parser3,
          { value: parser3.deref(info.example).resolved },
          name2,
          info.encoding
        )
      };
    } else if (isJsonLike(name2)) {
      this.generateExample(parser3, info);
    }
  }
  generateExample(parser3, info) {
    const samplerOptions = {
      skipReadOnly: this.isRequestType,
      skipWriteOnly: !this.isRequestType,
      skipNonRequired: this.isRequestType && this.onlyRequiredInSamples,
      maxSampleDepth: this.generatedSamplesMaxDepth
    };
    if (this.schema && this.schema.oneOf) {
      this.examples = {};
      for (const subSchema of this.schema.oneOf) {
        const sampleOutput = sample(subSchema.rawSchema, samplerOptions, parser3.spec);
        if (this.schema.discriminatorProp && typeof sampleOutput === "object" && sampleOutput) {
          sampleOutput[this.schema.discriminatorProp] = subSchema.title;
        }
        this.examples[subSchema.title] = new ExampleModel(
          parser3,
          {
            value: sampleOutput
          },
          this.name,
          info.encoding
        );
      }
    } else if (this.schema) {
      this.examples = {
        default: new ExampleModel(
          parser3,
          {
            value: sample(info.schema, samplerOptions, parser3.spec)
          },
          this.name,
          info.encoding
        )
      };
    }
  }
};

// src/services/models/MediaContent.ts
var MediaContentModel = class {
  /**
   * @param isRequestType needed to know if skipe RO/RW fields in objects
   */
  constructor(parser3, info, isRequestType, options2) {
    this.isRequestType = isRequestType;
    this.activeMimeIdx = 0;
    makeObservable4(this);
    if (options2.unstable_ignoreMimeParameters) {
      info = mergeSimilarMediaTypes(info);
    }
    this.mediaTypes = Object.keys(info).map((name2) => {
      const mime = info[name2];
      return new MediaTypeModel(parser3, name2, isRequestType, mime, options2);
    });
  }
  activate(idx) {
    this.activeMimeIdx = idx;
  }
  get active() {
    return this.mediaTypes[this.activeMimeIdx];
  }
  get hasSample() {
    return this.mediaTypes.filter((mime) => !!mime.examples).length > 0;
  }
};
__decorateClass([
  observable4
], MediaContentModel.prototype, "activeMimeIdx", 2);
__decorateClass([
  action4
], MediaContentModel.prototype, "activate", 1);
__decorateClass([
  computed
], MediaContentModel.prototype, "active", 1);

// src/services/models/RequestBody.ts
var RequestBodyModel = class {
  constructor({ parser: parser3, infoOrRef, options: options2, isEvent }) {
    const isRequest = !isEvent;
    const { resolved: info } = parser3.deref(infoOrRef);
    this.description = info.description || "";
    this.required = info.required;
    const mediaContent = getContentWithLegacyExamples(info);
    if (mediaContent !== void 0) {
      this.content = new MediaContentModel(parser3, mediaContent, isRequest, options2);
    }
  }
};

// src/services/models/Response.ts
import { action as action5, observable as observable5, makeObservable as makeObservable5 } from "mobx";
var ResponseModel = class {
  constructor({
    parser: parser3,
    code,
    defaultAsError,
    infoOrRef,
    options: options2,
    isEvent: isRequest
  }) {
    this.expanded = false;
    this.headers = [];
    makeObservable5(this);
    this.expanded = options2.expandResponses === "all" || options2.expandResponses[code];
    const { resolved: info } = parser3.deref(infoOrRef);
    this.code = code;
    if (info.content !== void 0) {
      this.content = new MediaContentModel(parser3, info.content, isRequest, options2);
    }
    if (info["x-summary"] !== void 0) {
      this.summary = info["x-summary"];
      this.description = info.description || "";
    } else {
      this.summary = info.description || "";
      this.description = "";
    }
    this.type = getStatusCodeType(code, defaultAsError);
    const headers = info.headers;
    if (headers !== void 0) {
      this.headers = Object.keys(headers).map((name2) => {
        const header = headers[name2];
        return new FieldModel(parser3, { ...header, name: name2 }, "", options2);
      });
    }
    if (options2.showExtensions) {
      this.extensions = extractExtensions(info, options2.showExtensions);
    }
  }
  toggle() {
    this.expanded = !this.expanded;
  }
};
__decorateClass([
  observable5
], ResponseModel.prototype, "expanded", 2);
__decorateClass([
  action5
], ResponseModel.prototype, "toggle", 1);

// src/services/models/Operation.ts
function isPayloadSample(sample2) {
  return sample2.lang === "payload" && sample2.requestBodyContent;
}
var isCodeSamplesWarningPrinted = false;
var OperationModel = class {
  constructor(parser3, operationSpec, parent, options2, isCallback = false) {
    this.parser = parser3;
    this.operationSpec = operationSpec;
    this.options = options2;
    this.type = "operation";
    this.items = [];
    this.ready = true;
    this.active = false;
    this.expanded = false;
    var _a2;
    makeObservable6(this);
    this.pointer = operationSpec.pointer;
    this.description = operationSpec.description;
    this.parent = parent;
    this.externalDocs = operationSpec.externalDocs;
    this.deprecated = !!operationSpec.deprecated;
    this.httpVerb = operationSpec.httpVerb;
    this.deprecated = !!operationSpec.deprecated;
    this.operationId = operationSpec.operationId;
    this.path = operationSpec.pathName;
    this.isCallback = isCallback;
    this.isWebhook = operationSpec.isWebhook;
    this.isEvent = this.isCallback || this.isWebhook;
    this.name = getOperationSummary(operationSpec);
    this.sidebarLabel = options2.sideNavStyle === "id-only" /* IdOnly */ ? this.operationId || this.path : options2.sideNavStyle === "path-only" /* PathOnly */ ? this.path : this.name;
    this.badges = ((_a2 = operationSpec["x-badges"]) == null ? void 0 : _a2.map(({ name: name2, color, position }) => ({
      name: name2,
      color,
      position: position || "after"
    }))) || [];
    if (this.isCallback) {
      this.security = (operationSpec.security || []).map(
        (security) => new SecurityRequirementModel(security, parser3)
      );
      this.servers = normalizeServers("", operationSpec.servers || operationSpec.pathServers || []);
    } else {
      this.operationHash = operationSpec.operationId && "operation/" + operationSpec.operationId;
      this.id = operationSpec.operationId !== void 0 ? (parent ? parent.id + "/" : "") + this.operationHash : parent !== void 0 ? parent.id + this.pointer : this.pointer;
      this.security = (operationSpec.security || parser3.spec.security || []).map(
        (security) => new SecurityRequirementModel(security, parser3)
      );
      this.servers = normalizeServers(
        parser3.specUrl,
        operationSpec.servers || operationSpec.pathServers || parser3.spec.servers || []
      );
    }
    if (options2.showExtensions) {
      this.extensions = extractExtensions(operationSpec, options2.showExtensions);
    }
  }
  activate() {
    this.active = true;
  }
  deactivate() {
    this.active = false;
  }
  toggle() {
    this.expanded = !this.expanded;
  }
  expand() {
    if (this.parent) {
      this.parent.expand();
    }
  }
  collapse() {
  }
  get requestBody() {
    return this.operationSpec.requestBody && new RequestBodyModel({
      parser: this.parser,
      infoOrRef: this.operationSpec.requestBody,
      options: this.options,
      isEvent: this.isEvent
    });
  }
  get codeSamples() {
    const { payloadSampleIdx, hideRequestPayloadSample } = this.options;
    let samples = this.operationSpec["x-codeSamples"] || this.operationSpec["x-code-samples"] || [];
    if (this.operationSpec["x-code-samples"] && !isCodeSamplesWarningPrinted) {
      isCodeSamplesWarningPrinted = true;
      console.warn('"x-code-samples" is deprecated. Use "x-codeSamples" instead');
    }
    const requestBodyContent = this.requestBody && this.requestBody.content;
    if (requestBodyContent && requestBodyContent.hasSample && !hideRequestPayloadSample) {
      const insertInx = Math.min(samples.length, payloadSampleIdx);
      samples = [
        ...samples.slice(0, insertInx),
        {
          lang: "payload",
          label: "Payload",
          source: "",
          requestBodyContent
        },
        ...samples.slice(insertInx)
      ];
    }
    return samples;
  }
  get parameters() {
    const _parameters = mergeParams(
      this.parser,
      this.operationSpec.pathParameters,
      this.operationSpec.parameters
      // TODO: fix pointer
    ).map((paramOrRef) => new FieldModel(this.parser, paramOrRef, this.pointer, this.options));
    if (this.options.sortPropsAlphabetically) {
      return sortByField(_parameters, "name");
    }
    if (this.options.sortRequiredPropsFirst) {
      return sortByRequired(_parameters);
    }
    return _parameters;
  }
  get responses() {
    let hasSuccessResponses = false;
    return Object.keys(this.operationSpec.responses || []).filter((code) => {
      if (code === "default") {
        return true;
      }
      if (getStatusCodeType(code) === "success") {
        hasSuccessResponses = true;
      }
      return isStatusCode(code);
    }).map((code) => {
      return new ResponseModel({
        parser: this.parser,
        code,
        defaultAsError: hasSuccessResponses,
        infoOrRef: this.operationSpec.responses[code],
        options: this.options,
        isEvent: this.isEvent
      });
    });
  }
  get callbacks() {
    return Object.keys(this.operationSpec.callbacks || []).map((callbackEventName) => {
      return new CallbackModel(
        this.parser,
        callbackEventName,
        this.operationSpec.callbacks[callbackEventName],
        this.pointer,
        this.options
      );
    });
  }
};
__decorateClass([
  observable6
], OperationModel.prototype, "ready", 2);
__decorateClass([
  observable6
], OperationModel.prototype, "active", 2);
__decorateClass([
  observable6
], OperationModel.prototype, "expanded", 2);
__decorateClass([
  action6
], OperationModel.prototype, "activate", 1);
__decorateClass([
  action6
], OperationModel.prototype, "deactivate", 1);
__decorateClass([
  action6
], OperationModel.prototype, "toggle", 1);
__decorateClass([
  memoize
], OperationModel.prototype, "requestBody", 1);
__decorateClass([
  memoize
], OperationModel.prototype, "codeSamples", 1);
__decorateClass([
  memoize
], OperationModel.prototype, "parameters", 1);
__decorateClass([
  memoize
], OperationModel.prototype, "responses", 1);
__decorateClass([
  memoize
], OperationModel.prototype, "callbacks", 1);

// src/services/models/Webhook.ts
var WebhookModel = class {
  constructor(parser3, options2, infoOrRef) {
    this.operations = [];
    const { resolved: webhooks } = parser3.deref(infoOrRef || {});
    this.initWebhooks(parser3, webhooks, options2);
  }
  initWebhooks(parser3, webhooks, options2) {
    for (const webhookName of Object.keys(webhooks)) {
      const webhook = webhooks[webhookName];
      const operations = Object.keys(webhook).filter(isOperationName);
      for (const operationName of operations) {
        const operationInfo = webhook[operationName];
        if (webhook.$ref) {
          const resolvedWebhook = parser3.deref(webhook || {});
          this.initWebhooks(parser3, { [operationName]: resolvedWebhook }, options2);
        }
        if (!operationInfo) continue;
        const operation = new OperationModel(
          parser3,
          {
            ...operationInfo,
            httpVerb: operationName
          },
          void 0,
          options2,
          false
        );
        this.operations.push(operation);
      }
    }
  }
};

// src/services/models/SecuritySchemes.ts
var SecuritySchemeModel = class {
  constructor(parser3, id, scheme) {
    const { resolved: info } = parser3.deref(scheme);
    this.id = id;
    this.sectionId = SECURITY_SCHEMES_SECTION_PREFIX + id;
    this.type = info.type;
    this.displayName = info["x-displayName"] || id;
    this.description = info.description || "";
    if (info.type === "apiKey") {
      this.apiKey = {
        name: info.name,
        in: info.in
      };
    }
    if (info.type === "http") {
      this.http = {
        scheme: info.scheme,
        bearerFormat: info.bearerFormat
      };
    }
    if (info.type === "openIdConnect") {
      this.openId = {
        connectUrl: info.openIdConnectUrl
      };
    }
    if (info.type === "oauth2" && info.flows) {
      this.flows = info.flows;
    }
  }
};
var SecuritySchemesModel = class {
  constructor(parser3) {
    const schemes = parser3.spec.components && parser3.spec.components.securitySchemes || {};
    this.schemes = Object.keys(schemes).map(
      (name2) => new SecuritySchemeModel(parser3, name2, schemes[name2])
    );
  }
};

// src/services/SpecStore.ts
var SpecStore = class {
  constructor(spec, specUrl, options2) {
    this.options = options2;
    var _a2, _b, _c;
    this.parser = new OpenAPIParser(spec, specUrl, options2);
    this.info = new ApiInfoModel(this.parser, this.options);
    this.externalDocs = this.parser.spec.externalDocs;
    this.contentItems = MenuBuilder.buildStructure(this.parser, this.options);
    this.securitySchemes = new SecuritySchemesModel(this.parser);
    const webhookPath = {
      ...(_b = (_a2 = this.parser) == null ? void 0 : _a2.spec) == null ? void 0 : _b["x-webhooks"],
      ...(_c = this.parser) == null ? void 0 : _c.spec.webhooks
    };
    this.webhooks = new WebhookModel(this.parser, options2, webhookPath);
  }
};

// src/services/models/Group.model.ts
import { action as action7, observable as observable7, makeObservable as makeObservable7 } from "mobx";
var GroupModel = class {
  //#endregion
  constructor(type, tagOrGroup, parent) {
    this.items = [];
    this.active = false;
    this.expanded = false;
    makeObservable7(this);
    this.id = tagOrGroup.id || type + "/" + safeSlugify(tagOrGroup.name);
    this.type = type;
    this.name = tagOrGroup["x-displayName"] || tagOrGroup.name;
    this.level = tagOrGroup.level || 1;
    this.sidebarLabel = this.name;
    this.description = tagOrGroup.description || "";
    const items = tagOrGroup.items;
    if (items && items.length) {
      this.description = MarkdownRenderer.getTextBeforeHading(this.description, items[0].name);
    }
    this.parent = parent;
    this.externalDocs = tagOrGroup.externalDocs;
    if (this.type === "group") {
      this.expanded = true;
    }
  }
  activate() {
    this.active = true;
  }
  expand() {
    if (this.parent) {
      this.parent.expand();
    }
    this.expanded = true;
  }
  collapse() {
    if (this.type === "group") {
      return;
    }
    this.expanded = false;
  }
  deactivate() {
    this.active = false;
  }
};
__decorateClass([
  observable7
], GroupModel.prototype, "active", 2);
__decorateClass([
  observable7
], GroupModel.prototype, "expanded", 2);
__decorateClass([
  action7
], GroupModel.prototype, "activate", 1);
__decorateClass([
  action7
], GroupModel.prototype, "expand", 1);
__decorateClass([
  action7
], GroupModel.prototype, "collapse", 1);
__decorateClass([
  action7
], GroupModel.prototype, "deactivate", 1);

// src/services/MenuBuilder.ts
var GROUP_DEPTH = 0;
var MenuBuilder = class _MenuBuilder {
  /**
   * Builds page content structure based on tags
   */
  static buildStructure(parser3, options2) {
    const spec = parser3.spec;
    const { schemaDefinitionsTagName } = options2;
    const items = [];
    const tags2 = [...spec.tags || []];
    const hasAutogenerated = tags2.find(
      (tag) => (tag == null ? void 0 : tag.name) === schemaDefinitionsTagName
    );
    if (!hasAutogenerated && schemaDefinitionsTagName) {
      tags2.push({ name: schemaDefinitionsTagName });
    }
    const tagsMap = _MenuBuilder.getTagsWithOperations(parser3, tags2);
    items.push(..._MenuBuilder.addMarkdownItems(spec.info.description || "", void 0, 1, options2));
    if (spec["x-tagGroups"] && spec["x-tagGroups"].length > 0) {
      items.push(
        ..._MenuBuilder.getTagGroupsItems(parser3, void 0, spec["x-tagGroups"], tagsMap, options2)
      );
    } else {
      items.push(..._MenuBuilder.getTagsItems(parser3, tagsMap, void 0, void 0, options2));
    }
    return items;
  }
  /**
   * extracts items from markdown description
   * @param description - markdown source
   */
  static addMarkdownItems(description, parent, initialDepth, options2) {
    const renderer2 = new MarkdownRenderer(options2, parent == null ? void 0 : parent.id);
    const headings = renderer2.extractHeadings(description || "");
    if (headings.length && parent && parent.description) {
      parent.description = MarkdownRenderer.getTextBeforeHading(
        parent.description,
        headings[0].name
      );
    }
    const mapHeadingsDeep = (_parent, items, depth = 1) => items.map((heading2) => {
      const group = new GroupModel("section", heading2, _parent);
      group.depth = depth;
      if (heading2.items) {
        group.items = mapHeadingsDeep(group, heading2.items, depth + 1);
      }
      return group;
    });
    return mapHeadingsDeep(parent, headings, initialDepth);
  }
  /**
   * Returns array of OperationsGroup items for the tag groups (x-tagGroups vendor extension)
   * @param tags value of `x-tagGroups` vendor extension
   */
  static getTagGroupsItems(parser3, parent, groups, tags2, options2) {
    const res = [];
    for (const group of groups) {
      const item = new GroupModel("group", group, parent);
      item.depth = GROUP_DEPTH;
      item.items = _MenuBuilder.getTagsItems(parser3, tags2, item, group, options2);
      res.push(item);
    }
    return res;
  }
  /**
   * Returns array of OperationsGroup items for the tags of the group or for all tags
   * @param parser
   * @param tagsMap tags info returned from `getTagsWithOperations`
   * @param parent parent item
   * @param group group which this tag belongs to. if not provided gets all tags
   * @param options normalized options
   */
  static getTagsItems(parser3, tagsMap, parent, group, options2) {
    let tagNames;
    if (group === void 0) {
      tagNames = Object.keys(tagsMap);
    } else {
      tagNames = group.tags;
    }
    const tags2 = tagNames.map((tagName) => {
      if (!tagsMap[tagName]) {
        console.warn(`Non-existing tag "${tagName}" is added to the group "${group.name}"`);
        return null;
      }
      tagsMap[tagName].used = true;
      return tagsMap[tagName];
    });
    const res = [];
    for (const tag of tags2) {
      if (!tag) {
        continue;
      }
      const item = new GroupModel("tag", tag, parent);
      item.depth = GROUP_DEPTH + 1;
      if (tag.name === "") {
        const items = [
          ..._MenuBuilder.addMarkdownItems(tag.description || "", item, item.depth + 1, options2),
          ...this.getOperationsItems(parser3, void 0, tag, item.depth + 1, options2)
        ];
        res.push(...items);
        continue;
      }
      const relatedSchemas = this.getTagRelatedSchema({
        parser: parser3,
        tag,
        parent: item,
        schemaDefinitionsTagName: options2.schemaDefinitionsTagName
      });
      item.items = [
        ...relatedSchemas,
        ..._MenuBuilder.addMarkdownItems(tag.description || "", item, item.depth + 1, options2),
        ...this.getOperationsItems(parser3, item, tag, item.depth + 1, options2)
      ];
      res.push(item);
    }
    if (options2.sortTagsAlphabetically) {
      res.sort(alphabeticallyByProp("name"));
    }
    return res;
  }
  /**
   * Returns array of Operation items for the tag
   * @param parser
   * @param parent parent OperationsGroup
   * @param tag tag info returned from `getTagsWithOperations`
   * @param depth items depth
   * @param options - normalized options
   */
  static getOperationsItems(parser3, parent, tag, depth, options2) {
    if (tag.operations.length === 0) {
      return [];
    }
    const res = [];
    for (const operationInfo of tag.operations) {
      const operation = new OperationModel(parser3, operationInfo, parent, options2);
      operation.depth = depth;
      res.push(operation);
    }
    if (options2.sortOperationsAlphabetically) {
      res.sort(alphabeticallyByProp("name"));
    }
    return res;
  }
  /**
   * collects tags and maps each tag to list of operations belonging to this tag
   */
  static getTagsWithOperations(parser3, explicitTags) {
    const { spec } = parser3;
    const tags2 = {};
    const webhooks = spec["x-webhooks"] || spec.webhooks;
    for (const tag of explicitTags || []) {
      tags2[tag.name] = { ...tag, operations: [] };
    }
    if (webhooks) {
      getTags(parser3, webhooks, true);
    }
    if (spec.paths) {
      getTags(parser3, spec.paths);
    }
    function getTags(parser4, paths, isWebhook) {
      for (const pathName of Object.keys(paths)) {
        const path = paths[pathName];
        const operations = Object.keys(path).filter(isOperationName);
        for (const operationName of operations) {
          const operationInfo = path[operationName];
          if (path.$ref) {
            const { resolved: resolvedPaths } = parser4.deref(path);
            getTags(parser4, { [pathName]: resolvedPaths }, isWebhook);
            continue;
          }
          let operationTags = operationInfo == null ? void 0 : operationInfo.tags;
          if (!operationTags || !operationTags.length) {
            operationTags = [""];
          }
          for (const tagName of operationTags) {
            let tag = tags2[tagName];
            if (tag === void 0) {
              tag = {
                name: tagName,
                operations: []
              };
              tags2[tagName] = tag;
            }
            if (tag["x-traitTag"]) {
              continue;
            }
            tag.operations.push({
              ...operationInfo,
              pathName,
              pointer: JsonPointer.compile(["paths", pathName, operationName]),
              httpVerb: operationName,
              pathParameters: path.parameters || [],
              pathServers: path.servers,
              isWebhook: !!isWebhook
            });
          }
        }
      }
    }
    return tags2;
  }
  static getTagRelatedSchema({
    parser: parser3,
    tag,
    parent,
    schemaDefinitionsTagName
  }) {
    var _a2;
    const defaultTags = schemaDefinitionsTagName ? [schemaDefinitionsTagName] : [];
    return Object.entries(((_a2 = parser3.spec.components) == null ? void 0 : _a2.schemas) || {}).map(([schemaName, schema]) => {
      const schemaTags = schema["x-tags"] || defaultTags;
      if (!(schemaTags == null ? void 0 : schemaTags.includes(tag.name))) return null;
      const item = new GroupModel(
        "schema",
        {
          name: schemaName,
          "x-displayName": `${schema.title || schemaName}`,
          description: `<SchemaDefinition showWriteOnly={true} schemaRef="#/components/schemas/${schemaName}" />`
        },
        parent
      );
      item.depth = parent.depth + 1;
      return item;
    }).filter(Boolean);
  }
};

// src/services/MenuStore.ts
var SECTION_ATTR = "data-section-id";
var MenuStore = class {
  /**
   *
   * @param spec [SpecStore](#SpecStore) which contains page content structure
   * @param scroll scroll service instance used by this menu
   */
  constructor(spec, scroll, history3) {
    this.scroll = scroll;
    this.history = history3;
    this.activeItemIdx = -1;
    this.sideBarOpened = false;
    /**
     * update active items on scroll
     * @param isScrolledDown whether last scroll was downside
     */
    this.updateOnScroll = (isScrolledDown) => {
      const step = isScrolledDown ? 1 : -1;
      let itemIdx = this.activeItemIdx;
      while (true) {
        if (itemIdx === -1 && !isScrolledDown) {
          break;
        }
        if (itemIdx >= this.flatItems.length - 1 && isScrolledDown) {
          break;
        }
        if (isScrolledDown) {
          const el = this.getElementAtOrFirstChild(itemIdx + 1);
          if (this.scroll.isElementBellow(el)) {
            break;
          }
        } else {
          const el = this.getElementAt(itemIdx);
          if (this.scroll.isElementAbove(el)) {
            break;
          }
        }
        itemIdx += step;
      }
      this.activate(this.flatItems[itemIdx], true, true);
    };
    /**
     * update active items on hash change
     * @param id current hash
     */
    this.updateOnHistory = (id = this.history.currentId) => {
      if (!id) {
        return;
      }
      let item;
      item = this.flatItems.find((i) => i.id === id);
      if (item) {
        this.activateAndScroll(item, false);
      } else {
        if (id.startsWith(SECURITY_SCHEMES_SECTION_PREFIX)) {
          item = this.flatItems.find((i) => SECURITY_SCHEMES_SECTION_PREFIX.startsWith(i.id));
          this.activateAndScroll(item, false);
        }
        this.scroll.scrollIntoViewBySelector(`[${SECTION_ATTR}="${escapeHTMLAttrChars(id)}"]`);
      }
    };
    this.getItemById = (id) => {
      return this.flatItems.find((item) => item.id === id);
    };
    makeObservable8(this);
    this.items = spec.contentItems;
    this.flatItems = flattenByProp(this.items || [], "items");
    this.flatItems.forEach((item, idx) => item.absoluteIdx = idx);
    this.subscribe();
  }
  /**
   * Statically try update scroll position
   * Used before hydrating from server-side rendered html to scroll page faster
   */
  static updateOnHistory(id = history.currentId, scroll) {
    if (!id) {
      return;
    }
    scroll.scrollIntoViewBySelector(`[${SECTION_ATTR}="${escapeHTMLAttrChars(id)}"]`);
  }
  subscribe() {
    this._unsubscribe = this.scroll.subscribe(this.updateOnScroll);
    this._hashUnsubscribe = this.history.subscribe(this.updateOnHistory);
  }
  toggleSidebar() {
    this.sideBarOpened = this.sideBarOpened ? false : true;
  }
  closeSidebar() {
    this.sideBarOpened = false;
  }
  /**
   * get section/operation DOM Node related to the item or null if it doesn't exist
   * @param idx item absolute index
   */
  getElementAt(idx) {
    const item = this.flatItems[idx];
    return item && querySelector(`[${SECTION_ATTR}="${escapeHTMLAttrChars(item.id)}"]`) || null;
  }
  /**
   * get section/operation DOM Node related to the item or if it is group item, returns first item of the group
   * @param idx item absolute index
   */
  getElementAtOrFirstChild(idx) {
    let item = this.flatItems[idx];
    if (item && item.type === "group") {
      item = item.items[0];
    }
    return item && querySelector(`[${SECTION_ATTR}="${escapeHTMLAttrChars(item.id)}"]`) || null;
  }
  /**
   * current active item
   */
  get activeItem() {
    return this.flatItems[this.activeItemIdx] || void 0;
  }
  activate(item, updateLocation = true, rewriteHistory = false) {
    if ((this.activeItem && this.activeItem.id) === (item && item.id)) {
      return;
    }
    if (item && item.type === "group") {
      return;
    }
    this.deactivate(this.activeItem);
    if (!item) {
      this.activeItemIdx = -1;
      this.history.replace("", rewriteHistory);
      return;
    }
    if (item.depth <= GROUP_DEPTH) {
      return;
    }
    this.activeItemIdx = item.absoluteIdx;
    if (updateLocation) {
      this.history.replace(encodeURI(item.id), rewriteHistory);
    }
    item.activate();
    item.expand();
  }
  /**
   * makes item and all the parents not active
   * @param item item to deactivate
   */
  deactivate(item) {
    if (item === void 0) {
      return;
    }
    item.deactivate();
    while (item !== void 0) {
      item.collapse();
      item = item.parent;
    }
  }
  activateAndScroll(item, updateLocation, rewriteHistory) {
    const menuItem = item && this.getItemById(item.id) || item;
    this.activate(menuItem, updateLocation, rewriteHistory);
    this.scrollToActive();
    if (!menuItem || !menuItem.items.length) {
      this.closeSidebar();
    }
  }
  /**
   * scrolls to active section
   */
  scrollToActive() {
    this.scroll.scrollIntoView(this.getElementAt(this.activeItemIdx));
  }
  dispose() {
    this._unsubscribe();
    this._hashUnsubscribe();
  }
};
__decorateClass([
  observable8
], MenuStore.prototype, "activeItemIdx", 2);
__decorateClass([
  observable8
], MenuStore.prototype, "sideBarOpened", 2);
__decorateClass([
  action8
], MenuStore.prototype, "toggleSidebar", 1);
__decorateClass([
  action8
], MenuStore.prototype, "closeSidebar", 1);
__decorateClass([
  action8
], MenuStore.prototype, "activate", 1);
__decorateClass([
  action8.bound
], MenuStore.prototype, "activateAndScroll", 1);

// src/services/ScrollService.ts
var import_decko2 = __toESM(require_decko(), 1);
var EVENT2 = "scroll";
var ScrollService = class {
  constructor(options2) {
    this.options = options2;
    this._prevOffsetY = 0;
    this._scrollParent = IS_BROWSER ? window : void 0;
    this._emiter = new import_index.default();
    this.bind();
  }
  bind() {
    this._prevOffsetY = this.scrollY();
    if (this._scrollParent) {
      this._scrollParent.addEventListener("scroll", this.handleScroll);
    }
  }
  dispose() {
    if (this._scrollParent) {
      this._scrollParent.removeEventListener("scroll", this.handleScroll);
    }
    this._emiter.removeAllListeners(EVENT2);
  }
  scrollY() {
    if (typeof HTMLElement !== "undefined" && this._scrollParent instanceof HTMLElement) {
      return this._scrollParent.scrollTop;
    } else if (this._scrollParent !== void 0) {
      return this._scrollParent.pageYOffset;
    } else {
      return 0;
    }
  }
  isElementBellow(el) {
    if (el === null) {
      return;
    }
    return el.getBoundingClientRect().top > this.options.scrollYOffset();
  }
  isElementAbove(el) {
    if (el === null) {
      return;
    }
    const top2 = el.getBoundingClientRect().top;
    return (top2 > 0 ? Math.floor(top2) : Math.ceil(top2)) <= this.options.scrollYOffset();
  }
  subscribe(cb) {
    const emmiter = this._emiter.addListener(EVENT2, cb);
    return () => emmiter.removeListener(EVENT2, cb);
  }
  scrollIntoView(element) {
    if (element === null) {
      return;
    }
    element.scrollIntoView();
    if (this._scrollParent && this._scrollParent.scrollBy) {
      this._scrollParent.scrollBy(0, -this.options.scrollYOffset() + 1);
    }
  }
  scrollIntoViewBySelector(selector) {
    const element = querySelector(selector);
    this.scrollIntoView(element);
  }
  handleScroll() {
    const scrollY = this.scrollY();
    const isScrolledDown = scrollY - this._prevOffsetY > 0;
    this._prevOffsetY = this.scrollY();
    this._emiter.emit(EVENT2, isScrolledDown);
  }
};
__decorateClass([
  import_decko2.bind,
  Throttle(100)
], ScrollService.prototype, "handleScroll", 1);

// src/services/SearchWorker.worker.ts
var import_lunr = __toESM(require_lunr(), 1);
var store = [];
import_lunr.default.tokenizer.separator = /\s+/;
var builder;
var resolveIndex;
var index;
function initEmpty() {
  builder = new import_lunr.default.Builder();
  builder.field("title");
  builder.field("description");
  builder.ref("ref");
  builder.pipeline.add(import_lunr.default.trimmer, import_lunr.default.stopWordFilter, import_lunr.default.stemmer);
  index = new Promise((resolve) => {
    resolveIndex = resolve;
  });
}
initEmpty();
var expandTerm = (term) => {
  const token = import_lunr.default.trimmer(new import_lunr.default.Token(term, {}));
  return "*" + import_lunr.default.stemmer(token) + "*";
};
function add(title, description, meta2) {
  const ref = store.push(meta2) - 1;
  const item = { title: title.toLowerCase(), description: description.toLowerCase(), ref };
  builder.add(item);
}
async function done() {
  resolveIndex(builder.build());
}
async function toJS() {
  return {
    store,
    index: (await index).toJSON()
  };
}
async function fromExternalJS(path, exportName) {
  try {
    importScripts(path);
    if (!self[exportName]) {
      throw new Error("Broken index file format");
    }
    load(self[exportName]);
  } catch (e) {
    console.error("Failed to load search index: " + e.message);
  }
}
async function load(state) {
  store = state.store;
  resolveIndex(import_lunr.default.Index.load(state.index));
}
async function dispose() {
  store = [];
  initEmpty();
}
async function search(q, limit = 0) {
  if (q.trim().length === 0) {
    return [];
  }
  let searchResults = (await index).query((t2) => {
    q.trim().toLowerCase().split(/\s+/).forEach((term) => {
      if (term.length === 1) return;
      const exp = expandTerm(term);
      t2.term(exp, {});
    });
  });
  if (limit > 0) {
    searchResults = searchResults.slice(0, limit);
  }
  return searchResults.map((res) => ({ meta: store[res.ref], score: res.score }));
}

// src/services/SearchStore.ts
var SearchStore = class {
  indexItems(groups) {
    const recurse = (items) => {
      items.forEach((group) => {
        if (group.type !== "group") {
          this.add(group.name, (group.description || "").concat(" ", group.path || ""), group.id);
        }
        recurse(group.items);
      });
    };
    recurse(groups);
    done();
  }
  add(title, body, meta2) {
    add(title, body, meta2);
  }
  dispose() {
    dispose();
  }
  search(q) {
    return search(q);
  }
  async toJS() {
    return toJS();
  }
  load(state) {
    load(state);
  }
  fromExternalJS(path, exportName) {
    if (path && exportName) {
      fromExternalJS(path, exportName);
    }
  }
};

// src/components/SchemaDefinition/SchemaDefinition.tsx
import React29 from "react";

// src/common-elements/panels.ts
var MiddlePanel = styled_components_default.div`
  width: calc(100% - ${(props) => props.theme.rightPanel.width});
  padding: 0 ${(props) => props.theme.spacing.sectionHorizontal}px;

  ${({ $compact, theme: theme2 }) => media.lessThan("medium", true)`
    width: 100%;
    padding: ${`${$compact ? 0 : theme2.spacing.sectionVertical}px ${theme2.spacing.sectionHorizontal}px`};
  `};
`;
var Section = styled_components_default.div.attrs((props) => ({
  [SECTION_ATTR]: props.id
}))`
  padding: ${(props) => props.theme.spacing.sectionVertical}px 0;

  &:last-child {
    min-height: calc(100vh + 1px);
  }

  & > &:last-child {
    min-height: initial;
  }

  ${media.lessThan("medium", true)`
    padding: 0;
  `}
  ${({ $underlined }) => $underlined && `
    position: relative;

    &:not(:last-of-type):after {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: block;
      content: '';
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    }
  ` || ""}
`;
var RightPanel = styled_components_default.div`
  width: ${(props) => props.theme.rightPanel.width};
  color: ${({ theme: theme2 }) => theme2.rightPanel.textColor};
  background-color: ${(props) => props.theme.rightPanel.backgroundColor};
  padding: 0 ${(props) => props.theme.spacing.sectionHorizontal}px;

  ${media.lessThan("medium", true)`
    width: 100%;
    padding: ${(props) => `${props.theme.spacing.sectionVertical}px ${props.theme.spacing.sectionHorizontal}px`};
  `};
`;
var DarkRightPanel = styled_components_default(RightPanel)`
  background-color: transparent;

  & > *:not(:last-child) {
    margin-bottom: 10px;
  }
`;
var Row = styled_components_default.div`
  display: flex;
  width: 100%;
  padding: 0;

  ${media.lessThan("medium", true)`
    flex-direction: column;
  `};
`;

// src/common-elements/headers.ts
var headerFontSize = {
  1: "1.85714em",
  2: "1.57143em",
  3: "1.27em"
};
var headerCommonMixin = (level2) => css`
  font-family: ${({ theme: theme2 }) => theme2.typography.headings.fontFamily};
  font-weight: ${({ theme: theme2 }) => theme2.typography.headings.fontWeight};
  font-size: ${headerFontSize[level2]};
  line-height: ${({ theme: theme2 }) => theme2.typography.headings.lineHeight};
`;
var H1 = styled_components_default.h1`
  ${headerCommonMixin(1)};
  color: ${({ theme: theme2 }) => theme2.colors.text.primary};

  ${extensionsHook("H1")};
`;
var H2 = styled_components_default.h2`
  ${headerCommonMixin(2)};
  color: ${({ theme: theme2 }) => theme2.colors.text.primary};
  margin: 0 0 20px;

  ${extensionsHook("H2")};
`;
var H3 = styled_components_default.h2`
  ${headerCommonMixin(3)};
  color: ${({ theme: theme2 }) => theme2.colors.text.primary};

  ${extensionsHook("H3")};
`;
var RightPanelHeader = styled_components_default.h3`
  color: ${({ theme: theme2 }) => theme2.rightPanel.textColor};

  ${extensionsHook("RightPanelHeader")};
`;
var UnderlinedHeader = styled_components_default.h5`
  border-bottom: 1px solid rgba(38, 50, 56, 0.3);
  margin: 1em 0 1em 0;
  color: rgba(38, 50, 56, 0.5);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 0.929em;
  line-height: 20px;

  ${extensionsHook("UnderlinedHeader")};
`;

// src/common-elements/linkify.tsx
import React5 from "react";

// src/components/StoreBuilder.ts
import React4 from "react";
import { createContext, useContext } from "react";
var StoreContext = createContext(void 0);
var { Provider, Consumer } = StoreContext;
function StoreBuilder(props) {
  const { spec, specUrl, options: options2, onLoaded, children } = props;
  const [resolvedSpec, setResolvedSpec] = React4.useState(null);
  const [error, setError] = React4.useState(null);
  if (error) {
    throw error;
  }
  React4.useEffect(() => {
    async function load2() {
      if (!spec && !specUrl) {
        return void 0;
      }
      setResolvedSpec(null);
      try {
        const resolved = await loadAndBundleSpec(spec || specUrl);
        setResolvedSpec(resolved);
      } catch (e) {
        if (onLoaded) {
          onLoaded(e);
        }
        setError(e);
        throw e;
      }
    }
    load2();
  }, [spec, specUrl]);
  const store2 = React4.useMemo(() => {
    if (!resolvedSpec) return null;
    try {
      return new AppStore(resolvedSpec, specUrl, options2);
    } catch (e) {
      if (onLoaded) {
        onLoaded(e);
      }
      throw e;
    }
  }, [resolvedSpec, specUrl, options2]);
  React4.useEffect(() => {
    if (store2 && onLoaded) {
      onLoaded();
    }
  }, [store2, onLoaded]);
  return children({
    loading: !store2,
    store: store2
  });
}
function useStore() {
  return useContext(StoreContext);
}

// src/common-elements/linkify.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
var linkifyMixin = (className) => css`
  ${className} {
    cursor: pointer;
    margin-left: -20px;
    padding: 0;
    line-height: 1;
    width: 20px;
    display: inline-block;
    outline: 0;
  }
  ${className}:before {
    content: '';
    width: 15px;
    height: 15px;
    background-size: contain;
    background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSIjMDEwMTAxIiBkPSJNNDU5LjcgMjMzLjRsLTkwLjUgOTAuNWMtNTAgNTAtMTMxIDUwLTE4MSAwIC03LjktNy44LTE0LTE2LjctMTkuNC0yNS44bDQyLjEtNDIuMWMyLTIgNC41LTMuMiA2LjgtNC41IDIuOSA5LjkgOCAxOS4zIDE1LjggMjcuMiAyNSAyNSA2NS42IDI0LjkgOTAuNSAwbDkwLjUtOTAuNWMyNS0yNSAyNS02NS42IDAtOTAuNSAtMjQuOS0yNS02NS41LTI1LTkwLjUgMGwtMzIuMiAzMi4yYy0yNi4xLTEwLjItNTQuMi0xMi45LTgxLjYtOC45bDY4LjYtNjguNmM1MC01MCAxMzEtNTAgMTgxIDBDNTA5LjYgMTAyLjMgNTA5LjYgMTgzLjQgNDU5LjcgMjMzLjR6TTIyMC4zIDM4Mi4ybC0zMi4yIDMyLjJjLTI1IDI0LjktNjUuNiAyNC45LTkwLjUgMCAtMjUtMjUtMjUtNjUuNiAwLTkwLjVsOTAuNS05MC41YzI1LTI1IDY1LjUtMjUgOTAuNSAwIDcuOCA3LjggMTIuOSAxNy4yIDE1LjggMjcuMSAyLjQtMS40IDQuOC0yLjUgNi44LTQuNWw0Mi4xLTQyYy01LjQtOS4yLTExLjYtMTgtMTkuNC0yNS44IC01MC01MC0xMzEtNTAtMTgxIDBsLTkwLjUgOTAuNWMtNTAgNTAtNTAgMTMxIDAgMTgxIDUwIDUwIDEzMSA1MCAxODEgMGw2OC42LTY4LjZDMjc0LjYgMzk1LjEgMjQ2LjQgMzkyLjMgMjIwLjMgMzgyLjJ6Ii8+PC9zdmc+Cg==');
    opacity: 0.5;
    visibility: hidden;
    display: inline-block;
    vertical-align: middle;
  }

  h1:hover > ${className}::before, h2:hover > ${className}::before, ${className}:hover::before {
    visibility: visible;
  }
`;
var isModifiedEvent = (event) => !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
function Link(props) {
  const store2 = React5.useContext(StoreContext);
  const clickHandler = React5.useCallback(
    (event) => {
      if (!store2) return;
      navigate(store2.menu.history, event, props.to);
    },
    [store2, props.to]
  );
  if (!store2) return null;
  return /* @__PURE__ */ jsx4(
    "a",
    {
      className: props.className,
      href: store2.menu.history.linkForId(props.to),
      onClick: clickHandler,
      "aria-label": props.to,
      children: props.children
    }
  );
}
function navigate(history3, event, to) {
  if (!event.defaultPrevented && // onClick prevented default
  event.button === 0 && // ignore everything but left clicks
  !isModifiedEvent(event)) {
    event.preventDefault();
    history3.replace(encodeURI(to));
  }
}
var StyledShareLink = styled_components_default(Link)`
  ${linkifyMixin("&")};
`;
function ShareLink(props) {
  return /* @__PURE__ */ jsx4(StyledShareLink, { to: props.to });
}

// src/common-elements/shelfs.tsx
import { jsx as jsx5 } from "react/jsx-runtime";
var directionMap = {
  left: "90deg",
  right: "-90deg",
  up: "-180deg",
  down: "0"
};
var IntShelfIcon = (props) => {
  return /* @__PURE__ */ jsx5(
    "svg",
    {
      className: props.className,
      style: props.style,
      version: "1.1",
      viewBox: "0 0 24 24",
      x: "0",
      xmlns: "http://www.w3.org/2000/svg",
      y: "0",
      "aria-hidden": "true",
      children: /* @__PURE__ */ jsx5("polygon", { points: "17.3 8.3 12 13.6 6.7 8.3 5.3 9.7 12 16.4 18.7 9.7 " })
    }
  );
};
var ShelfIcon = styled_components_default(IntShelfIcon)`
  height: ${(props) => props.size || "18px"};
  width: ${(props) => props.size || "18px"};
  min-width: ${(props) => props.size || "18px"};
  vertical-align: middle;
  float: ${(props) => props.float || ""};
  transition: transform 0.2s ease-out;
  transform: rotateZ(${(props) => directionMap[props.direction || "down"]});

  polygon {
    fill: ${({ color, theme: theme2 }) => color && theme2.colors.responses[color] && theme2.colors.responses[color].color || color};
  }
`;
var Badge = styled_components_default.span`
  display: inline-block;
  padding: 2px 8px;
  margin: 0;
  background-color: ${(props) => props.color || props.theme.colors[props.type].main};
  color: ${(props) => props.theme.colors[props.type].contrastText};
  font-size: ${(props) => props.theme.typography.code.fontSize};
  vertical-align: middle;
  line-height: 1.6;
  border-radius: 4px;
  font-weight: ${({ theme: theme2 }) => theme2.typography.fontWeightBold};
  font-size: 12px;
  + span[type] {
    margin-left: 4px;
  }
`;
var IntPadlockIcon = (props) => /* @__PURE__ */ jsx5("svg", { version: "1.1", viewBox: "0 0 100 100", ...props, children: /* @__PURE__ */ jsx5("path", { d: "M16.1 45.4V92.5h67.8V45.4H16.1zM53.9 70.9v12.4h-7.4V70.9c-3.2-1.4-5.4-4.6-5.4-8.2 0-5 4-9 9-9 5 0 9 4.1 9 9C59.3 66.3 57.1 69.5 53.9 70.9zM37.2 39.8c-0.3 0-1.4-2.9-1.4-2.9 -0.5-1.5-0.7-3-0.7-4.6 0-8.4 6.8-15.2 15.2-15.2 8.4 0 15.2 6.8 15.2 15.2 0 1.6-0.2 3.1-0.7 4.6l0 0 0 0c0 0-1.1 2.9-1.4 2.9 -0.3 0 10.4 0 10.6 0l0 0c0.8-2.4 1.2-4.9 1.2-7.5C75.1 18.6 64 7.5 50.3 7.5c-13.7 0-24.8 11.1-24.8 24.8 0 2.5 0.4 5.1 1.2 7.5C26.6 39.8 37.5 39.8 37.2 39.8z" }) });
var IntErrorIcon = (props) => /* @__PURE__ */ jsx5("svg", { version: "1.1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 122.879 122.879", ...props, children: /* @__PURE__ */ jsx5(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M61.44,0c33.933,0,61.439,27.507,61.439,61.439 s-27.506,61.439-61.439,61.439C27.507,122.879,0,95.372,0,61.439S27.507,0,61.44,0L61.44,0z M73.451,39.151 c2.75-2.793,7.221-2.805,9.986-0.027c2.764,2.776,2.775,7.292,0.027,10.083L71.4,61.445l12.076,12.249 c2.729,2.77,2.689,7.257-0.08,10.022c-2.773,2.765-7.23,2.758-9.955-0.013L61.446,71.54L49.428,83.728 c-2.75,2.793-7.22,2.805-9.986,0.027c-2.763-2.776-2.776-7.293-0.027-10.084L51.48,61.434L39.403,49.185 c-2.728-2.769-2.689-7.256,0.082-10.022c2.772-2.765,7.229-2.758,9.953,0.013l11.997,12.165L73.451,39.151L73.451,39.151z"
  }
) });
var PadlockIcon = styled_components_default(IntPadlockIcon)`
  height: ${(props) => props.size || "18px"};
  width: ${(props) => props.size || "18px"};
  min-width: ${(props) => props.size || "18px"};
  vertical-align: middle;
  float: ${(props) => props.float || ""};

  path {
    fill: ${({ color, theme: theme2 }) => color && theme2.colors.responses[color] && theme2.colors.responses[color].color || color};
  }
`;
var ErrorIcon = styled_components_default(IntErrorIcon)`
  height: ${(props) => props.size || "18px"};
  width: ${(props) => props.size || "18px"};
  min-width: ${(props) => props.size || "18px"};
  vertical-align: middle;
  float: ${(props) => props.float || ""};

  path {
    fill: ${({ theme: theme2 }) => theme2.colors.error.light};
  }
`;

// src/common-elements/mixins.ts
var deprecatedCss = css`
  text-decoration: line-through;
  color: #707070;
`;

// src/common-elements/fields-layout.ts
var PropertiesTableCaption = styled_components_default.caption`
  text-align: right;
  font-size: 0.9em;
  font-weight: normal;
  color: ${(props) => props.theme.colors.text.secondary};
`;
var PropertyCell = styled_components_default.td`
  border-left: 1px solid ${(props) => props.theme.schema.linesColor};
  box-sizing: border-box;
  position: relative;
  padding: 10px 10px 10px 0;

  ${media.lessThan("small")`
    display: block;
    overflow: hidden;
  `}

  tr:first-of-type > &,
  tr.last > & {
    border-left-width: 0;
    background-position: top left;
    background-repeat: no-repeat;
    background-size: 1px 100%;
  }

  tr:first-of-type > & {
    background-image: linear-gradient(
      to bottom,
      transparent 0%,
      transparent 22px,
      ${(props) => props.theme.schema.linesColor} 22px,
      ${(props) => props.theme.schema.linesColor} 100%
    );
  }

  tr.last > & {
    background-image: linear-gradient(
      to bottom,
      ${(props) => props.theme.schema.linesColor} 0%,
      ${(props) => props.theme.schema.linesColor} 22px,
      transparent 22px,
      transparent 100%
    );
  }

  tr.last + tr > & {
    border-left-color: transparent;
  }

  tr.last:first-child > & {
    background: none;
    border-left-color: transparent;
  }
`;
var PropertyCellWithInner = styled_components_default(PropertyCell)`
  padding: 0;
`;
var PropertyNameCell = styled_components_default(PropertyCell)`
  vertical-align: top;
  line-height: 20px;
  white-space: nowrap;
  font-size: 13px;
  font-family: ${(props) => props.theme.typography.code.fontFamily};

  &.deprecated {
    ${deprecatedCss};
  }

  ${({ kind }) => kind === "patternProperties" && css`
      > span.property-name {
        display: inline-table;
        white-space: break-spaces;
        margin-right: 20px;

        ::before,
        ::after {
          content: '/';
          filter: opacity(0.2);
        }
      }
    `}

  ${({ kind = "" }) => ["field", "additionalProperties", "patternProperties"].includes(kind) ? "" : "font-style: italic"};

  ${extensionsHook("PropertyNameCell")};
`;
var PropertyDetailsCell = styled_components_default.td`
  border-bottom: 1px solid #9fb4be;
  padding: 10px 0;
  width: ${(props) => props.theme.schema.defaultDetailsWidth};
  box-sizing: border-box;

  tr.expanded & {
    border-bottom: none;
  }

  ${media.lessThan("small")`
    padding: 0 20px;
    border-bottom: none;
    border-left: 1px solid ${(props) => props.theme.schema.linesColor};

    tr.last > & {
      border-left: none;
    }
  `}

  ${extensionsHook("PropertyDetailsCell")};
`;
var PropertyBullet = styled_components_default.span`
  color: ${(props) => props.theme.schema.linesColor};
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  margin-right: 10px;

  &::before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 10px;
    height: 1px;
    background: ${(props) => props.theme.schema.linesColor};
  }

  &::after {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 1px;
    background: ${(props) => props.theme.schema.linesColor};
    height: 7px;
  }
`;
var InnerPropertiesWrap = styled_components_default.div`
  padding: ${({ theme: theme2 }) => theme2.schema.nestingSpacing};
`;
var PropertiesTable = styled_components_default.table`
  border-collapse: separate;
  border-radius: 3px;
  font-size: ${(props) => props.theme.typography.fontSize};

  border-spacing: 0;
  width: 100%;

  > tr {
    vertical-align: middle;
  }

  ${media.lessThan("small")`
    display: block;
    > tr, > tbody > tr {
      display: block;
    }
  `}

  ${media.lessThan("small", false, " and (-ms-high-contrast:none)")`
    td {
      float: left;
      width: 100%;
    }
  `}

  &
    ${InnerPropertiesWrap},
    &
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap},
    &
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap} {
    margin: ${({ theme: theme2 }) => theme2.schema.nestingSpacing};
    margin-right: 0;
    background: ${({ theme: theme2 }) => theme2.schema.nestedBackground};
  }

  &
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap},
    &
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap},
    &
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap}
    ${InnerPropertiesWrap} {
    background: #ffffff;
  }
`;

// src/common-elements/schema.ts
var import_polished2 = __toESM(require_polished_cjs(), 1);
var OneOfList = styled_components_default.div`
  margin: 0 0 3px 0;
  display: inline-block;
`;
var OneOfLabel = styled_components_default.span`
  font-size: 0.9em;
  margin-right: 10px;
  color: ${(props) => props.theme.colors.primary.main};
  font-family: ${(props) => props.theme.typography.headings.fontFamily};
}
`;
var OneOfButton = styled_components_default.button`
  display: inline-block;
  margin-right: 10px;
  margin-bottom: 5px;
  font-size: 0.8em;
  cursor: pointer;
  border: 1px solid ${(props) => props.theme.colors.primary.main};
  padding: 2px 10px;
  line-height: 1.5em;
  outline: none;
  &:focus {
    box-shadow: 0 0 0 1px ${(props) => props.theme.colors.primary.main};
  }

  ${({ $deprecated }) => $deprecated && deprecatedCss || ""};

  ${(props) => {
  if (props.$active) {
    return `
      color: white;
      background-color: ${props.theme.colors.primary.main};
      &:focus {
        box-shadow: none;
        background-color: ${(0, import_polished2.darken)(0.15, props.theme.colors.primary.main)};
      }
      `;
  } else {
    return `
        color: ${props.theme.colors.primary.main};
        background-color: white;
      `;
  }
}}
`;
var ArrayOpenningLabel = styled_components_default.div`
  font-size: 0.9em;
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  &::after {
    content: ' [';
  }
`;
var ArrayClosingLabel = styled_components_default.div`
  font-size: 0.9em;
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  &::after {
    content: ']';
  }
`;

// src/common-elements/tabs.ts
import { Tabs as ReactTabs } from "react-tabs";
import { Tab, TabList, TabPanel } from "react-tabs";
var Tabs = styled_components_default(ReactTabs)`
  > ul {
    display: flex;
    list-style: none;
    padding: 0;
    margin: 0 0 10px;
    border-bottom: 4px solid rgb(97, 110, 124);

    > li {
      flex: 1;
      cursor: pointer;
      padding: 5px 10px;
      font-size: 14px;
      line-height: 26px;
      font-weight: 400;
      text-align: center;
      color: rgb(245, 247, 250);
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;

      &:first-child {
        border-top-left-radius: 4px;
      }

      &:last-child {
        border-top-right-radius: 4px;
      }

      &.react-tabs__tab--selected {
        background: rgb(50, 63, 75);
        border-bottom: 4px solid ${(props) => props.theme.colors.primary.light};
        margin-bottom: -4px;

        &:focus {
          outline: none;
        }
      }

      &:only-child {
        flex: none;
        min-width: 100px;
      }
    }
  }
`;

// src/common-elements/PrismDiv.tsx
var PrismDiv = styled_components_default.div`
  /**
  * Based on prism-dark.css
  */

  code[class*='language-'],
  pre[class*='language-'] {
    /* color: white;
    background: none; */
    text-shadow: 0 -0.1em 0.2em black;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  @media print {
    code[class*='language-'],
    pre[class*='language-'] {
      text-shadow: none;
    }
  }

  /* Code blocks */
  pre[class*='language-'] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }

  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: hsl(30, 20%, 50%);
  }

  .token.punctuation {
    opacity: 1;
  }

  .namespace {
    opacity: 0.7;
  }

  .token.property,
  .token.tag,
  .token.number,
  .token.constant,
  .token.symbol {
    color: rgb(245, 247, 250);
  }

  .token.boolean {
    color: #e64441;
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: rgb(254, 227, 158);
    & + a,
    & + a:visited {
      color: #4ed2ba;
      text-decoration: underline;
    }
  }

  .token.property.string {
    color: rgb(158, 250, 167);
  }

  .token.operator,
  .token.entity,
  .token.url,
  .token.variable {
    color: hsl(40, 90%, 60%);
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: hsl(350, 40%, 70%);
  }

  .token.regex,
  .token.important {
    color: #e90;
  }

  .token.important,
  .token.bold {
    font-weight: bold;
  }
  .token.italic {
    font-style: italic;
  }

  .token.entity {
    cursor: help;
  }

  .token.deleted {
    color: red;
  }

  ${extensionsHook("Prism")};
`;

// src/common-elements/samples.tsx
var SampleControls = styled_components_default.div`
  opacity: 0.7;
  transition: opacity 0.3s ease;
  text-align: right;
  &:focus-within {
    opacity: 1;
  }
  > button {
    background-color: transparent;
    border: 0;
    color: inherit;
    padding: 2px 10px;
    font-family: ${({ theme: theme2 }) => theme2.typography.fontFamily};
    font-size: ${({ theme: theme2 }) => theme2.typography.fontSize};
    line-height: ${({ theme: theme2 }) => theme2.typography.lineHeight};
    cursor: pointer;
    outline: 0;

    :hover,
    :focus {
      background: rgba(255, 255, 255, 0.1);
    }
  }
`;
var SampleControlsWrap = styled_components_default.div`
  &:hover ${SampleControls} {
    opacity: 1;
  }
`;
var StyledPre = styled_components_default(PrismDiv).attrs({
  as: "pre"
})`
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  font-size: ${(props) => props.theme.typography.code.fontSize};
  overflow-x: auto;
  margin: 0;
  padding: 20px;
  border-radius: 4px;
  color: rgb(245, 247, 250);
  background-color: rgb(50, 63, 75);

  white-space: ${({ theme: theme2 }) => theme2.typography.code.wrap ? "pre-wrap" : "pre"};
`;

// src/common-elements/perfect-scrollbar.tsx
var import_perfect_scrollbar = __toESM(require_perfect_scrollbar_common(), 1);
import React6 from "react";

// node_modules/perfect-scrollbar/css/perfect-scrollbar.css
var perfect_scrollbar_default = "/*\n * Container style\n */\n.ps {\n  overflow: hidden !important;\n  overflow-anchor: none;\n  -ms-overflow-style: none;\n  touch-action: auto;\n  -ms-touch-action: auto;\n}\n\n/*\n * Scrollbar rail styles\n */\n.ps__rail-x {\n  display: none;\n  opacity: 0;\n  transition: background-color .2s linear, opacity .2s linear;\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\n  height: 15px;\n  /* there must be 'bottom' or 'top' for ps__rail-x */\n  bottom: 0px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__rail-y {\n  display: none;\n  opacity: 0;\n  transition: background-color .2s linear, opacity .2s linear;\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\n  width: 15px;\n  /* there must be 'right' or 'left' for ps__rail-y */\n  right: 0;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps--active-x > .ps__rail-x,\n.ps--active-y > .ps__rail-y {\n  display: block;\n  background-color: transparent;\n}\n\n.ps:hover > .ps__rail-x,\n.ps:hover > .ps__rail-y,\n.ps--focus > .ps__rail-x,\n.ps--focus > .ps__rail-y,\n.ps--scrolling-x > .ps__rail-x,\n.ps--scrolling-y > .ps__rail-y {\n  opacity: 0.6;\n}\n\n.ps .ps__rail-x:hover,\n.ps .ps__rail-y:hover,\n.ps .ps__rail-x:focus,\n.ps .ps__rail-y:focus,\n.ps .ps__rail-x.ps--clicking,\n.ps .ps__rail-y.ps--clicking {\n  background-color: #eee;\n  opacity: 0.9;\n}\n\n/*\n * Scrollbar thumb styles\n */\n.ps__thumb-x {\n  background-color: #aaa;\n  border-radius: 6px;\n  transition: background-color .2s linear, height .2s ease-in-out;\n  -webkit-transition: background-color .2s linear, height .2s ease-in-out;\n  height: 6px;\n  /* there must be 'bottom' for ps__thumb-x */\n  bottom: 2px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__thumb-y {\n  background-color: #aaa;\n  border-radius: 6px;\n  transition: background-color .2s linear, width .2s ease-in-out;\n  -webkit-transition: background-color .2s linear, width .2s ease-in-out;\n  width: 6px;\n  /* there must be 'right' for ps__thumb-y */\n  right: 2px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__rail-x:hover > .ps__thumb-x,\n.ps__rail-x:focus > .ps__thumb-x,\n.ps__rail-x.ps--clicking .ps__thumb-x {\n  background-color: #999;\n  height: 11px;\n}\n\n.ps__rail-y:hover > .ps__thumb-y,\n.ps__rail-y:focus > .ps__thumb-y,\n.ps__rail-y.ps--clicking .ps__thumb-y {\n  background-color: #999;\n  width: 11px;\n}\n\n/* MS supports */\n@supports (-ms-overflow-style: none) {\n  .ps {\n    overflow: auto !important;\n  }\n}\n\n@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {\n  .ps {\n    overflow: auto !important;\n  }\n}\n";

// src/common-elements/perfect-scrollbar.tsx
import { Fragment, jsx as jsx6, jsxs as jsxs4 } from "react/jsx-runtime";
var psStyles = IS_BROWSER ? perfect_scrollbar_default : "";
var PSStyling = createGlobalStyle`${psStyles}`;
var StyledScrollWrapper = styled_components_default.div`
  position: relative;
`;
var PerfectScrollbar = class extends React6.Component {
  constructor() {
    super(...arguments);
    this.handleRef = (ref) => {
      this._container = ref;
    };
  }
  componentDidMount() {
    const offset = this._container.parentElement && this._container.parentElement.scrollTop || 0;
    this.inst = new import_perfect_scrollbar.default(this._container, this.props.options || {});
    if (this._container.scrollTo) {
      this._container.scrollTo(0, offset);
    }
  }
  componentDidUpdate() {
    this.inst.update();
  }
  componentWillUnmount() {
    this.inst.destroy();
  }
  render() {
    const { children, className, updateFn } = this.props;
    if (updateFn) {
      updateFn(this.componentDidUpdate.bind(this));
    }
    return /* @__PURE__ */ jsxs4(Fragment, { children: [
      psStyles && /* @__PURE__ */ jsx6(PSStyling, {}),
      /* @__PURE__ */ jsx6(StyledScrollWrapper, { className: `scrollbar-container ${className}`, ref: this.handleRef, children })
    ] });
  }
};
function PerfectScrollbarWrap(props) {
  return /* @__PURE__ */ jsx6(OptionsContext.Consumer, { children: (options2) => !options2.nativeScrollbars ? /* @__PURE__ */ jsx6(PerfectScrollbar, { ...props, children: props.children }) : /* @__PURE__ */ jsx6(
    "div",
    {
      style: {
        overflow: "auto",
        overscrollBehavior: "contain",
        msOverflowStyle: "-ms-autohiding-scrollbar"
      },
      children: props.children
    }
  ) });
}

// src/common-elements/Dropdown/Dropdown.tsx
import React7 from "react";
import { jsx as jsx7, jsxs as jsxs5 } from "react/jsx-runtime";
var ArrowSvg = ({ className, style }) => /* @__PURE__ */ jsx7(
  "svg",
  {
    className,
    style,
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: /* @__PURE__ */ jsx7("polyline", { points: "6 9 12 15 18 9" })
  }
);
var ArrowIcon = styled_components_default(ArrowSvg)`
  position: absolute;
  pointer-events: none;
  z-index: 1;
  top: 50%;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  right: 8px;
  margin: auto;
  text-align: center;
  polyline {
    color: ${(props) => props.variant === "dark" && "white"};
  }
`;
var DropdownComponent = (props) => {
  const { options: options2, onChange, placeholder: placeholder2, value = "", variant, className } = props;
  const handleOnChange = (event) => {
    const { selectedIndex } = event.target;
    const index2 = placeholder2 ? selectedIndex - 1 : selectedIndex;
    onChange(options2[index2]);
  };
  return /* @__PURE__ */ jsxs5("div", { className, children: [
    /* @__PURE__ */ jsx7(ArrowIcon, { variant }),
    /* @__PURE__ */ jsxs5("select", { onChange: handleOnChange, value, className: "dropdown-select", children: [
      placeholder2 && /* @__PURE__ */ jsx7("option", { disabled: true, hidden: true, value: placeholder2, children: placeholder2 }),
      options2.map(({ idx, value: value2, title }, index2) => /* @__PURE__ */ jsx7("option", { value: value2, children: title || value2 }, idx || value2 + index2))
    ] }),
    /* @__PURE__ */ jsx7("label", { children: value })
  ] });
};
var Dropdown = React7.memo(DropdownComponent);

// src/common-elements/Dropdown/styled.ts
var Dropdown2 = styled_components_default(Dropdown)`
  label {
    box-sizing: border-box;
    min-width: 100px;
    outline: none;
    display: inline-block;
    font-family: ${(props) => props.theme.typography.headings.fontFamily};
    color: ${({ theme: theme2 }) => theme2.colors.text.primary};
    vertical-align: bottom;
    width: ${({ fullWidth }) => fullWidth ? "100%" : "auto"};
    text-transform: none;
    padding: 0 22px 0 4px;

    font-size: 0.929em;
    line-height: 1.5em;
    font-family: inherit;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }
  .dropdown-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    border: none;
    appearance: none;
    cursor: pointer;

    color: ${({ theme: theme2 }) => theme2.colors.text.primary};
    line-height: inherit;
    font-family: inherit;
  }
  box-sizing: border-box;
  min-width: 100px;
  outline: none;
  display: inline-block;
  border-radius: 2px;
  border: 1px solid rgba(38, 50, 56, 0.5);
  vertical-align: bottom;
  padding: 2px 0px 2px 6px;
  position: relative;
  width: auto;
  background: white;
  color: #263238;
  font-family: ${(props) => props.theme.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
  cursor: pointer;
  transition: border 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;

  &:hover,
  &:focus-within {
    border: 1px solid ${(props) => props.theme.colors.primary.main};
    color: ${(props) => props.theme.colors.primary.main};
    box-shadow: 0px 0px 0px 1px ${(props) => props.theme.colors.primary.main};
  }
`;
var SimpleDropdown = styled_components_default(Dropdown2)`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.969em;

  font-size: 1em;
  border: none;
  padding: 0 1.2em 0 0;
  background: transparent;

  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    label {
      color: ${(props) => props.theme.colors.primary.main};
      text-shadow: 0px 0px 0px ${(props) => props.theme.colors.primary.main};
    }
  }
`;
var MimeLabel = styled_components_default.span`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.929em;
  color: black;
`;

// src/common-elements/Input/Input.tsx
import React8 from "react";

// src/common-elements/Input/styled.elements.ts
var Label = styled_components_default.label`
  padding-bottom: 6px;
  display: block;
  white-space: nowrap;
  line-height: 1em;

  ${({ required: required3 }) => required3 && css`
      &:after {
        display: inline-block;
        content: '*';
        margin-left: 4px;
        color: ${(props) => props.theme.colors.error.main};
      }
    `}
`;
var Root = styled_components_default.div`
  width: 100%;
  font-family: ${(props) => props.theme.typography.fontFamily};
  display: flex;
  flex-direction: column;
  margin-bottom: 10px;
`;
var InputContainer = styled_components_default.div`
  display: inline-block;
  width: 100%;
`;
var InputWrapper = styled_components_default.div`
  position: relative;
`;
var StyledInput = styled_components_default.input`
  border: medium none;
  outline: none;
  padding: ${({ password }) => password ? "8px 40px 8px 8px" : "8px"};
  border-radius: 4px;
  background-color: rgb(50, 63, 75);
  color: rgb(245, 247, 250);
  font-size: 14px;
  width: 100%;
`;
var Error2 = styled_components_default.div`
  color: ${(props) => props.theme.colors.error.main};
  font-size: 0.9em;
`;
var ShowButton = styled_components_default.span`
  position: absolute;
  right: 0;
  line-height: normal;
  font-size: 0.8em;
  padding: 10px;
  cursor: pointer;
  text-align: center;
  color: rgb(238, 238, 238);
`;

// src/common-elements/Input/Input.tsx
import { useCallback, useEffect, useState } from "react";
import { jsx as jsx8, jsxs as jsxs6 } from "react/jsx-runtime";
var InputComponent = (props) => {
  const { label, input, meta: meta2, inputType, placeholder: placeholder2, required: required3 } = props;
  const { error, submitError, touched } = meta2;
  const [type, setType] = useState(inputType);
  const togglePasswordVisible = useCallback(() => {
    setType((old) => old === "password" ? "text" : "password");
  }, []);
  useEffect(() => {
    setType(inputType);
  }, [inputType]);
  return /* @__PURE__ */ jsxs6(Root, { children: [
    label && /* @__PURE__ */ jsxs6(Label, { required: required3, children: [
      label,
      ":"
    ] }),
    /* @__PURE__ */ jsxs6(InputContainer, { children: [
      /* @__PURE__ */ jsxs6(InputWrapper, { children: [
        /* @__PURE__ */ jsx8(
          StyledInput,
          {
            type,
            placeholder: placeholder2,
            id: input.name,
            required: required3,
            password: inputType === "password",
            ...input
          }
        ),
        inputType === "password" && /* @__PURE__ */ jsx8(ShowButton, { onClick: togglePasswordVisible, children: type === "password" ? "show" : "hide" })
      ] }),
      touched && error || submitError ? /* @__PURE__ */ jsx8(Error2, { children: error || submitError }) : null
    ] })
  ] });
};
var Input = React8.memo(InputComponent);

// src/components/DropdownOrLabel/DropdownOrLabel.tsx
import { jsx as jsx9 } from "react/jsx-runtime";
function DropdownOrLabel(props) {
  const { Label: Label3 = MimeLabel, Dropdown: Dropdown3 = SimpleDropdown } = props;
  if (props.options.length === 1) {
    return /* @__PURE__ */ jsx9(Label3, { children: props.options[0].value });
  }
  return /* @__PURE__ */ jsx9(Dropdown3, { ...props });
}

// src/components/PayloadSamples/MediaTypeSamples.tsx
import React13 from "react";

// src/components/Markdown/Markdown.tsx
import React9 from "react";

// node_modules/dompurify/dist/purify.es.mjs
var {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
var {
  freeze,
  seal,
  create
} = Object;
var {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var arraySplice = unapply(Array.prototype.splice);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l2 = array.length;
  while (l2--) {
    let element = array[l2];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function cleanArray(array) {
  for (let index2 = 0; index2 < array.length; index2++) {
    const isPropertyExist = objectHasOwnProperty(array, index2);
    if (!isPropertyExist) {
      array[index2] = null;
    }
  }
  return array;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
var NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
};
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
var _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.2.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element2,
    NodeFilter: NodeFilter2,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove2 = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove2(node);
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name2),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name2);
    if (name2 === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {
        }
      } else {
        try {
          element.setAttribute(name2, "");
        } catch (_) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc2 = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc2 = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc2 || !doc2.documentElement) {
      doc2 = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc2.body || doc2.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc2.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT | NodeFilter2.SHOW_PROCESSING_INSTRUCTION | NodeFilter2.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node2 === "function" && value instanceof Node2;
  };
  function _executeHooks(hooks2, currentNode, data) {
    arrayForEach(hooks2, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content2 = null;
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content2 = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content2 = stringReplace(content2, expr, " ");
      });
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content2;
      }
    }
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l2 = attributes.length;
    while (l2--) {
      const attr = attributes[l2];
      const {
        name: name2,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name2);
      let value = name2 === "value" ? attrValue : stringTrim(attrValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {
      }
    }
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint, hookFunction) {
    if (hookFunction !== void 0) {
      const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

// src/components/Markdown/styled.elements.tsx
var linksCss = css`
  a {
    text-decoration: ${(props) => props.theme.typography.links.textDecoration};
    color: ${(props) => props.theme.typography.links.color};

    &:visited {
      color: ${(props) => props.theme.typography.links.visited};
    }

    &:hover {
      color: ${(props) => props.theme.typography.links.hover};
      text-decoration: ${(props) => props.theme.typography.links.hoverTextDecoration};
    }
  }
`;
var StyledMarkdownBlock = styled_components_default(PrismDiv)`
  font-family: ${(props) => props.theme.typography.fontFamily};
  font-weight: ${(props) => props.theme.typography.fontWeightRegular};
  line-height: ${(props) => props.theme.typography.lineHeight};

  p {
    &:last-child {
      margin-bottom: 0;
    }
  }

  ${({ $compact }) => $compact && `
    p:first-child {
      margin-top: 0;
    }
    p:last-child {
      margin-bottom: 0;
    }
  `}

  ${({ $inline }) => $inline && ` p {
    display: inline-block;
  }`}

  h1 {
    ${headerCommonMixin(1)};
    color: ${(props) => props.theme.colors.primary.main};
    margin-top: 0;
  }

  h2 {
    ${headerCommonMixin(2)};
    color: ${(props) => props.theme.colors.text.primary};
  }

  code {
    color: ${({ theme: theme2 }) => theme2.typography.code.color};
    background-color: ${({ theme: theme2 }) => theme2.typography.code.backgroundColor};

    font-family: ${(props) => props.theme.typography.code.fontFamily};
    border-radius: 2px;
    border: 1px solid rgba(38, 50, 56, 0.1);
    padding: 0 ${({ theme: theme2 }) => theme2.spacing.unit}px;
    font-size: ${(props) => props.theme.typography.code.fontSize};
    font-weight: ${({ theme: theme2 }) => theme2.typography.code.fontWeight};

    word-break: break-word;
  }

  pre {
    font-family: ${(props) => props.theme.typography.code.fontFamily};
    white-space: ${({ theme: theme2 }) => theme2.typography.code.wrap ? "pre-wrap" : "pre"};
    background-color: ${({ theme: theme2 }) => theme2.codeBlock.backgroundColor};
    color: white;
    padding: ${(props) => props.theme.spacing.unit * 4}px;
    overflow-x: auto;
    line-height: normal;
    border-radius: 0;
    border: 1px solid rgba(38, 50, 56, 0.1);

    code {
      background-color: transparent;
      color: white;
      padding: 0;

      &:before,
      &:after {
        content: none;
      }
    }
  }

  blockquote {
    margin: 0;
    margin-bottom: 1em;
    padding: 0 15px;
    color: #777;
    border-left: 4px solid #ddd;
  }

  img {
    max-width: 100%;
    box-sizing: content-box;
  }

  ul,
  ol {
    padding-left: 2em;
    margin: 0;
    margin-bottom: 1em;

    ul,
    ol {
      margin-bottom: 0;
      margin-top: 0;
    }
  }

  table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
    border-collapse: collapse;
    border-spacing: 0;
    margin-top: 1.5em;
    margin-bottom: 1.5em;
  }

  table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;

    &:nth-child(2n) {
      background-color: ${({ theme: theme2 }) => theme2.schema.nestedBackground};
    }
  }

  table th,
  table td {
    padding: 6px 13px;
    border: 1px solid #ddd;
  }

  table th {
    text-align: left;
    font-weight: bold;
  }

  ${linkifyMixin(".share-link")};

  ${linksCss}

  ${extensionsHook("Markdown")};
`;

// src/components/Markdown/SanitizedMdBlock.tsx
import { jsx as jsx10 } from "react/jsx-runtime";
var StyledMarkdownSpan = styled_components_default(StyledMarkdownBlock)`
  display: inline;
`;
var sanitize = (sanitize2, html2) => sanitize2 ? purify.sanitize(html2) : html2;
function SanitizedMarkdownHTML({
  inline: inline2,
  compact,
  ...rest
}) {
  const Wrap2 = inline2 ? StyledMarkdownSpan : StyledMarkdownBlock;
  return /* @__PURE__ */ jsx10(OptionsConsumer, { children: (options2) => /* @__PURE__ */ jsx10(
    Wrap2,
    {
      className: "redoc-markdown " + (rest.className || ""),
      dangerouslySetInnerHTML: {
        __html: sanitize(options2.sanitize, rest.html)
      },
      "data-role": rest["data-role"],
      ...rest,
      $inline: inline2,
      $compact: compact
    }
  ) });
}

// src/components/Markdown/Markdown.tsx
import { jsx as jsx11 } from "react/jsx-runtime";
var Markdown = class extends React9.Component {
  render() {
    const { source, inline: inline2, compact, className, "data-role": dataRole } = this.props;
    const renderer2 = new MarkdownRenderer();
    return /* @__PURE__ */ jsx11(
      SanitizedMarkdownHTML,
      {
        html: renderer2.renderMd(source),
        inline: inline2,
        compact,
        className,
        "data-role": dataRole
      }
    );
  }
};

// src/components/JsonViewer/JsonViewer.tsx
import React12 from "react";

// src/common-elements/CopyButtonWrapper.tsx
import React11 from "react";

// src/common-elements/Tooltip.tsx
import React10 from "react";
import { jsx as jsx12, jsxs as jsxs7 } from "react/jsx-runtime";
var Wrapper = styled_components_default.div`
  position: relative;
`;
var Tip = styled_components_default.div`
  position: absolute;
  min-width: 80px;
  max-width: 500px;
  background: #fff;
  bottom: 100%;
  left: 50%;
  margin-bottom: 10px;
  transform: translateX(-50%);

  border-radius: 4px;
  padding: 0.3em 0.6em;
  text-align: center;
  box-shadow: 0px 0px 5px 0px rgba(204, 204, 204, 1);
`;
var Content = styled_components_default.div`
  background: #fff;
  color: #000;
  display: inline;
  font-size: 0.85em;
  white-space: nowrap;
`;
var Arrow = styled_components_default.div`
  position: absolute;
  width: 0;
  height: 0;
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
  border-left: solid transparent 5px;
  border-right: solid transparent 5px;
  border-top: solid #fff 5px;
`;
var Gap = styled_components_default.div`
  position: absolute;
  width: 100%;
  height: 20px;
  bottom: -20px;
`;
var Tooltip = class extends React10.Component {
  render() {
    const { open, title, children } = this.props;
    return /* @__PURE__ */ jsxs7(Wrapper, { children: [
      children,
      open && /* @__PURE__ */ jsxs7(Tip, { children: [
        /* @__PURE__ */ jsx12(Content, { children: title }),
        /* @__PURE__ */ jsx12(Arrow, {}),
        /* @__PURE__ */ jsx12(Gap, {})
      ] })
    ] });
  }
};

// src/services/ClipboardService.ts
var isSupported = typeof document !== "undefined" && document.queryCommandSupported && document.queryCommandSupported("copy");
var ClipboardService = class _ClipboardService {
  static isSupported() {
    return isSupported;
  }
  static selectElement(element) {
    let range;
    let selection2;
    if (document.body.createTextRange) {
      range = document.body.createTextRange();
      range.moveToElementText(element);
      range.select();
    } else if (document.createRange && window.getSelection) {
      selection2 = window.getSelection();
      range = document.createRange();
      range.selectNodeContents(element);
      selection2.removeAllRanges();
      selection2.addRange(range);
    }
  }
  static deselect() {
    if (document.selection) {
      document.selection.empty();
    } else if (window.getSelection) {
      const selection2 = window.getSelection();
      if (selection2) {
        selection2.removeAllRanges();
      }
    }
  }
  static copySelected() {
    let result;
    try {
      result = document.execCommand("copy");
    } catch (err) {
      result = false;
    }
    return result;
  }
  static copyElement(element) {
    _ClipboardService.selectElement(element);
    const res = _ClipboardService.copySelected();
    if (res) {
      _ClipboardService.deselect();
    }
    return res;
  }
  static copyCustom(text2) {
    const textArea = document.createElement("textarea");
    textArea.style.position = "fixed";
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.width = "2em";
    textArea.style.height = "2em";
    textArea.style.padding = "0";
    textArea.style.border = "none";
    textArea.style.outline = "none";
    textArea.style.boxShadow = "none";
    textArea.style.background = "transparent";
    textArea.value = text2;
    document.body.appendChild(textArea);
    textArea.select();
    const res = _ClipboardService.copySelected();
    document.body.removeChild(textArea);
    return res;
  }
};

// src/common-elements/CopyButtonWrapper.tsx
import { jsx as jsx13 } from "react/jsx-runtime";
var CopyButtonWrapper = (props) => {
  const [tooltipShown, setTooltipShown] = React11.useState(false);
  const copy = () => {
    const content2 = typeof props.data === "string" ? props.data : JSON.stringify(props.data, null, 2);
    ClipboardService.copyCustom(content2);
    showTooltip2();
  };
  const renderCopyButton = () => {
    return /* @__PURE__ */ jsx13("button", { onClick: copy, children: /* @__PURE__ */ jsx13(
      Tooltip,
      {
        title: ClipboardService.isSupported() ? "Copied" : "Not supported in your browser",
        open: tooltipShown,
        children: "Copy"
      }
    ) });
  };
  const showTooltip2 = () => {
    setTooltipShown(true);
    setTimeout(() => {
      setTooltipShown(false);
    }, 1500);
  };
  return props.children({ renderCopyButton });
};

// src/utils/jsonToHtml.ts
var level = 1;
function jsonToHTML(json2, maxExpandLevel) {
  level = 1;
  let output = "";
  output += '<div class="redoc-json">';
  output += "<code>";
  output += valueToHTML(json2, maxExpandLevel);
  output += "</code>";
  output += "</div>";
  return output;
}
function htmlEncode(t2) {
  return t2 !== void 0 ? t2.toString().replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : "";
}
function stringifyStringLiteral(str) {
  return JSON.stringify(str).slice(1, -1);
}
function decorateWithSpan(value, className) {
  return '<span class="' + className + '">' + htmlEncode(value) + "</span>";
}
function punctuation(val) {
  return '<span class="token punctuation">' + val + "</span>";
}
function valueToHTML(value, maxExpandLevel) {
  const valueType = typeof value;
  let output = "";
  if (value === void 0 || value === null) {
    output += decorateWithSpan("null", "token keyword");
  } else if (value && value.constructor === Array) {
    level++;
    output += arrayToHTML(value, maxExpandLevel);
    level--;
  } else if (value && value.constructor === Date) {
    output += decorateWithSpan('"' + value.toISOString() + '"', "token string");
  } else if (valueType === "object") {
    level++;
    output += objectToHTML(value, maxExpandLevel);
    level--;
  } else if (valueType === "number") {
    output += decorateWithSpan(value, "token number");
  } else if (valueType === "string") {
    if (/^(http|https):\/\/[^\s]+$/.test(value)) {
      output += decorateWithSpan('"', "token string") + '<a href="' + encodeURI(value) + '">' + htmlEncode(stringifyStringLiteral(value)) + "</a>" + decorateWithSpan('"', "token string");
    } else {
      output += decorateWithSpan('"' + stringifyStringLiteral(value) + '"', "token string");
    }
  } else if (valueType === "boolean") {
    output += decorateWithSpan(value, "token boolean");
  }
  return output;
}
function arrayToHTML(json2, maxExpandLevel) {
  const collapsed = level > maxExpandLevel ? "collapsed" : "";
  let output = `<button class="collapser" aria-label="${level > maxExpandLevel + 1 ? "expand" : "collapse"}"></button>${punctuation("[")}<span class="ellipsis"></span><ul class="array collapsible">`;
  let hasContents = false;
  const length = json2.length;
  for (let i = 0; i < length; i++) {
    hasContents = true;
    output += '<li><div class="hoverable ' + collapsed + '">';
    output += valueToHTML(json2[i], maxExpandLevel);
    if (i < length - 1) {
      output += ",";
    }
    output += "</div></li>";
  }
  output += `</ul>${punctuation("]")}`;
  if (!hasContents) {
    output = punctuation("[ ]");
  }
  return output;
}
function objectToHTML(json2, maxExpandLevel) {
  const collapsed = level > maxExpandLevel ? "collapsed" : "";
  const keys2 = Object.keys(json2);
  const length = keys2.length;
  let output = `<button class="collapser" aria-label="${level > maxExpandLevel + 1 ? "expand" : "collapse"}"></button>${punctuation("{")}<span class="ellipsis"></span><ul class="obj collapsible">`;
  let hasContents = false;
  for (let i = 0; i < length; i++) {
    const key2 = keys2[i];
    hasContents = true;
    output += '<li><div class="hoverable ' + collapsed + '">';
    output += '<span class="property token string">"' + htmlEncode(key2) + '"</span>: ';
    output += valueToHTML(json2[key2], maxExpandLevel);
    if (i < length - 1) {
      output += punctuation(",");
    }
    output += "</div></li>";
  }
  output += `</ul>${punctuation("}")}`;
  if (!hasContents) {
    output = punctuation("{ }");
  }
  return output;
}

// src/components/JsonViewer/style.ts
var jsonStyles = css`
  .redoc-json code > .collapser {
    display: none;
    pointer-events: none;
  }

  font-family: ${(props) => props.theme.typography.code.fontFamily};
  font-size: ${(props) => props.theme.typography.code.fontSize};

  white-space: ${({ theme: theme2 }) => theme2.typography.code.wrap ? "pre-wrap" : "pre"};
  contain: content;
  overflow-x: auto;
  padding: 10px;
  border-radius: 4px;
  background-color: rgb(50, 63, 75);
  color: rgb(245, 247, 250);

  .callback-function {
    color: gray;
  }

  .collapser:after {
    content: '-';
    cursor: pointer;
  }

  .collapsed > .collapser:after {
    content: '+';
    cursor: pointer;
  }

  .ellipsis:after {
    content: ' … ';
  }

  .collapsible {
    margin-left: 2em;
  }

  .hoverable {
    padding: 1px 2px;
    border-radius: 2px;
  }

  .hovered {
    background-color: rgba(235, 238, 249, 1);
  }

  .collapser {
    background-color: transparent;
    border: 0;
    color: #fff;
    font-family: ${(props) => props.theme.typography.code.fontFamily};
    font-size: ${(props) => props.theme.typography.code.fontSize};
    display: flex;
    align-items: center;
    justify-content: center;
    width: 15px;
    height: 15px;
    position: absolute;
    top: 4px;
    left: -1.5em;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    padding: 2px;
    &:focus {
      outline-color: #fff;
      outline-style: dotted;
      outline-width: 1px;
    }
  }

  ul {
    list-style-type: none;
    padding: 0px;
    margin: 0px 0px 0px 26px;
  }

  li {
    position: relative;
    display: block;
  }

  .hoverable {
    display: inline-block;
  }

  .selected {
    outline-style: solid;
    outline-width: 1px;
    outline-style: dotted;
  }

  .collapsed > .collapsible {
    display: none;
  }

  .ellipsis {
    display: none;
  }

  .collapsed > .ellipsis {
    display: inherit;
  }
`;

// src/components/JsonViewer/JsonViewer.tsx
import { Fragment as Fragment2, jsx as jsx14, jsxs as jsxs8 } from "react/jsx-runtime";
var JsonViewerWrap = styled_components_default.div`
  &:hover > ${SampleControls} {
    opacity: 1;
  }
`;
var Json = (props) => {
  const [node, setNode] = React12.useState();
  const renderInner = ({ renderCopyButton }) => {
    const showFoldingButtons = props.data && Object.values(props.data).some((value) => typeof value === "object" && value !== null);
    return /* @__PURE__ */ jsxs8(JsonViewerWrap, { children: [
      /* @__PURE__ */ jsxs8(SampleControls, { children: [
        renderCopyButton(),
        showFoldingButtons && /* @__PURE__ */ jsxs8(Fragment2, { children: [
          /* @__PURE__ */ jsx14("button", { onClick: expandAll, children: " Expand all " }),
          /* @__PURE__ */ jsx14("button", { onClick: collapseAll, children: " Collapse all " })
        ] })
      ] }),
      /* @__PURE__ */ jsx14(OptionsContext.Consumer, { children: (options2) => /* @__PURE__ */ jsx14(
        PrismDiv,
        {
          tabIndex: 0,
          className: props.className,
          ref: (node2) => setNode(node2),
          dangerouslySetInnerHTML: {
            __html: jsonToHTML(props.data, options2.jsonSamplesExpandLevel)
          }
        }
      ) })
    ] });
  };
  const expandAll = () => {
    const elements = node == null ? void 0 : node.getElementsByClassName("collapsible");
    for (const collapsed of Array.prototype.slice.call(elements)) {
      const parentNode = collapsed.parentNode;
      parentNode.classList.remove("collapsed");
      parentNode.querySelector(".collapser").setAttribute("aria-label", "collapse");
    }
  };
  const collapseAll = () => {
    const elements = node == null ? void 0 : node.getElementsByClassName("collapsible");
    const elementsArr = Array.prototype.slice.call(elements, 1);
    for (const expanded of elementsArr) {
      const parentNode = expanded.parentNode;
      parentNode.classList.add("collapsed");
      parentNode.querySelector(".collapser").setAttribute("aria-label", "expand");
    }
  };
  const collapseElement = (target) => {
    let collapsed;
    if (target.className === "collapser") {
      collapsed = target.parentElement.getElementsByClassName("collapsible")[0];
      if (collapsed.parentElement.classList.contains("collapsed")) {
        collapsed.parentElement.classList.remove("collapsed");
        target.setAttribute("aria-label", "collapse");
      } else {
        collapsed.parentElement.classList.add("collapsed");
        target.setAttribute("aria-label", "expand");
      }
    }
  };
  const clickListener = React12.useCallback((event) => {
    collapseElement(event.target);
  }, []);
  const focusListener = React12.useCallback((event) => {
    if (event.key === "Enter") {
      collapseElement(event.target);
    }
  }, []);
  React12.useEffect(() => {
    node == null ? void 0 : node.addEventListener("click", clickListener);
    node == null ? void 0 : node.addEventListener("focus", focusListener);
    return () => {
      node == null ? void 0 : node.removeEventListener("click", clickListener);
      node == null ? void 0 : node.removeEventListener("focus", focusListener);
    };
  }, [clickListener, focusListener, node]);
  return /* @__PURE__ */ jsx14(CopyButtonWrapper, { data: props.data, children: renderInner });
};
var JsonViewer = styled_components_default(Json)`
  ${jsonStyles};
`;

// src/components/SourceCode/SourceCode.tsx
import { jsx as jsx15, jsxs as jsxs9 } from "react/jsx-runtime";
var SourceCode = (props) => {
  const { source, lang } = props;
  return /* @__PURE__ */ jsx15(StyledPre, { dangerouslySetInnerHTML: { __html: highlight(source, lang) } });
};
var SourceCodeWithCopy = (props) => {
  const { source, lang } = props;
  return /* @__PURE__ */ jsx15(CopyButtonWrapper, { data: source, children: ({ renderCopyButton }) => /* @__PURE__ */ jsxs9(SampleControlsWrap, { children: [
    /* @__PURE__ */ jsx15(SampleControls, { children: renderCopyButton() }),
    /* @__PURE__ */ jsx15(SourceCode, { lang, source })
  ] }) });
};

// src/components/PayloadSamples/ExampleValue.tsx
import { jsx as jsx16 } from "react/jsx-runtime";
function ExampleValue({ value, mimeType }) {
  if (isJsonLike(mimeType)) {
    return /* @__PURE__ */ jsx16(JsonViewer, { data: value });
  } else {
    if (typeof value === "object") {
      value = JSON.stringify(value, null, 2);
    }
    return /* @__PURE__ */ jsx16(SourceCodeWithCopy, { lang: langFromMime(mimeType), source: value });
  }
}

// src/components/PayloadSamples/exernalExampleHook.ts
import { useEffect as useEffect2, useRef, useState as useState2 } from "react";
function useExternalExample(example, mimeType) {
  const [, setIsLoading] = useState2(true);
  const value = useRef(void 0);
  const prevRef = useRef(void 0);
  if (prevRef.current !== example) {
    value.current = void 0;
  }
  prevRef.current = example;
  useEffect2(() => {
    const load2 = async () => {
      setIsLoading(true);
      try {
        value.current = await example.getExternalValue(mimeType);
      } catch (e) {
        value.current = e;
      }
      setIsLoading(false);
    };
    load2();
  }, [example, mimeType]);
  return value.current;
}

// src/components/PayloadSamples/Example.tsx
import { jsx as jsx17, jsxs as jsxs10 } from "react/jsx-runtime";
function Example({ example, mimeType }) {
  if (example.value === void 0 && example.externalValueUrl) {
    return /* @__PURE__ */ jsx17(ExternalExample, { example, mimeType });
  } else {
    return /* @__PURE__ */ jsx17(ExampleValue, { value: example.value, mimeType });
  }
}
function ExternalExample({ example, mimeType }) {
  const value = useExternalExample(example, mimeType);
  if (value === void 0) {
    return /* @__PURE__ */ jsx17("span", { children: "Loading..." });
  }
  if (value instanceof Error) {
    return /* @__PURE__ */ jsxs10(StyledPre, { children: [
      "Error loading external example: ",
      /* @__PURE__ */ jsx17("br", {}),
      /* @__PURE__ */ jsx17(
        "a",
        {
          className: "token string",
          href: example.externalValueUrl,
          target: "_blank",
          rel: "noopener noreferrer",
          children: example.externalValueUrl
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsx17(ExampleValue, { value, mimeType });
}

// src/components/PayloadSamples/styled.elements.ts
var import_polished3 = __toESM(require_polished_cjs(), 1);
var MimeLabel2 = styled_components_default.div`
  background-color: rgb(50, 63, 75);
  color: rgb(245, 247, 250);
  margin: 0 0 10px 0;
  height: 30px;
  padding: 7px 10px;
  border-radius: 4px;
  display: block;
  font-family: ${({ theme: theme2 }) => theme2.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 16px;
`;
var DropdownLabel = styled_components_default.span`
  font-family: ${({ theme: theme2 }) => theme2.typography.headings.fontFamily};
  font-size: 12px;
  position: absolute;
  z-index: 1;
  top: -11px;
  left: 12px;
  font-weight: ${({ theme: theme2 }) => theme2.typography.fontWeightBold};
  color: ${({ theme: theme2 }) => (0, import_polished3.transparentize)(0.3, theme2.rightPanel.textColor)};
`;
var DropdownWrapper = styled_components_default.div`
  position: relative;
`;
var InvertedSimpleDropdown = styled_components_default(Dropdown2)`
  label {
    color: ${({ theme: theme2 }) => theme2.rightPanel.textColor};
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    font-size: 1em;
    text-transform: none;
    border: none;
  }
  margin: 0 0 10px 0;
  display: block;
  background-color: ${({ theme: theme2 }) => (0, import_polished3.transparentize)(0.6, theme2.rightPanel.backgroundColor)};
  border: none;
  padding: 0.9em 1.6em 0.9em 0.9em;
  box-shadow: none;
  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    background-color: ${({ theme: theme2 }) => (0, import_polished3.transparentize)(0.3, theme2.rightPanel.backgroundColor)};
  }
`;
var NoSampleLabel = styled_components_default.div`
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  font-size: 12px;
  color: #ee807f;
`;
var ArrayFieldContainer = styled_components_default.div`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  margin-bottom: 10px;
`;
var Label2 = styled_components_default.label`
  padding-bottom: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 1.5;
  display: block;
  white-space: nowrap;
`;
var DeleteButton = styled_components_default.span`
  cursor: pointer;
  margin-left: auto;
  color: rgb(123, 135, 148);
  background: transparent;
  border: medium none;
  position: relative;
`;
var ArrayItem = styled_components_default.div`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  margin-bottom: 10px;
`;

// src/components/PayloadSamples/MediaTypeSamples.tsx
import { jsx as jsx18, jsxs as jsxs11 } from "react/jsx-runtime";
var MediaTypeSamples = class extends React13.Component {
  constructor() {
    super(...arguments);
    this.state = {
      activeIdx: 0
    };
    this.switchMedia = ({ idx }) => {
      if (idx !== void 0) {
        this.setState({
          activeIdx: idx
        });
      }
    };
  }
  render() {
    const { activeIdx } = this.state;
    const examples = this.props.mediaType.examples || {};
    const mimeType = this.props.mediaType.name;
    const noSample = /* @__PURE__ */ jsx18(NoSampleLabel, { children: "No sample" });
    const examplesNames = Object.keys(examples);
    if (examplesNames.length === 0) {
      return noSample;
    }
    if (examplesNames.length > 1) {
      const options2 = examplesNames.map((name2, idx) => {
        return {
          value: examples[name2].summary || name2,
          idx
        };
      });
      const example = examples[examplesNames[activeIdx]];
      const description = example.description;
      return /* @__PURE__ */ jsxs11(SamplesWrapper, { children: [
        /* @__PURE__ */ jsxs11(DropdownWrapper, { children: [
          /* @__PURE__ */ jsx18(DropdownLabel, { children: "Example" }),
          this.props.renderDropdown({
            value: options2[activeIdx].value,
            options: options2,
            onChange: this.switchMedia,
            ariaLabel: "Example"
          })
        ] }),
        /* @__PURE__ */ jsxs11("div", { children: [
          description && /* @__PURE__ */ jsx18(Markdown, { source: description }),
          /* @__PURE__ */ jsx18(Example, { example, mimeType })
        ] })
      ] });
    } else {
      const example = examples[examplesNames[0]];
      return /* @__PURE__ */ jsxs11(SamplesWrapper, { children: [
        example.description && /* @__PURE__ */ jsx18(Markdown, { source: example.description }),
        /* @__PURE__ */ jsx18(Example, { example, mimeType })
      ] });
    }
  }
};
var SamplesWrapper = styled_components_default.div`
  margin-top: 15px;
`;

// src/components/Schema/Schema.tsx
import { observer as observer8 } from "mobx-react";
import React28 from "react";

// src/components/Fields/FieldDetails.tsx
import React22 from "react";
import { observer as observer2 } from "mobx-react";

// src/common-elements/fields.ts
var import_polished4 = __toESM(require_polished_cjs(), 1);
var ClickablePropertyNameCell = styled_components_default(PropertyNameCell)`
  &.deprecated {
    span.property-name {
      ${deprecatedCss}
    }
  }

  button {
    background-color: transparent;
    border: 0;
    outline: 0;
    font-size: 13px;
    font-family: ${(props) => props.theme.typography.code.fontFamily};
    cursor: pointer;
    padding: 0;
    color: ${(props) => props.theme.colors.text.primary};
    &:focus {
      font-weight: ${({ theme: theme2 }) => theme2.typography.fontWeightBold};
    }
    ${({ kind }) => kind === "patternProperties" && css`
        display: inline-flex;
        margin-right: 20px;

        > span.property-name {
          white-space: break-spaces;
          text-align: left;

          ::before,
          ::after {
            content: '/';
            filter: opacity(0.2);
          }
        }

        > svg {
          align-self: center;
        }
      `}
  }
  ${ShelfIcon} {
    height: ${({ theme: theme2 }) => theme2.schema.arrow.size};
    width: ${({ theme: theme2 }) => theme2.schema.arrow.size};
    polygon {
      fill: ${({ theme: theme2 }) => theme2.schema.arrow.color};
    }
  }
`;
var FieldLabel = styled_components_default.span`
  vertical-align: middle;
  font-size: ${({ theme: theme2 }) => theme2.typography.code.fontSize};
  line-height: 20px;
`;
var TypePrefix = styled_components_default(FieldLabel)`
  color: ${(props) => (0, import_polished4.transparentize)(0.1, props.theme.schema.typeNameColor)};
`;
var TypeName = styled_components_default(FieldLabel)`
  color: ${(props) => props.theme.schema.typeNameColor};
`;
var TypeTitle = styled_components_default(FieldLabel)`
  color: ${(props) => props.theme.schema.typeTitleColor};
  word-break: break-word;
`;
var TypeFormat = TypeName;
var RequiredLabel = styled_components_default(FieldLabel).attrs({
  as: "div"
})`
  color: ${(props) => props.theme.schema.requireLabelColor};
  font-size: ${(props) => props.theme.schema.labelsTextSize};
  font-weight: normal;
  margin-left: 20px;
  line-height: 1;
`;
var PropertyLabel = styled_components_default(RequiredLabel)`
  color: ${(props) => props.theme.colors.primary.light};
`;
var RecursiveLabel = styled_components_default(FieldLabel)`
  color: ${({ theme: theme2 }) => theme2.colors.warning.main};
  font-size: 13px;
`;
var PatternLabel = styled_components_default(FieldLabel)`
  color: #0e7c86;
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  font-size: 12px;
  &::before,
  &::after {
    content: ' ';
  }
`;
var ExampleValue2 = styled_components_default(FieldLabel)`
  border-radius: 2px;
  word-break: break-word;
  ${({ theme: theme2 }) => `
    background-color: ${(0, import_polished4.transparentize)(0.95, theme2.colors.text.primary)};
    color: ${(0, import_polished4.transparentize)(0.1, theme2.colors.text.primary)};

    padding: 0 ${theme2.spacing.unit}px;
    border: 1px solid ${(0, import_polished4.transparentize)(0.9, theme2.colors.text.primary)};
    font-family: ${theme2.typography.code.fontFamily};
}`};
  & + & {
    margin-left: 0;
  }
  ${extensionsHook("ExampleValue")};
`;
var ExtensionValue = styled_components_default(ExampleValue2)``;
var ConstraintItem = styled_components_default(FieldLabel)`
  border-radius: 2px;
  ${({ theme: theme2 }) => `
    background-color: ${(0, import_polished4.transparentize)(0.95, theme2.colors.primary.light)};
    color: ${(0, import_polished4.transparentize)(0.1, theme2.colors.primary.main)};

    margin: 0 ${theme2.spacing.unit}px;
    padding: 0 ${theme2.spacing.unit}px;
    border: 1px solid ${(0, import_polished4.transparentize)(0.9, theme2.colors.primary.main)};
}`};
  & + & {
    margin-left: 0;
  }
  ${extensionsHook("ConstraintItem")};
`;
var ToggleButton = styled_components_default.button`
  background-color: transparent;
  border: 0;
  color: ${({ theme: theme2 }) => theme2.colors.text.secondary};
  margin-left: ${({ theme: theme2 }) => theme2.spacing.unit}px;
  border-radius: 2px;
  cursor: pointer;
  outline-color: ${({ theme: theme2 }) => theme2.colors.text.secondary};
  font-size: 12px;
`;

// src/components/ExternalDocumentation/ExternalDocumentation.tsx
import { observer } from "mobx-react";
import React14 from "react";
import { jsx as jsx19 } from "react/jsx-runtime";
var LinkWrap = styled_components_default.div`
  ${linksCss};
  ${({ $compact }) => !$compact ? "margin: 1em 0" : ""}
`;
var ExternalDocumentation = class extends React14.Component {
  render() {
    const { externalDocs } = this.props;
    if (!externalDocs || !externalDocs.url) {
      return null;
    }
    return /* @__PURE__ */ jsx19(LinkWrap, { $compact: this.props.compact, children: /* @__PURE__ */ jsx19("a", { href: externalDocs.url, children: externalDocs.description || externalDocs.url }) });
  }
};
ExternalDocumentation = __decorateClass([
  observer
], ExternalDocumentation);

// src/components/Fields/EnumValues.tsx
import React15 from "react";
import { Fragment as Fragment3, jsx as jsx20, jsxs as jsxs12 } from "react/jsx-runtime";
var DescriptionEnumsBlock = styled_components_default(StyledMarkdownBlock)`
  table {
    margin-bottom: 0.2em;
  }
`;
var EnumValues = class extends React15.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      collapsed: true
    };
    this.toggle = this.toggle.bind(this);
  }
  toggle() {
    this.setState({ collapsed: !this.state.collapsed });
  }
  render() {
    const { values, type } = this.props;
    const { collapsed } = this.state;
    const isDescriptionEnum = !Array.isArray(values);
    const enums = Array.isArray(values) && values || Object.entries(values || {}).map(([value, description]) => ({
      value,
      description
    }));
    const { enumSkipQuotes, maxDisplayedEnumValues } = this.context;
    if (!enums.length) {
      return null;
    }
    const displayedItems = this.state.collapsed && maxDisplayedEnumValues ? enums.slice(0, maxDisplayedEnumValues) : enums;
    const showToggleButton = maxDisplayedEnumValues ? enums.length > maxDisplayedEnumValues : false;
    const toggleButtonText = maxDisplayedEnumValues ? collapsed ? `\u2026 ${enums.length - maxDisplayedEnumValues} more` : "Hide" : "";
    return /* @__PURE__ */ jsx20("div", { children: isDescriptionEnum ? /* @__PURE__ */ jsxs12(Fragment3, { children: [
      /* @__PURE__ */ jsx20(DescriptionEnumsBlock, { children: /* @__PURE__ */ jsxs12("table", { children: [
        /* @__PURE__ */ jsx20("thead", { children: /* @__PURE__ */ jsxs12("tr", { children: [
          /* @__PURE__ */ jsxs12("th", { children: [
            /* @__PURE__ */ jsxs12(FieldLabel, { children: [
              type === "array" ? l("enumArray") : "",
              " ",
              enums.length === 1 ? l("enumSingleValue") : l("enum")
            ] }),
            " "
          ] }),
          /* @__PURE__ */ jsx20("th", { children: /* @__PURE__ */ jsx20("strong", { children: "Description" }) })
        ] }) }),
        /* @__PURE__ */ jsx20("tbody", { children: displayedItems.map(
          ({ description, value }) => {
            return /* @__PURE__ */ jsxs12("tr", { children: [
              /* @__PURE__ */ jsx20("td", { children: value }),
              /* @__PURE__ */ jsx20("td", { children: /* @__PURE__ */ jsx20(Markdown, { source: description, compact: true, inline: true }) })
            ] }, value);
          }
        ) })
      ] }) }),
      showToggleButton ? /* @__PURE__ */ jsx20(ToggleButton2, { onClick: this.toggle, children: toggleButtonText }) : null
    ] }) : /* @__PURE__ */ jsxs12(Fragment3, { children: [
      /* @__PURE__ */ jsxs12(FieldLabel, { children: [
        type === "array" ? l("enumArray") : "",
        " ",
        values.length === 1 ? l("enumSingleValue") : l("enum"),
        ":"
      ] }),
      " ",
      displayedItems.map((value, idx) => {
        const exampleValue = enumSkipQuotes ? String(value) : JSON.stringify(value);
        return /* @__PURE__ */ jsxs12(React15.Fragment, { children: [
          /* @__PURE__ */ jsx20(ExampleValue2, { children: exampleValue }),
          " "
        ] }, idx);
      }),
      showToggleButton ? /* @__PURE__ */ jsx20(ToggleButton2, { onClick: this.toggle, children: toggleButtonText }) : null
    ] }) });
  }
};
EnumValues.contextType = OptionsContext;
var ToggleButton2 = styled_components_default.span`
  color: ${(props) => props.theme.colors.primary.main};
  vertical-align: middle;
  font-size: 13px;
  line-height: 20px;
  padding: 0 5px;
  cursor: pointer;
`;

// src/components/Fields/Extensions.tsx
import React16 from "react";
import { Fragment as Fragment4, jsx as jsx21, jsxs as jsxs13 } from "react/jsx-runtime";
var Extension = styled_components_default(StyledMarkdownBlock)`
  margin: 2px 0;
`;
var Extensions = class extends React16.PureComponent {
  render() {
    const exts = this.props.extensions;
    return /* @__PURE__ */ jsx21(OptionsContext.Consumer, { children: (options2) => /* @__PURE__ */ jsx21(Fragment4, { children: options2.showExtensions && Object.keys(exts).map((key2) => /* @__PURE__ */ jsxs13(Extension, { children: [
      /* @__PURE__ */ jsxs13(FieldLabel, { children: [
        " ",
        key2.substring(2),
        ": "
      ] }),
      " ",
      /* @__PURE__ */ jsx21(ExtensionValue, { children: typeof exts[key2] === "string" ? exts[key2] : JSON.stringify(exts[key2]) })
    ] }, key2)) }) });
  }
};

// src/components/Fields/Examples.tsx
import React17 from "react";
import { Fragment as Fragment5, jsx as jsx22, jsxs as jsxs14 } from "react/jsx-runtime";
function Examples({ field }) {
  if (!field.examples) {
    return null;
  }
  return /* @__PURE__ */ jsxs14(Fragment5, { children: [
    /* @__PURE__ */ jsxs14(FieldLabel, { children: [
      " ",
      l("examples"),
      ": "
    ] }),
    isArray(field.examples) ? field.examples.map((example, idx) => {
      const value = getSerializedValue(field, example);
      const stringifyValue = field.in ? String(value) : JSON.stringify(value);
      return /* @__PURE__ */ jsxs14(React17.Fragment, { children: [
        /* @__PURE__ */ jsx22(ExampleValue2, { children: stringifyValue }),
        " "
      ] }, idx);
    }) : /* @__PURE__ */ jsx22(ExamplesList, { children: Object.values(field.examples).map((example, idx) => /* @__PURE__ */ jsxs14("li", { children: [
      /* @__PURE__ */ jsx22(ExampleValue2, { children: getSerializedValue(field, example.value) }),
      " -",
      " ",
      example.summary || example.description
    ] }, idx + example.value)) })
  ] });
}
var ExamplesList = styled_components_default.ul`
  margin-top: 1em;
  list-style-position: outside;
`;

// src/components/Fields/FieldConstraints.tsx
import React18 from "react";
import { jsxs as jsxs15 } from "react/jsx-runtime";
var ConstraintsView = class extends React18.PureComponent {
  render() {
    if (this.props.constraints.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxs15("span", { children: [
      " ",
      this.props.constraints.map((constraint) => /* @__PURE__ */ jsxs15(ConstraintItem, { children: [
        " ",
        constraint,
        " "
      ] }, constraint))
    ] });
  }
};

// src/components/Fields/FieldDetail.tsx
import React19 from "react";
import { jsx as jsx23, jsxs as jsxs16 } from "react/jsx-runtime";
function FieldDetailComponent({ value, label, raw }) {
  if (value === void 0) {
    return null;
  }
  const stringifyValue = raw ? String(value) : JSON.stringify(value);
  return /* @__PURE__ */ jsxs16("div", { children: [
    /* @__PURE__ */ jsxs16(FieldLabel, { children: [
      " ",
      label,
      " "
    ] }),
    " ",
    /* @__PURE__ */ jsx23(ExampleValue2, { children: stringifyValue })
  ] });
}
var FieldDetail = React19.memo(FieldDetailComponent);

// src/components/Fields/Pattern.tsx
import React20 from "react";
import { Fragment as Fragment6, jsx as jsx24, jsxs as jsxs17 } from "react/jsx-runtime";
var MAX_PATTERN_LENGTH = 45;
function Pattern(props) {
  const pattern = props.schema.pattern;
  const { hideSchemaPattern } = React20.useContext(OptionsContext);
  const [isPatternShown, setIsPatternShown] = React20.useState(false);
  const togglePattern = React20.useCallback(
    () => setIsPatternShown(!isPatternShown),
    [isPatternShown]
  );
  if (!pattern || hideSchemaPattern) return null;
  return /* @__PURE__ */ jsxs17(Fragment6, { children: [
    /* @__PURE__ */ jsx24(PatternLabel, { children: isPatternShown || pattern.length < MAX_PATTERN_LENGTH ? pattern : `${pattern.substr(0, MAX_PATTERN_LENGTH)}...` }),
    pattern.length > MAX_PATTERN_LENGTH && /* @__PURE__ */ jsx24(ToggleButton, { onClick: togglePattern, children: isPatternShown ? "Hide pattern" : "Show pattern" })
  ] });
}

// src/components/Fields/ArrayItemDetails.tsx
import React21 from "react";
import { jsx as jsx25, jsxs as jsxs18 } from "react/jsx-runtime";
function ArrayItemDetails({ schema }) {
  var _a2;
  const { hideSchemaPattern } = React21.useContext(OptionsContext);
  if (!schema || (!(schema == null ? void 0 : schema.pattern) || hideSchemaPattern) && !schema.items && !schema.displayFormat && !((_a2 = schema.constraints) == null ? void 0 : _a2.length)) {
    return null;
  }
  return /* @__PURE__ */ jsxs18(Wrapper2, { children: [
    "[ items",
    schema.displayFormat && /* @__PURE__ */ jsxs18(TypeFormat, { children: [
      " <",
      schema.displayFormat,
      " >"
    ] }),
    /* @__PURE__ */ jsx25(ConstraintsView, { constraints: schema.constraints }),
    /* @__PURE__ */ jsx25(Pattern, { schema }),
    schema.items && /* @__PURE__ */ jsx25(ArrayItemDetails, { schema: schema.items }),
    " ]"
  ] });
}
var Wrapper2 = styled_components_default(TypePrefix)`
  margin: 0 5px;
  vertical-align: text-top;
`;

// src/components/Fields/FieldDetails.tsx
import { jsx as jsx26, jsxs as jsxs19 } from "react/jsx-runtime";
var FieldDetailsComponent = observer2((props) => {
  const { enumSkipQuotes, hideSchemaTitles } = React22.useContext(OptionsContext);
  const { showExamples, field, renderDiscriminatorSwitch } = props;
  const { schema, description, deprecated, extensions, in: _in, const: _const } = field;
  const isArrayType = schema.type === "array" || isArray(schema.type) && schema.type.includes("array");
  const rawDefault = enumSkipQuotes || _in === "header";
  const renderedExamples = React22.useMemo(() => {
    if (showExamples && (field.example !== void 0 || field.examples !== void 0)) {
      if (field.examples !== void 0) {
        return /* @__PURE__ */ jsx26(Examples, { field });
      } else {
        return /* @__PURE__ */ jsx26(
          FieldDetail,
          {
            label: l("example") + ":",
            value: getSerializedValue(field, field.example),
            raw: Boolean(field.in)
          }
        );
      }
    }
    return null;
  }, [field, showExamples]);
  const defaultValue = isObject(schema.default) && field.in ? getSerializedValue(field, schema.default).replace(`${field.name}=`, "") : schema.default;
  return /* @__PURE__ */ jsxs19("div", { children: [
    /* @__PURE__ */ jsxs19("div", { children: [
      /* @__PURE__ */ jsx26(TypePrefix, { children: schema.typePrefix }),
      /* @__PURE__ */ jsx26(TypeName, { children: schema.displayType }),
      schema.displayFormat && /* @__PURE__ */ jsxs19(TypeFormat, { children: [
        " ",
        "<",
        schema.displayFormat,
        ">",
        " "
      ] }),
      schema.contentEncoding && /* @__PURE__ */ jsxs19(TypeFormat, { children: [
        " ",
        "<",
        schema.contentEncoding,
        ">",
        " "
      ] }),
      schema.contentMediaType && /* @__PURE__ */ jsxs19(TypeFormat, { children: [
        " ",
        "<",
        schema.contentMediaType,
        ">",
        " "
      ] }),
      schema.title && !hideSchemaTitles && /* @__PURE__ */ jsxs19(TypeTitle, { children: [
        " (",
        schema.title,
        ") "
      ] }),
      /* @__PURE__ */ jsx26(ConstraintsView, { constraints: schema.constraints }),
      /* @__PURE__ */ jsx26(Pattern, { schema }),
      schema.isCircular && /* @__PURE__ */ jsxs19(RecursiveLabel, { children: [
        " ",
        l("recursive"),
        " "
      ] }),
      isArrayType && schema.items && /* @__PURE__ */ jsx26(ArrayItemDetails, { schema: schema.items })
    ] }),
    deprecated && /* @__PURE__ */ jsx26("div", { children: /* @__PURE__ */ jsxs19(Badge, { type: "warning", children: [
      " ",
      l("deprecated"),
      " "
    ] }) }),
    /* @__PURE__ */ jsx26(FieldDetail, { raw: rawDefault, label: l("default") + ":", value: defaultValue }),
    !renderDiscriminatorSwitch && /* @__PURE__ */ jsx26(EnumValues, { type: schema.type, values: schema["x-enumDescriptions"] || schema.enum }),
    " ",
    renderedExamples,
    /* @__PURE__ */ jsx26(Extensions, { extensions: { ...extensions, ...schema.extensions } }),
    /* @__PURE__ */ jsx26("div", { children: /* @__PURE__ */ jsx26(Markdown, { compact: true, source: description }) }),
    schema.externalDocs && /* @__PURE__ */ jsx26(ExternalDocumentation, { externalDocs: schema.externalDocs, compact: true }),
    renderDiscriminatorSwitch && renderDiscriminatorSwitch(props) || null,
    _const && /* @__PURE__ */ jsx26(FieldDetail, { label: l("const") + ":", value: _const }) || null
  ] });
});
var FieldDetails = React22.memo(FieldDetailsComponent);

// src/components/Schema/ArraySchema.tsx
import React26 from "react";

// src/components/Schema/ObjectSchema.tsx
import { observer as observer5 } from "mobx-react";
import React25 from "react";

// src/components/Fields/Field.tsx
import { observer as observer3 } from "mobx-react";
import React23 from "react";
import { Fragment as Fragment7, jsx as jsx27, jsxs as jsxs20 } from "react/jsx-runtime";
var Field = class extends React23.Component {
  constructor() {
    super(...arguments);
    this.toggle = () => {
      if (this.props.field.expanded === void 0 && this.props.expandByDefault) {
        this.props.field.collapse();
      } else {
        this.props.field.toggle();
      }
    };
    this.handleKeyPress = (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.toggle();
      }
    };
  }
  render() {
    const { hidePropertiesPrefix } = this.context;
    const { className = "", field, isLast, expandByDefault, fieldParentsName = [] } = this.props;
    const { name: name2, deprecated, required: required3, kind } = field;
    const withSubSchema = !field.schema.isPrimitive && !field.schema.isCircular;
    const expanded = field.expanded === void 0 ? expandByDefault : field.expanded;
    const labels2 = /* @__PURE__ */ jsxs20(Fragment7, { children: [
      kind === "additionalProperties" && /* @__PURE__ */ jsx27(PropertyLabel, { children: "additional property" }),
      kind === "patternProperties" && /* @__PURE__ */ jsx27(PropertyLabel, { children: "pattern property" }),
      required3 && /* @__PURE__ */ jsx27(RequiredLabel, { children: "required" })
    ] });
    const paramName = withSubSchema ? /* @__PURE__ */ jsxs20(
      ClickablePropertyNameCell,
      {
        className: deprecated ? "deprecated" : "",
        kind,
        title: name2,
        children: [
          /* @__PURE__ */ jsx27(PropertyBullet, {}),
          /* @__PURE__ */ jsxs20(
            "button",
            {
              onClick: this.toggle,
              onKeyPress: this.handleKeyPress,
              "aria-label": `expand ${name2}`,
              children: [
                !hidePropertiesPrefix && fieldParentsName.map(
                  (name3) => name3 + ".\u200B"
                  // zero-width space, a special character is used for correct line breaking
                ),
                /* @__PURE__ */ jsx27("span", { className: "property-name", children: name2 }),
                /* @__PURE__ */ jsx27(ShelfIcon, { direction: expanded ? "down" : "right" })
              ]
            }
          ),
          labels2
        ]
      }
    ) : /* @__PURE__ */ jsxs20(PropertyNameCell, { className: deprecated ? "deprecated" : void 0, kind, title: name2, children: [
      /* @__PURE__ */ jsx27(PropertyBullet, {}),
      !hidePropertiesPrefix && fieldParentsName.map(
        (name3) => name3 + ".\u200B"
        // zero-width space, a special character is used for correct line breaking
      ),
      /* @__PURE__ */ jsx27("span", { className: "property-name", children: name2 }),
      labels2
    ] });
    return /* @__PURE__ */ jsxs20(Fragment7, { children: [
      /* @__PURE__ */ jsxs20("tr", { className: isLast ? "last " + className : className, children: [
        paramName,
        /* @__PURE__ */ jsx27(PropertyDetailsCell, { children: /* @__PURE__ */ jsx27(FieldDetails, { ...this.props }) })
      ] }),
      expanded && withSubSchema && /* @__PURE__ */ jsx27("tr", { children: /* @__PURE__ */ jsx27(PropertyCellWithInner, { colSpan: 2, children: /* @__PURE__ */ jsx27(InnerPropertiesWrap, { children: /* @__PURE__ */ jsx27(
        Schema,
        {
          schema: field.schema,
          fieldParentsName: [...fieldParentsName || [], field.name],
          skipReadOnly: this.props.skipReadOnly,
          skipWriteOnly: this.props.skipWriteOnly,
          showTitle: this.props.showTitle,
          level: this.props.level
        }
      ) }) }) }, field.name + "inner")
    ] });
  }
};
Field.contextType = OptionsContext;
Field = __decorateClass([
  observer3
], Field);

// src/components/Schema/DiscriminatorDropdown.tsx
import { observer as observer4 } from "mobx-react";
import React24 from "react";
import { jsx as jsx28 } from "react/jsx-runtime";
var DiscriminatorDropdown = class extends React24.Component {
  constructor() {
    super(...arguments);
    this.changeActiveChild = (option) => {
      if (option.idx !== void 0) {
        this.props.parent.activateOneOf(option.idx);
      }
    };
  }
  sortOptions(options2, enumValues) {
    if (enumValues.length === 0) {
      return;
    }
    const enumOrder = {};
    enumValues.forEach((enumItem, idx) => {
      enumOrder[enumItem] = idx;
    });
    options2.sort((a, b) => {
      return enumOrder[a.value] > enumOrder[b.value] ? 1 : -1;
    });
  }
  render() {
    const { parent, enumValues } = this.props;
    if (parent.oneOf === void 0) {
      return null;
    }
    const options2 = parent.oneOf.map((subSchema, idx) => {
      return {
        value: subSchema.title,
        idx
      };
    });
    const activeValue = options2[parent.activeOneOf].value;
    this.sortOptions(options2, enumValues);
    return /* @__PURE__ */ jsx28(
      Dropdown2,
      {
        value: activeValue,
        options: options2,
        onChange: this.changeActiveChild,
        ariaLabel: "Example"
      }
    );
  }
};
DiscriminatorDropdown = __decorateClass([
  observer4
], DiscriminatorDropdown);

// src/components/Schema/ObjectSchema.tsx
import { jsx as jsx29, jsxs as jsxs21 } from "react/jsx-runtime";
var ObjectSchema = observer5(
  ({
    schema: { fields = [], title },
    showTitle,
    discriminator,
    skipReadOnly,
    skipWriteOnly,
    level: level2,
    fieldParentsName
  }) => {
    const { expandSingleSchemaField, showObjectSchemaExamples, schemasExpansionLevel } = React25.useContext(OptionsContext);
    const filteredFields = React25.useMemo(
      () => skipReadOnly || skipWriteOnly ? fields.filter(
        (item) => !(skipReadOnly && item.schema.readOnly || skipWriteOnly && item.schema.writeOnly)
      ) : fields,
      [skipReadOnly, skipWriteOnly, fields]
    );
    const expandByDefault = expandSingleSchemaField && filteredFields.length === 1 || schemasExpansionLevel >= level2;
    return /* @__PURE__ */ jsxs21(PropertiesTable, { children: [
      showTitle && /* @__PURE__ */ jsx29(PropertiesTableCaption, { children: title }),
      /* @__PURE__ */ jsx29("tbody", { children: mapWithLast(filteredFields, (field, isLast) => {
        return /* @__PURE__ */ jsx29(
          Field,
          {
            isLast,
            field,
            expandByDefault,
            fieldParentsName: Number(level2) > 1 ? fieldParentsName : [],
            renderDiscriminatorSwitch: (discriminator == null ? void 0 : discriminator.fieldName) === field.name ? () => /* @__PURE__ */ jsx29(
              DiscriminatorDropdown,
              {
                parent: discriminator.parentSchema,
                enumValues: field.schema.enum
              }
            ) : void 0,
            className: field.expanded ? "expanded" : void 0,
            showExamples: showObjectSchemaExamples,
            skipReadOnly,
            skipWriteOnly,
            showTitle,
            level: level2
          },
          field.name
        );
      }) })
    ] });
  }
);

// src/components/Schema/ArraySchema.tsx
import { jsx as jsx30, jsxs as jsxs22 } from "react/jsx-runtime";
var PaddedSchema = styled_components_default.div`
  padding-left: ${({ theme: theme2 }) => theme2.spacing.unit * 2}px;
`;
var ArraySchema = class extends React26.PureComponent {
  render() {
    const schema = this.props.schema;
    const itemsSchema = schema.items;
    const fieldParentsName = this.props.fieldParentsName;
    const minMaxItems = schema.minItems === void 0 && schema.maxItems === void 0 ? "" : `(${humanizeConstraints(schema)})`;
    const updatedParentsArray = fieldParentsName ? [...fieldParentsName.slice(0, -1), fieldParentsName[fieldParentsName.length - 1] + "[]"] : fieldParentsName;
    if (schema.fields) {
      return /* @__PURE__ */ jsx30(
        ObjectSchema,
        {
          ...this.props,
          level: this.props.level,
          fieldParentsName: updatedParentsArray
        }
      );
    }
    if (schema.displayType && !itemsSchema && !minMaxItems.length) {
      return /* @__PURE__ */ jsx30("div", { children: /* @__PURE__ */ jsx30(TypeName, { children: schema.displayType }) });
    }
    return /* @__PURE__ */ jsxs22("div", { children: [
      /* @__PURE__ */ jsxs22(ArrayOpenningLabel, { children: [
        " Array ",
        minMaxItems
      ] }),
      /* @__PURE__ */ jsx30(PaddedSchema, { children: /* @__PURE__ */ jsx30(Schema, { ...this.props, schema: itemsSchema, fieldParentsName: updatedParentsArray }) }),
      /* @__PURE__ */ jsx30(ArrayClosingLabel, {})
    ] });
  }
};

// src/components/Schema/OneOfSchema.tsx
import { observer as observer6 } from "mobx-react";
import React27 from "react";
import { jsx as jsx31, jsxs as jsxs23 } from "react/jsx-runtime";
var OneOfButton2 = class extends React27.Component {
  constructor() {
    super(...arguments);
    this.activateOneOf = () => {
      this.props.schema.activateOneOf(this.props.idx);
    };
  }
  render() {
    const { idx, schema, subSchema } = this.props;
    return /* @__PURE__ */ jsx31(
      OneOfButton,
      {
        $deprecated: subSchema.deprecated,
        $active: idx === schema.activeOneOf,
        onClick: this.activateOneOf,
        children: subSchema.title || subSchema.typePrefix + subSchema.displayType
      }
    );
  }
};
OneOfButton2 = __decorateClass([
  observer6
], OneOfButton2);
var OneOfSchema = class extends React27.Component {
  render() {
    const {
      schema: { oneOf },
      schema
    } = this.props;
    if (oneOf === void 0) {
      return null;
    }
    const activeSchema = oneOf[schema.activeOneOf];
    return /* @__PURE__ */ jsxs23("div", { children: [
      /* @__PURE__ */ jsxs23(OneOfLabel, { children: [
        " ",
        schema.oneOfType,
        " "
      ] }),
      /* @__PURE__ */ jsx31(OneOfList, { children: oneOf.map((subSchema, idx) => /* @__PURE__ */ jsx31(OneOfButton2, { schema, subSchema, idx }, subSchema.pointer)) }),
      /* @__PURE__ */ jsx31("div", { children: oneOf[schema.activeOneOf].deprecated && /* @__PURE__ */ jsx31(Badge, { type: "warning", children: "Deprecated" }) }),
      /* @__PURE__ */ jsx31(ConstraintsView, { constraints: activeSchema.constraints }),
      /* @__PURE__ */ jsx31(Schema, { ...this.props, schema: activeSchema })
    ] });
  }
};
OneOfSchema = __decorateClass([
  observer6
], OneOfSchema);

// src/components/Schema/RecursiveSchema.tsx
import { observer as observer7 } from "mobx-react";
import { jsx as jsx32, jsxs as jsxs24 } from "react/jsx-runtime";
var RecursiveSchema = observer7(({ schema }) => {
  return /* @__PURE__ */ jsxs24("div", { children: [
    /* @__PURE__ */ jsx32(TypeName, { children: schema.displayType }),
    schema.title && /* @__PURE__ */ jsxs24(TypeTitle, { children: [
      " ",
      schema.title,
      " "
    ] }),
    /* @__PURE__ */ jsxs24(RecursiveLabel, { children: [
      " ",
      l("recursive"),
      " "
    ] })
  ] });
});

// src/components/Schema/Schema.tsx
import { jsx as jsx33 } from "react/jsx-runtime";
var Schema = class extends React28.Component {
  render() {
    var _a2;
    const { schema, ...rest } = this.props;
    const level2 = (rest.level || 0) + 1;
    if (!schema) {
      return /* @__PURE__ */ jsx33("em", { children: " Schema not provided " });
    }
    const { type, oneOf, discriminatorProp, isCircular } = schema;
    if (isCircular) {
      return /* @__PURE__ */ jsx33(RecursiveSchema, { schema });
    }
    if (discriminatorProp !== void 0) {
      if (!oneOf || !oneOf.length) {
        console.warn(
          `Looks like you are using discriminator wrong: you don't have any definition inherited from the ${schema.title}`
        );
        return null;
      }
      const activeSchema = oneOf[schema.activeOneOf];
      return activeSchema.isCircular ? /* @__PURE__ */ jsx33(RecursiveSchema, { schema: activeSchema }) : /* @__PURE__ */ jsx33(
        ObjectSchema,
        {
          ...rest,
          level: level2,
          schema: activeSchema,
          discriminator: {
            fieldName: discriminatorProp,
            parentSchema: schema
          }
        }
      );
    }
    if (oneOf !== void 0) {
      return /* @__PURE__ */ jsx33(OneOfSchema, { schema, ...rest });
    }
    const types2 = isArray(type) ? type : [type];
    if (types2.includes("object")) {
      if ((_a2 = schema.fields) == null ? void 0 : _a2.length) {
        return /* @__PURE__ */ jsx33(ObjectSchema, { ...this.props, level: level2 });
      }
    } else if (types2.includes("array")) {
      return /* @__PURE__ */ jsx33(ArraySchema, { ...this.props, level: level2 });
    }
    const field = {
      schema,
      name: "",
      required: false,
      description: schema.description,
      externalDocs: schema.externalDocs,
      deprecated: false,
      toggle: () => null,
      expanded: false
    };
    return /* @__PURE__ */ jsx33("div", { children: /* @__PURE__ */ jsx33(FieldDetails, { field }) });
  }
};
Schema = __decorateClass([
  observer8
], Schema);

// src/components/SchemaDefinition/SchemaDefinition.tsx
import { jsx as jsx34, jsxs as jsxs25 } from "react/jsx-runtime";
var SchemaDefinition = class _SchemaDefinition extends React29.PureComponent {
  constructor() {
    super(...arguments);
    this.renderDropdown = (props) => {
      return /* @__PURE__ */ jsx34(
        DropdownOrLabel,
        {
          Label: MimeLabel,
          Dropdown: InvertedSimpleDropdown,
          ...props,
          variant: "dark"
        }
      );
    };
  }
  static getMediaType(schemaRef, exampleRef) {
    if (!schemaRef) {
      return {};
    }
    const info = {
      schema: { $ref: schemaRef }
    };
    if (exampleRef) {
      info.examples = { example: { $ref: exampleRef } };
    }
    return info;
  }
  get mediaModel() {
    const { parser: parser3, schemaRef, exampleRef, options: options2 } = this.props;
    if (!this._mediaModel) {
      this._mediaModel = new MediaTypeModel(
        parser3,
        "json",
        false,
        _SchemaDefinition.getMediaType(schemaRef, exampleRef),
        options2
      );
    }
    return this._mediaModel;
  }
  render() {
    const { showReadOnly = true, showWriteOnly = false, showExample = true } = this.props;
    return /* @__PURE__ */ jsx34(Section, { children: /* @__PURE__ */ jsxs25(Row, { children: [
      /* @__PURE__ */ jsx34(MiddlePanel, { children: /* @__PURE__ */ jsx34(
        Schema,
        {
          skipWriteOnly: !showWriteOnly,
          skipReadOnly: !showReadOnly,
          schema: this.mediaModel.schema
        }
      ) }),
      showExample && /* @__PURE__ */ jsx34(DarkRightPanel, { children: /* @__PURE__ */ jsx34(MediaSamplesWrap, { children: /* @__PURE__ */ jsx34(
        MediaTypeSamples,
        {
          renderDropdown: this.renderDropdown,
          mediaType: this.mediaModel
        }
      ) }) })
    ] }) });
  }
};
var MediaSamplesWrap = styled_components_default.div`
  background: ${({ theme: theme2 }) => theme2.codeBlock.backgroundColor};
  & > div,
  & > pre {
    padding: ${(props) => props.theme.spacing.unit * 4}px;
    margin: 0;
  }

  & > div > pre {
    padding: 0;
  }
`;

// src/components/SecuritySchemes/SecuritySchemes.tsx
import React32 from "react";

// src/components/SecurityRequirement/styled.elements.ts
var ScopeName = styled_components_default.code`
  font-size: ${(props) => props.theme.typography.code.fontSize};
  font-family: ${(props) => props.theme.typography.code.fontFamily};
  margin: 0 3px;
  padding: 0.2em;
  display: inline-block;
  line-height: 1;

  &:after {
    content: ',';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }
`;
var SecurityRequirementAndWrap = styled_components_default.span`
  &:after {
    content: ' and ';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }

  ${linksCss};
`;
var SecurityRequirementOrWrap = styled_components_default.span`
  ${(p) => !p.$expanded && `white-space: nowrap;`}
  &:after {
    content: ' or ';
    ${(p) => p.$expanded && `content: ' or \\a';`}
    white-space: pre;
  }

  &:last-child:after,
  &:only-child:after {
    content: none;
  }

  ${linksCss};
`;
var AuthHeaderColumn = styled_components_default.div`
  flex: 1 1 auto;
  cursor: pointer;
`;
var SecuritiesColumn = styled_components_default.div`
  width: ${(props) => props.theme.schema.defaultDetailsWidth};
  text-overflow: ellipsis;
  border-radius: 4px;
  overflow: hidden;
  ${(p) => p.$expanded && `background: ${p.theme.colors.gray["100"]};
     padding: 8px 9.6px;
     margin: 20px 0;
     width: 100%;
    `};
  ${media.lessThan("small")`
    margin-top: 10px;
  `}
`;
var AuthHeader = styled_components_default(UnderlinedHeader)`
  display: inline-block;
  margin: 0;
`;
var Wrap = styled_components_default.div`
  width: 100%;
  display: flex;
  margin: 1em 0;
  flex-direction: ${(p) => p.$expanded ? "column" : "row"};
  ${media.lessThan("small")`
    flex-direction: column;
  `}
`;
var SecurityRow = styled_components_default.div`
  margin: 0.5em 0;
`;
var SecurityDetailsStyle = styled_components_default.div`
  border-bottom: 1px solid ${({ theme: theme2 }) => theme2.colors.border.dark};
  margin-bottom: 1.5em;
  padding-bottom: 0.7em;

  h5 {
    line-height: 1em;
    margin: 0 0 0.6em;
    font-size: ${({ theme: theme2 }) => theme2.typography.fontSize};
  }

  .redoc-markdown p:first-child {
    display: inline;
  }
`;

// src/components/SecurityRequirement/OAuthFlow.tsx
import React31 from "react";

// src/components/SeeMore/SeeMore.tsx
import React30 from "react";
import { Fragment as Fragment8, jsx as jsx35, jsxs as jsxs26 } from "react/jsx-runtime";
var TOLERANCE_PX = 20;
function SeeMore({ children, height }) {
  const ref = React30.createRef();
  const [showMore, setShowMore] = React30.useState(false);
  const [showLink, setShowLink] = React30.useState(false);
  React30.useEffect(() => {
    if (ref.current && ref.current.clientHeight + TOLERANCE_PX < ref.current.scrollHeight) {
      setShowLink(true);
    }
  }, [ref]);
  const onClickMore = () => {
    setShowMore(!showMore);
  };
  return /* @__PURE__ */ jsxs26(Fragment8, { children: [
    /* @__PURE__ */ jsx35(
      Container,
      {
        ref,
        className: showMore ? "" : "container",
        style: { height: showMore ? "auto" : height },
        children
      }
    ),
    /* @__PURE__ */ jsx35(ButtonContainer, { $dimmed: !showMore, children: showLink && /* @__PURE__ */ jsx35(ButtonLinkStyled, { onClick: onClickMore, children: showMore ? "See less" : "See more" }) })
  ] });
}
var Container = styled_components_default.div`
  overflow-y: hidden;
`;
var ButtonContainer = styled_components_default.div`
  text-align: center;
  line-height: 1.5em;
  ${({ $dimmed }) => $dimmed && `background-image: linear-gradient(to bottom, transparent,rgb(255 255 255));
     position: relative;
     top: -0.5em;
     padding-top: 0.5em;
     background-position-y: -1em;
    `}
`;
var ButtonLinkStyled = styled_components_default.a`
  cursor: pointer;
`;

// src/components/SecurityRequirement/OAuthFlow.tsx
import { Fragment as Fragment9, jsx as jsx36, jsxs as jsxs27 } from "react/jsx-runtime";
function OAuthFlowComponent(props) {
  const { type, flow, RequiredScopes } = props;
  const scopesNames = Object.keys((flow == null ? void 0 : flow.scopes) || {});
  return /* @__PURE__ */ jsxs27(Fragment9, { children: [
    /* @__PURE__ */ jsxs27(SecurityRow, { children: [
      /* @__PURE__ */ jsx36("b", { children: "Flow type: " }),
      /* @__PURE__ */ jsxs27("code", { children: [
        type,
        " "
      ] })
    ] }),
    (type === "implicit" || type === "authorizationCode") && /* @__PURE__ */ jsxs27(SecurityRow, { children: [
      /* @__PURE__ */ jsx36("strong", { children: " Authorization URL: " }),
      /* @__PURE__ */ jsx36("code", { children: /* @__PURE__ */ jsx36("a", { target: "_blank", rel: "noopener noreferrer", href: flow.authorizationUrl, children: flow.authorizationUrl }) })
    ] }),
    (type === "password" || type === "clientCredentials" || type === "authorizationCode") && /* @__PURE__ */ jsxs27(SecurityRow, { children: [
      /* @__PURE__ */ jsx36("b", { children: " Token URL: " }),
      /* @__PURE__ */ jsx36("code", { children: flow.tokenUrl })
    ] }),
    flow.refreshUrl && /* @__PURE__ */ jsxs27(SecurityRow, { children: [
      /* @__PURE__ */ jsx36("strong", { children: " Refresh URL: " }),
      /* @__PURE__ */ jsx36("code", { children: flow.refreshUrl })
    ] }),
    !!scopesNames.length && /* @__PURE__ */ jsxs27(Fragment9, { children: [
      RequiredScopes || null,
      /* @__PURE__ */ jsx36(SecurityRow, { children: /* @__PURE__ */ jsx36("b", { children: " Scopes: " }) }),
      /* @__PURE__ */ jsx36(SeeMore, { height: "4em", children: /* @__PURE__ */ jsx36("ul", { children: scopesNames.map((scope) => /* @__PURE__ */ jsxs27("li", { children: [
        /* @__PURE__ */ jsx36("code", { children: scope }),
        " -",
        " ",
        /* @__PURE__ */ jsx36(
          Markdown,
          {
            className: "redoc-markdown",
            inline: true,
            source: flow.scopes[scope] || ""
          }
        )
      ] }, scope)) }) })
    ] })
  ] });
}
var OAuthFlow = React31.memo(OAuthFlowComponent);

// src/components/SecurityRequirement/SecurityDetails.tsx
import { Fragment as Fragment10, jsx as jsx37, jsxs as jsxs28 } from "react/jsx-runtime";
function SecurityDetails(props) {
  const { RequiredScopes, scheme } = props;
  return /* @__PURE__ */ jsx37(StyledMarkdownBlock, { children: scheme.apiKey ? /* @__PURE__ */ jsxs28(Fragment10, { children: [
    /* @__PURE__ */ jsxs28(SecurityRow, { children: [
      /* @__PURE__ */ jsxs28("b", { children: [
        titleize(scheme.apiKey.in || ""),
        " parameter name: "
      ] }),
      /* @__PURE__ */ jsx37("code", { children: scheme.apiKey.name })
    ] }),
    RequiredScopes
  ] }) : scheme.http ? /* @__PURE__ */ jsxs28(Fragment10, { children: [
    /* @__PURE__ */ jsxs28(SecurityRow, { children: [
      /* @__PURE__ */ jsx37("b", { children: "HTTP Authorization Scheme: " }),
      /* @__PURE__ */ jsx37("code", { children: scheme.http.scheme })
    ] }),
    /* @__PURE__ */ jsx37(SecurityRow, { children: scheme.http.scheme === "bearer" && scheme.http.bearerFormat && /* @__PURE__ */ jsxs28(Fragment10, { children: [
      /* @__PURE__ */ jsx37("b", { children: "Bearer format: " }),
      /* @__PURE__ */ jsx37("code", { children: scheme.http.bearerFormat })
    ] }) }),
    RequiredScopes
  ] }) : scheme.openId ? /* @__PURE__ */ jsxs28(Fragment10, { children: [
    /* @__PURE__ */ jsxs28(SecurityRow, { children: [
      /* @__PURE__ */ jsx37("b", { children: "Connect URL: " }),
      /* @__PURE__ */ jsx37("code", { children: /* @__PURE__ */ jsx37("a", { target: "_blank", rel: "noopener noreferrer", href: scheme.openId.connectUrl, children: scheme.openId.connectUrl }) })
    ] }),
    RequiredScopes
  ] }) : scheme.flows ? Object.keys(scheme.flows).map((type) => /* @__PURE__ */ jsx37(
    OAuthFlow,
    {
      type,
      RequiredScopes,
      flow: scheme.flows[type]
    },
    type
  )) : null });
}

// src/components/SecuritySchemes/SecuritySchemes.tsx
import { jsx as jsx38, jsxs as jsxs29 } from "react/jsx-runtime";
var AUTH_TYPES = {
  oauth2: "OAuth2",
  apiKey: "API Key",
  http: "HTTP",
  openIdConnect: "OpenID Connect"
};
var SecurityDefs = class extends React32.PureComponent {
  render() {
    return this.props.securitySchemes.schemes.map((scheme) => /* @__PURE__ */ jsx38(Section, { id: scheme.sectionId, children: /* @__PURE__ */ jsx38(Row, { children: /* @__PURE__ */ jsxs29(MiddlePanel, { children: [
      /* @__PURE__ */ jsxs29(H2, { children: [
        /* @__PURE__ */ jsx38(ShareLink, { to: scheme.sectionId }),
        scheme.displayName
      ] }),
      /* @__PURE__ */ jsx38(Markdown, { source: scheme.description || "" }),
      /* @__PURE__ */ jsxs29(SecurityDetailsStyle, { children: [
        /* @__PURE__ */ jsxs29(SecurityRow, { children: [
          /* @__PURE__ */ jsx38("b", { children: "Security Scheme Type: " }),
          /* @__PURE__ */ jsx38("span", { children: AUTH_TYPES[scheme.type] || scheme.type })
        ] }),
        /* @__PURE__ */ jsx38(SecurityDetails, { scheme })
      ] })
    ] }) }) }, scheme.id));
  }
};

// src/services/AppStore.ts
async function createStore(spec, specUrl, options2 = {}) {
  const resolvedSpec = await loadAndBundleSpec(spec || specUrl);
  return new AppStore(resolvedSpec, specUrl, options2);
}
var AppStore = class _AppStore {
  constructor(spec, specUrl, options2 = {}, createSearchIndex = true) {
    this.marker = new MarkerService();
    this.disposer = null;
    this.rawOptions = options2;
    this.options = new RedocNormalizedOptions(options2, DEFAULT_OPTIONS);
    this.scroll = new ScrollService(this.options);
    MenuStore.updateOnHistory(history.currentId, this.scroll);
    this.spec = new SpecStore(spec, specUrl, this.options);
    this.menu = new MenuStore(this.spec, this.scroll, history);
    if (!this.options.disableSearch) {
      this.search = new SearchStore();
      if (createSearchIndex) {
        this.search.indexItems(this.menu.items);
      }
      this.disposer = observe(this.menu, "activeItemIdx", (change) => {
        this.updateMarkOnMenu(change.newValue);
      });
    }
  }
  /**
   * deserialize store
   * **SUPER HACKY AND NOT OPTIMAL IMPLEMENTATION**
   */
  // TODO:
  static fromJS(state) {
    const inst = new _AppStore(state.spec.data, state.spec.url, state.options, false);
    inst.menu.activeItemIdx = state.menu.activeItemIdx || 0;
    inst.menu.activate(inst.menu.flatItems[inst.menu.activeItemIdx]);
    if (!inst.options.disableSearch) {
      inst.search.load(state.searchIndex);
    }
    return inst;
  }
  onDidMount() {
    this.menu.updateOnHistory();
    this.updateMarkOnMenu(this.menu.activeItemIdx);
  }
  dispose() {
    this.scroll.dispose();
    this.menu.dispose();
    if (this.search) {
      this.search.dispose();
    }
    if (this.disposer != null) {
      this.disposer();
    }
  }
  /**
   * serializes store
   * **SUPER HACKY AND NOT OPTIMAL IMPLEMENTATION**
   */
  // TODO: improve
  async toJS() {
    return {
      menu: {
        activeItemIdx: this.menu.activeItemIdx
      },
      spec: {
        url: this.spec.parser.specUrl,
        data: this.spec.parser.spec
      },
      searchIndex: this.search ? await this.search.toJS() : void 0,
      options: this.rawOptions
    };
  }
  updateMarkOnMenu(idx) {
    const start = Math.max(0, idx);
    const end = Math.min(this.menu.flatItems.length, start + 5);
    const elements = [];
    for (let i = start; i < end; i++) {
      const elem = this.menu.getElementAt(i);
      if (!elem) {
        continue;
      }
      elements.push(elem);
    }
    if (idx === -1 && IS_BROWSER) {
      const $description = document.querySelector('[data-role="redoc-description"]');
      const $summary = document.querySelector('[data-role="redoc-summary"]');
      if ($description) elements.push($description);
      if ($summary) elements.push($summary);
    }
    this.marker.addOnly(elements);
    this.marker.mark();
  }
};
var DEFAULT_OPTIONS = {
  allowedMdComponents: {
    [SECURITY_DEFINITIONS_JSX_NAME]: {
      component: SecurityDefs,
      propsSelector: (store2) => ({
        securitySchemes: store2.spec.securitySchemes
      })
    },
    [OLD_SECURITY_DEFINITIONS_JSX_NAME]: {
      component: SecurityDefs,
      propsSelector: (store2) => ({
        securitySchemes: store2.spec.securitySchemes
      })
    },
    [SCHEMA_DEFINITION_JSX_NAME]: {
      component: SchemaDefinition,
      propsSelector: (store2) => ({
        parser: store2.spec.parser,
        options: store2.options
      })
    }
  }
};

// src/components/ApiInfo/ApiInfo.tsx
import { observer as observer9 } from "mobx-react";
import React33 from "react";

// src/components/ApiInfo/styled.elements.ts
var delimiterWidth = 15;
var ApiHeader = styled_components_default(H1)`
  margin-top: 0;
  margin-bottom: 0.5em;

  ${extensionsHook("ApiHeader")};
`;
var DownloadButton = styled_components_default.a`
  border: 1px solid ${(props) => props.theme.colors.primary.main};
  color: ${(props) => props.theme.colors.primary.main};
  font-weight: normal;
  margin-left: 0.5em;
  padding: 4px 8px 4px;
  display: inline-block;
  text-decoration: none;
  cursor: pointer;

  ${extensionsHook("DownloadButton")};
`;
var InfoSpan = styled_components_default.span`
  &::before {
    content: '|';
    display: inline-block;
    opacity: 0.5;
    width: ${delimiterWidth}px;
    text-align: center;
  }

  &:last-child::after {
    display: none;
  }
`;
var InfoSpanBoxWrap = styled_components_default.div`
  overflow: hidden;
`;
var InfoSpanBox = styled_components_default.div`
  display: flex;
  flex-wrap: wrap;
  // hide separator on new lines: idea from https://stackoverflow.com/a/31732902/1749888
  margin-left: -${delimiterWidth}px;
`;

// src/components/ApiInfo/ApiInfo.tsx
import { jsx as jsx39, jsxs as jsxs30 } from "react/jsx-runtime";
var ApiInfo = class extends React33.Component {
  render() {
    const { store: store2 } = this.props;
    const { info, externalDocs } = store2.spec;
    const hideDownloadButtons = store2.options.hideDownloadButtons;
    const downloadUrls = info.downloadUrls;
    const downloadFileName = info.downloadFileName;
    const license = info.license && /* @__PURE__ */ jsxs30(InfoSpan, { children: [
      "License:",
      " ",
      info.license.identifier ? info.license.identifier : /* @__PURE__ */ jsx39("a", { href: info.license.url, children: info.license.name })
    ] }) || null;
    const website = info.contact && info.contact.url && /* @__PURE__ */ jsxs30(InfoSpan, { children: [
      "URL: ",
      /* @__PURE__ */ jsx39("a", { href: info.contact.url, children: info.contact.url })
    ] }) || null;
    const email = info.contact && info.contact.email && /* @__PURE__ */ jsxs30(InfoSpan, { children: [
      info.contact.name || "E-mail",
      ":",
      " ",
      /* @__PURE__ */ jsx39("a", { href: "mailto:" + info.contact.email, children: info.contact.email })
    ] }) || null;
    const terms = info.termsOfService && /* @__PURE__ */ jsx39(InfoSpan, { children: /* @__PURE__ */ jsx39("a", { href: info.termsOfService, children: "Terms of Service" }) }) || null;
    const version = info.version && /* @__PURE__ */ jsxs30("span", { children: [
      "(",
      info.version,
      ")"
    ] }) || null;
    return /* @__PURE__ */ jsx39(Section, { children: /* @__PURE__ */ jsx39(Row, { children: /* @__PURE__ */ jsxs30(MiddlePanel, { className: "api-info", children: [
      /* @__PURE__ */ jsxs30(ApiHeader, { children: [
        info.title,
        " ",
        version
      ] }),
      !hideDownloadButtons && /* @__PURE__ */ jsxs30("p", { children: [
        l("downloadSpecification"),
        ":",
        downloadUrls == null ? void 0 : downloadUrls.map(({ title, url }) => {
          return /* @__PURE__ */ jsx39(
            DownloadButton,
            {
              download: downloadFileName || true,
              target: "_blank",
              href: url,
              rel: "noreferrer",
              children: title
            },
            url
          );
        })
      ] }),
      /* @__PURE__ */ jsx39(StyledMarkdownBlock, { children: (info.license || info.contact || info.termsOfService) && /* @__PURE__ */ jsx39(InfoSpanBoxWrap, { children: /* @__PURE__ */ jsxs30(InfoSpanBox, { children: [
        email,
        " ",
        website,
        " ",
        license,
        " ",
        terms
      ] }) }) || null }),
      /* @__PURE__ */ jsx39(Markdown, { source: store2.spec.info.summary, "data-role": "redoc-summary" }),
      /* @__PURE__ */ jsx39(Markdown, { source: store2.spec.info.description, "data-role": "redoc-description" }),
      externalDocs && /* @__PURE__ */ jsx39(ExternalDocumentation, { externalDocs })
    ] }) }) });
  }
};
ApiInfo = __decorateClass([
  observer9
], ApiInfo);

// src/components/ApiLogo/ApiLogo.tsx
import { observer as observer10 } from "mobx-react";
import React34 from "react";

// src/components/ApiLogo/styled.elements.tsx
import { jsx as jsx40 } from "react/jsx-runtime";
var LogoImgEl = styled_components_default.img`
  max-height: ${(props) => props.theme.logo.maxHeight};
  max-width: ${(props) => props.theme.logo.maxWidth};
  padding: ${(props) => props.theme.logo.gutter};
  width: 100%;
  display: block;
`;
var LogoWrap = styled_components_default.div`
  text-align: center;
`;
var Link2 = styled_components_default.a`
  display: inline-block;
`;
var LinkWrap2 = (url) => (Component) => /* @__PURE__ */ jsx40(Link2, { href: url, children: Component });

// src/components/ApiLogo/ApiLogo.tsx
import { jsx as jsx41 } from "react/jsx-runtime";
var ApiLogo = class extends React34.Component {
  render() {
    const { info } = this.props;
    const logoInfo = info["x-logo"];
    if (!logoInfo || !logoInfo.url) {
      return null;
    }
    const logoHref = logoInfo.href || info.contact && info.contact.url;
    const altText = logoInfo.altText ? logoInfo.altText : "logo";
    const logo = /* @__PURE__ */ jsx41(LogoImgEl, { src: logoInfo.url, alt: altText });
    return /* @__PURE__ */ jsx41(LogoWrap, { style: { backgroundColor: logoInfo.backgroundColor }, children: logoHref ? LinkWrap2(logoHref)(logo) : logo });
  }
};
ApiLogo = __decorateClass([
  observer10
], ApiLogo);

// src/components/ContentItems/ContentItems.tsx
import { observer as observer22 } from "mobx-react";
import React63 from "react";

// src/components/Markdown/AdvancedMarkdown.tsx
import React35 from "react";
import { jsx as jsx42 } from "react/jsx-runtime";
var AdvancedMarkdown = class extends React35.Component {
  render() {
    return /* @__PURE__ */ jsx42(OptionsConsumer, { children: (options2) => /* @__PURE__ */ jsx42(Consumer, { children: (store2) => this.renderWithOptionsAndStore(options2, store2) }) });
  }
  renderWithOptionsAndStore(options2, store2) {
    const { source, htmlWrap = (i) => i } = this.props;
    if (!store2) {
      throw new Error("When using components in markdown, store prop must be provided");
    }
    const renderer2 = new MarkdownRenderer(options2, this.props.parentId);
    const parts = renderer2.renderMdWithComponents(source);
    if (!parts.length) {
      return null;
    }
    return parts.map((part, idx) => {
      if (typeof part === "string") {
        return React35.cloneElement(
          htmlWrap(/* @__PURE__ */ jsx42(SanitizedMarkdownHTML, { html: part, inline: false, compact: false })),
          { key: idx }
        );
      }
      const PartComponent = part.component;
      return /* @__PURE__ */ jsx42(PartComponent, { ...{ ...part.props, ...part.propsSelector(store2) } }, idx);
    });
  }
};

// src/components/Operation/Operation.tsx
import { observer as observer21 } from "mobx-react";
import React62 from "react";

// src/components/Callbacks/CallbackOperation.tsx
import { observer as observer15 } from "mobx-react";
import React53 from "react";

// src/components/Callbacks/CallbackTitle.tsx
var import_polished6 = __toESM(require_polished_cjs(), 1);

// src/components/SideMenu/styled.elements.ts
var import_classnames = __toESM(require_classnames(), 1);
var import_polished5 = __toESM(require_polished_cjs(), 1);
var OperationBadge = styled_components_default.span.attrs((props) => ({
  className: `operation-type ${props.type}`
}))`
  width: 9ex;
  display: inline-block;
  height: ${(props) => props.theme.typography.code.fontSize};
  line-height: ${(props) => props.theme.typography.code.fontSize};
  background-color: ${(props) => props.color || "#333"};
  border-radius: 3px;
  background-repeat: no-repeat;
  background-position: 6px 4px;
  font-size: 7px;
  font-family: Verdana, sans-serif; // web-safe
  color: white;
  text-transform: uppercase;
  text-align: center;
  font-weight: bold;
  vertical-align: middle;
  margin-right: 6px;
  margin-top: 2px;

  &.get {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.get};
  }

  &.post {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.post};
  }

  &.put {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.put};
  }

  &.options {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.options};
  }

  &.patch {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.patch};
  }

  &.delete {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.delete};
  }

  &.basic {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.basic};
  }

  &.link {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.link};
  }

  &.head {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.head};
  }

  &.hook {
    background-color: ${({ theme: theme2 }) => theme2.colors.primary.main};
  }

  &.schema {
    background-color: ${({ theme: theme2 }) => theme2.colors.http.basic};
  }
`;
function menuItemActive(depth, { theme: theme2 }, option) {
  if (depth > 1) {
    return theme2.sidebar.level1Items[option];
  } else if (depth === 1) {
    return theme2.sidebar.groupItems[option];
  } else {
    return "";
  }
}
var MenuItemUl = styled_components_default.ul`
  margin: 0;
  padding: 0;

  &:first-child {
    padding-bottom: 32px;
  }

  & & {
    font-size: 0.929em;
  }

  ${(props) => props.$expanded ? "" : "display: none;"};
`;
var MenuItemLi = styled_components_default.li`
  list-style: none inside none;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0;
  ${(props) => props.depth === 0 ? "margin-top: 15px" : ""};
`;
var menuItemDepth = {
  0: css`
    opacity: 0.7;
    text-transform: ${({ theme: theme2 }) => theme2.sidebar.groupItems.textTransform};
    font-size: 0.8em;
    padding-bottom: 0;
    cursor: default;
  `,
  1: css`
    font-size: 0.929em;
    text-transform: ${({ theme: theme2 }) => theme2.sidebar.level1Items.textTransform};
  `
};
var MenuItemLabel = styled_components_default.label.attrs((props) => ({
  className: (0, import_classnames.default)("-depth" + props.$depth, {
    active: props.$active
  })
}))`
  cursor: pointer;
  color: ${(props) => props.$active ? menuItemActive(props.$depth, props, "activeTextColor") : props.theme.sidebar.textColor};
  margin: 0;
  padding: 12.5px ${(props) => props.theme.spacing.unit * 4}px;
  ${({ $depth, $type, theme: theme2 }) => $type === "section" && $depth > 1 && "padding-left: " + theme2.spacing.unit * 8 + "px;" || ""}
  display: flex;
  justify-content: space-between;
  font-family: ${(props) => props.theme.typography.headings.fontFamily};
  ${(props) => menuItemDepth[props.$depth]};
  background-color: ${(props) => props.$active ? menuItemActive(props.$depth, props, "activeBackgroundColor") : props.theme.sidebar.backgroundColor};

  ${(props) => props.$deprecated && deprecatedCss || ""};

  &:hover {
    color: ${(props) => menuItemActive(props.$depth, props, "activeTextColor")};
    background-color: ${(props) => menuItemActive(props.$depth, props, "activeBackgroundColor")};
  }

  ${ShelfIcon} {
    height: ${({ theme: theme2 }) => theme2.sidebar.arrow.size};
    width: ${({ theme: theme2 }) => theme2.sidebar.arrow.size};
    polygon {
      fill: ${({ theme: theme2 }) => theme2.sidebar.arrow.color};
    }
  }
`;
var MenuItemTitle = styled_components_default.span`
  display: inline-block;
  vertical-align: middle;
  width: ${(props) => props.width ? props.width : "auto"};
  overflow: hidden;
  text-overflow: ellipsis;
`;
var RedocAttribution = styled_components_default.div`
  ${({ theme: theme2 }) => css`
    font-size: 0.8em;
    margin-top: ${theme2.spacing.unit * 2}px;
    text-align: center;
    position: fixed;
    width: ${theme2.sidebar.width};
    bottom: 0;
    background: ${theme2.sidebar.backgroundColor};

    a,
    a:visited,
    a:hover {
      color: ${theme2.sidebar.textColor} !important;
      padding: ${theme2.spacing.unit}px 0;
      border-top: 1px solid ${(0, import_polished5.darken)(0.1, theme2.sidebar.backgroundColor)};
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  `};
  img {
    width: 15px;
    margin-right: 5px;
  }

  ${media.lessThan("small")`
    width: 100%;
  `};
`;

// src/components/Callbacks/CallbackTitle.tsx
import { jsx as jsx43, jsxs as jsxs31 } from "react/jsx-runtime";
var CallbackTitle = (props) => {
  const { name: name2, opened, className, onClick, httpVerb, deprecated } = props;
  return /* @__PURE__ */ jsxs31(CallbackTitleWrapper, { className, onClick: onClick || void 0, children: [
    /* @__PURE__ */ jsx43(OperationBadgeStyled, { type: httpVerb, children: shortenHTTPVerb(httpVerb) }),
    /* @__PURE__ */ jsx43(ShelfIcon, { size: "1.5em", direction: opened ? "down" : "right", float: "left" }),
    /* @__PURE__ */ jsx43(CallbackName, { $deprecated: deprecated, children: name2 }),
    deprecated ? /* @__PURE__ */ jsxs31(Badge, { type: "warning", children: [
      " ",
      l("deprecated"),
      " "
    ] }) : null
  ] });
};
var CallbackTitleWrapper = styled_components_default.button`
  border: 0;
  width: 100%;
  text-align: left;
  & > * {
    vertical-align: middle;
  }

  ${ShelfIcon} {
    polygon {
      fill: ${({ theme: theme2 }) => (0, import_polished6.darken)(theme2.colors.tonalOffset, theme2.colors.gray[100])};
    }
  }
`;
var CallbackName = styled_components_default.span`
  text-decoration: ${(props) => props.$deprecated ? "line-through" : "none"};
  margin-right: 8px;
`;
var OperationBadgeStyled = styled_components_default(OperationBadge)`
  margin: 0 5px 0 0;
`;

// src/components/Callbacks/styled.elements.ts
var import_polished7 = __toESM(require_polished_cjs(), 1);
var StyledCallbackTitle = styled_components_default(CallbackTitle)`
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  background-color: ${({ theme: theme2 }) => theme2.colors.gray[100]};
  cursor: pointer;
  outline-color: ${({ theme: theme2 }) => (0, import_polished7.darken)(theme2.colors.tonalOffset, theme2.colors.gray[100])};
`;
var CallbackDetailsWrap = styled_components_default.div`
  padding: 10px 25px;
  background-color: ${({ theme: theme2 }) => theme2.colors.gray[50]};
  margin-bottom: 5px;
  margin-top: 5px;
`;

// src/components/Callbacks/CallbackDetails.tsx
import { observer as observer14 } from "mobx-react";
import React52 from "react";

// src/components/Endpoint/Endpoint.tsx
import React42 from "react";

// src/components/SelectOnClick/SelectOnClick.tsx
import React36 from "react";
import { jsx as jsx44 } from "react/jsx-runtime";
var SelectOnClick = class extends React36.PureComponent {
  constructor() {
    super(...arguments);
    this.selectElement = () => {
      ClipboardService.selectElement(this.child);
    };
  }
  render() {
    const { children } = this.props;
    return /* @__PURE__ */ jsx44(
      "div",
      {
        ref: (el) => this.child = el,
        onClick: this.selectElement,
        onFocus: this.selectElement,
        tabIndex: 0,
        role: "button",
        children
      }
    );
  }
};

// src/components/TryItConsole/TryItConsole.tsx
import { observer as observer11 } from "mobx-react";
import { useCallback as useCallback4, useMemo as useMemo4, useState as useState5 } from "react";
import { Form } from "react-final-form";
import arrayMutators from "final-form-arrays";
import { default as createDecorator } from "final-form-focus";
import { default as createCalculator } from "final-form-calculate";
import axios from "axios";

// src/components/TryItConsole/styled.elements.tsx
var Close = styled_components_default.div`
  cursor: pointer;
  font-size: 24px;
  font-weight: bold;
  color: rgb(245, 247, 250);
`;
var Header = styled_components_default.div`
  position: relative;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
  white-space: nowrap;
  border-radius: 8px 8px 0 0;
  pointer-events: auto;
  cursor: default;

  color: rgb(245, 247, 250);
  background-color: rgb(50, 63, 75);
  line-height: 30px;
  padding: 10px 20px;

  > div {
    display: flex;
    font-size: 12px;
  }

  button {
    margin: 0;
  }
`;
var HeaderButton = styled_components_default.button`
  outline: none;
  border-color: transparent currentColor;
  border-style: solid none;
  border-width: 4px medium;
  border-image: none 100% / 1 / 0 stretch;
  text-align: center;
  min-width: 80px;
  min-height: 30px;
  font-size: 12px;
  padding: 0 10px;
  background-color: rgb(82, 96, 109);
  cursor: pointer;
  color: rgba(245, 247, 250, 0.7);

  ${(props) => props.active && css`
      background-color: rgb(71, 83, 94);
      color: rgb(245, 247, 250);
      border-color: transparent currentColor ${({ theme: theme2 }) => theme2.colors.primary.light};
    `}

  &:disabled {
    cursor: default;
  }

  &:first-child {
    border-radius: 4px 0 0 4px;
  }

  &:last-child {
    border-radius: 0 4px 4px 0;
  }
`;
var IntRequestBody = styled_components_default.div`
  flex: 1;
  padding: 20px 20px 15px;
  overflow: auto;
  display: flex;
  flex-direction: column;
  position: relative;
  background-color: rgb(82, 96, 109);

  .cm-editor {
    background-color: rgb(50, 63, 75) !important;
    color: rgb(245, 247, 250) !important;
    padding: 10px;
  }

  .cm-scroller {
    font-family: inherit;
    line-height: 18px;
  }
`;
var ResponseBody = styled_components_default.div`
  flex: 1;
  padding: 20px 20px 15px;
  overflow: auto;
  display: flex;
  flex-direction: column;
  position: relative;
  background-color: rgb(82, 96, 109);
`;
var StatusRow = styled_components_default.div`
  margin-bottom: 10px;
`;
var Meta = styled_components_default.span`
  display: inline-block;
  margin-right: 20px;
  padding: 2px 0;
  text-align: center;
  color: rgb(245, 247, 250);

  ${({ color, theme: theme2 }) => color && css`
      color: ${color && theme2.colors.responses[color] && theme2.colors.responses[color].color || color};
    `}
`;
var HeadersSnippet = styled_components_default.pre`
  border-radius: 0 0 4px;
  overflow-x: auto;
  margin: 0;
  font: inherit;
  padding: 20px;
  background-color: rgb(50, 63, 75);
  color: rgb(245, 247, 250);
  font-size: 13px;
  white-space: pre;

  strong {
    text-transform: capitalize;
    display: inline-block;
    padding-right: 5px;
  }
`;
var Title = styled_components_default.div`
  margin-bottom: 10px;

  &:not(:first-child) {
    margin-top: 10px;
  }
`;
var SectionHeader = styled_components_default.div`
  position: relative;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
  white-space: nowrap;
  cursor: pointer;
  border-radius: ${({ expanded }) => expanded ? "8px 8px 0 0" : "8px"};
  pointer-events: auto;

  color: white;
  border: 1px solid rgb(137, 148, 159);
  padding: 10px;
`;
var Section2 = styled_components_default.div`
  &:not(:last-child) {
    margin-bottom: 10px;
  }
`;
var SectionHeaderText = styled_components_default.div`
  display: inline-flex;
  align-items: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  > span {
    line-height: 1;
    margin-right: 4px;
    font-weight: 700;
    color: rgb(245, 247, 250);
  }
`;
var expand = keyframes`
  0% {
    max-height: 0;
  }
  100% {
    max-height: unset;
  }
`;
var collapse = keyframes`
  0% {
    max-height: unset;
  }
  100% {
    max-height: 0;
  }
`;
var SectionContent = styled_components_default.div`
  animation: 0.2s ease ${collapse};
  visibility: hidden;
  border-radius: 0 0 8px 8px;
  background-color: rgb(62, 76, 89);
  border-color: currentColor rgb(137, 148, 159) rgb(137, 148, 159);
  border-style: none solid solid;
  border-width: 0 1px 1px;
  border-image: none 100% / 1 / 0 stretch;
  max-height: 0;
  overflow: hidden;

  ${({ expanded }) => expanded && css`
      padding: 15px 10px;
      animation: 0.2s ease ${expand};
      visibility: visible;
      max-height: unset;
    `}
`;
var SectionTitle = styled_components_default.div`
  width: 100%;
  display: flex;
  flex-direction: column;
  margin-bottom: 10px;
  color: rgb(150, 154, 154);
  font-size: 1em;
  font-weight: normal;
  text-align: left;
`;
var Tab2 = styled_components_default.div`
  flex: 1;
  padding: 20px 20px 15px;
  overflow: auto;
  display: flex;
  flex-direction: column;
  position: relative;
  background-color: rgb(82, 96, 109);
`;

// src/components/Endpoint/styled.elements.ts
var OperationEndpointWrap = styled_components_default.div`
  cursor: pointer;
  position: relative;
  padding: 10px 20px;
  line-height: 30px;
  min-height: 50px;
  background-color: ${(props) => props.$inverted ? "transparent" : "rgb(50, 63, 75)"};

  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
  pointer-events: auto;
  border-radius: 8px;
  ${(props) => props.$expanded && css`
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    `}

  ${(props) => props.$tryItExpanded && css`
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    `}
`;
var ServerRelativeURL = styled_components_default.span`
  margin: 0 4px;
  color: rgb(245, 247, 250);
  overflow-x: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow-wrap: normal;
  display: inline-block;
  max-height: 90px;
  word-break: break-all;

  ${(props) => props.$wrap && css`
      white-space: normal;
      overflow-wrap: anywhere;
    `}
`;
var EndpointInfo = styled_components_default.span`
  display: inline-flex;
  align-items: center;
  overflow-x: hidden;
  padding-right: 4px;

  &:focus {
    box-shadow: inset 0 2px 2px rgba(0, 0, 0, 0.45), 0 2px 0 rgba(128, 128, 128, 0.25);
  }
`;
var HttpVerb = styled_components_default.span.attrs((props) => ({
  className: `http-verb ${props.type}`
}))`
  font-size: ${(props) => props.$compact ? "0.8em" : "12px"};
  line-height: ${(props) => props.$compact ? "18px" : "20px"};
  background-color: ${(props) => props.theme.colors.http[props.type] || "#999999"};
  color: rgb(245, 247, 250);
  display: inline-block;
  text-align: center;
  padding: ${(props) => props.$compact ? "2px 8px" : "0 8px"};
  text-transform: uppercase;
  font-family: ${(props) => props.theme.typography.headings.fontFamily};
  margin: 0;
  border-radius: 16px;
  min-width: 58px;
  font-weight: 600;
`;
var Servers = styled_components_default.div`
  padding: 10px 20px 20px;
  background: ${(props) => props.theme.rightPanel.servers.overlay.backgroundColor};
  color: ${(props) => props.theme.rightPanel.servers.overlay.textColor};
  border-radius: 0 0 8px 8px;
  box-sizing: border-box;
  transition: all 0.25s ease;
`;
var ServerItem = styled_components_default.div`
  padding: 10px;
`;
var ServerUrl = styled_components_default.div`
  padding: 5px;
  border: 1px solid #ccc;
  background: ${(props) => props.theme.rightPanel.servers.url.backgroundColor};
  word-break: break-all;
  color: ${(props) => props.theme.colors.primary.main};
  > span {
    color: ${(props) => props.theme.colors.text.primary};
  }
`;
var TryItButton = styled_components_default.button`
  width: auto;
  text-decoration: none;
  text-align: center;
  outline: none;
  border: none;
  border-radius: 4px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.25s ease 0s, border-color 0.25s ease 0s, box-shadow 0.25s ease 0s;
  line-height: 1;
  font-family: inherit;
  box-shadow: none;
  background-color: ${(props) => props.theme.colors.primary.main};
  color: ${(props) => props.theme.colors.primary.contrastText};
  font-size: 14px;
  padding: 8px 20px;
  min-width: 120px;
`;

// src/components/TryItConsole/RequestBody.tsx
import React40 from "react";
import { Field as Field4, useFormState } from "react-final-form";

// src/components/TryItConsole/Auths.tsx
import React37 from "react";
import { useMemo } from "react";
import { Field as Field2 } from "react-final-form";
import validator from "validator";
import { jsx as jsx45, jsxs as jsxs32 } from "react/jsx-runtime";
var required = (value) => !value && value !== 0 || validator.isEmpty(`${value}`.trim()) ? "Field is required" : void 0;
var Auths = ({ definitions }) => {
  const nonOauthDefinitions = useMemo(
    () => definitions.filter((schema) => schema.type !== "oauth2"),
    [definitions]
  );
  return /* @__PURE__ */ jsx45("div", { children: nonOauthDefinitions.length > 0 && nonOauthDefinitions.map((schema, index2) => /* @__PURE__ */ jsxs32(React37.Fragment, { children: [
    schema.type === "apiKey" && /* @__PURE__ */ jsx45("div", { children: /* @__PURE__ */ jsx45(Field2, { name: "auth.ApiKeyAuth", validate: required, children: ({ input, meta: meta2 }) => /* @__PURE__ */ jsx45(
      Input,
      {
        input,
        meta: meta2,
        inputType: "password",
        required: true,
        label: schema.name
      }
    ) }) }, index2),
    schema.type === "http" && /* @__PURE__ */ jsxs32("div", { children: [
      /* @__PURE__ */ jsx45(Field2, { name: "auth.basic.username", validate: required, children: ({ input, meta: meta2 }) => /* @__PURE__ */ jsx45(Input, { input, meta: meta2, label: "Username", required: true }) }),
      /* @__PURE__ */ jsx45(Field2, { name: "auth.basic.password", validate: required, children: ({ input, meta: meta2 }) => /* @__PURE__ */ jsx45(
        Input,
        {
          input,
          meta: meta2,
          label: "Password",
          inputType: "password",
          required: true
        }
      ) })
    ] }, index2)
  ] }, index2)) });
};
var Auths_default = React37.memo(Auths);

// node_modules/@uiw/react-codemirror/esm/index.js
var import_extends = __toESM(require_extends(), 1);
var import_objectWithoutPropertiesLoose = __toESM(require_objectWithoutPropertiesLoose(), 1);
import React38, { useRef as useRef2, forwardRef, useImperativeHandle, useCallback as useCallback2 } from "react";

// node_modules/@uiw/react-codemirror/esm/useCodeMirror.js
import { useEffect as useEffect3, useLayoutEffect, useState as useState3 } from "react";

// node_modules/@marijn/find-cluster-break/src/index.js
var rangeFrom = [];
var rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 0, n = 0; i < numbers.length; i++)
    (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = from + to >> 1;
    if (code < rangeFrom[mid]) to = mid;
    else if (code >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text2) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text2.length)
      text2.decompose(
        0,
        text2.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text2.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text2) {
    if (text2.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text2.length == 1 && !text2[0])
      return _Text.empty;
    return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text2, length = textLength(text2)) {
    super();
    this.text = text2;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text2 = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text2.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text2);
    }
  }
  replace(from, to, text2) {
    if (!(text2 instanceof _TextLeaf))
      return super.replace(from, to, text2);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text2.length - (to - from);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text2, target) {
    let part = [], len = -1;
    for (let line of text2) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text2) {
    [from, to] = clip(this, from, to);
    if (text2.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text2);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new _TextNode(copy, this.length - (to - from) + text2.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text2);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l2, ch) => l2 + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add3(child) {
      let last;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children)
          add3(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add3(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text2) {
  let length = -1;
  for (let line of text2)
    length += line.length + 1;
  return length;
}
function appendText(text2, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text2.length && pos <= to; i++) {
    let line = text2[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text2, from, to) {
  return appendText(text2, [""], from, to);
}
var RawTextCursor = class {
  constructor(text2, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text2];
    this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text2, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text2, start > end ? -1 : 1);
    this.pos = start > end ? text2.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done: done2, lineBreak, value } = this.inner.next(skip);
    if (done2 && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done2) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to, number2, text2) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text2;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text2, from, to) {
  from = Math.max(0, Math.min(text2.length, from));
  return [from, Math.max(from, Math.min(text2.length, to))];
}
function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak(str, pos, forward, includeExtending);
}
function surrogateLow2(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh2(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt2(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh2(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow2(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize2(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2) || json2.length % 2 || json2.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json2);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index2 = i >> 1;
        while (inserted.length < index2)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i = 0, pos = 0; ; ) {
      let next = i == ranges.length ? 1e9 : ranges[i++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json2.length; i++) {
      let part = json2[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (last >= 0 && len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index2 = sections.length - 2 >> 1;
  if (index2 < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index2)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text2 = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text2 = text2.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text2);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.done && b.len || b.done && a.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text.empty : inserted[index2];
  }
  textBit(len) {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level2 = this.flags & 7;
    return level2 == 7 ? null : level2;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json2) {
    if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json2.anchor, json2.head);
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new _SelectionRange(from, to, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json2) {
    if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json2.ranges.map((r) => SelectionRange.fromJSON(r)), json2.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i], prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection2, docLength) {
  for (let range of selection2.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config3 = {}) {
    return new _Facet(config3.combine || ((a) => a), config3.compareInput || ((a, b) => a === b), config3.compare || (!config3.combine ? sameArray : (a, b) => a === b), !!config3.static, config3.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
};
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = /* @__PURE__ */ Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config3) {
    let field = new _StateField(nextID++, config3.create, config3.update, config3.compare || ((a, b) => a === b), config3);
    if (config3.provide)
      field.provides = config3.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i) => i.field == this)) && reInit != oldInit.find((i) => i.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create2) {
    return [this, initField.of({ field: this, create: create2 })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = /* @__PURE__ */ Facet.define();
var allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = /* @__PURE__ */ Facet.define();
var transactionFilter = /* @__PURE__ */ Facet.define();
var transactionExtender = /* @__PURE__ */ Facet.define();
var readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView3) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection2;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView3;
    this._doc = null;
    this._state = null;
    if (selection2)
      checkSelection(selection2, changes.newLength);
    if (!annotations.some((a) => a.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection2, effects, annotations, scrollIntoView3) {
    return new _Transaction(startState, changes, selection2, effects, annotations, scrollIntoView3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e = this.annotation(_Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
};
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config3, doc2, selection2, values, computeSlot, tr) {
    this.config = config3;
    this.doc = doc2;
    this.selection = selection2;
    this.values = values;
    this.status = config3.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key2) => compartments.set(key2, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new _EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text2) {
    if (typeof text2 == "string")
      text2 = this.toText(text2);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text2 },
      range: EditorSelection.cursor(range.from + text2.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json2, config3 = {}, fields) {
    if (!json2 || typeof json2.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json2, prop)) {
          let field = fields[prop], value = json2[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json2.doc,
      selection: EditorSelection.fromJSON(json2.selection),
      extensions: config3.extensions ? fieldInit.concat([config3.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config3 = {}) {
    let configuration = Configuration.resolve(config3.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config3.doc instanceof Text ? config3.doc : Text.of((config3.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection2 = !config3.selection ? EditorSelection.single(0) : config3.selection instanceof EditorSelection ? config3.selection : EditorSelection.single(config3.selection.anchor, config3.selection.head);
    checkSelection(selection2, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection2 = selection2.asSingle();
    return new _EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == "$")
          return "$";
        let n = +(i || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text: text2, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak2(text2, start, false);
      if (cat(text2.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak2(text2, end);
      if (cat(text2.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults4, combine = {}) {
  let result = {};
  for (let config3 of configs)
    for (let key2 of Object.keys(config3)) {
      let value = config3[key2], current = result[key2];
      if (current === void 0)
        result[key2] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key2))
        result[key2] = combine[key2](current, value);
      else
        throw new Error("Config merge conflict for field " + key2);
    }
  for (let key2 in defaults4)
    if (result[key2] === void 0)
      result[key2] = defaults4[key2];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range.create(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class _Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new _Range(from, to, value);
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add3 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add3.length == 0 && !filter)
      return this;
    if (sort)
      add3 = add3.slice().sort(cmpRange);
    if (this.isEmpty)
      return add3.length ? _RangeSet.of(add3) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder2 = new RangeSetBuilder();
    while (cur2.value || i < add3.length) {
      if (i < add3.length && (cur2.from - add3[i].from || cur2.startSide - add3[i].value.startSide) >= 0) {
        let range = add3[i++];
        if (!builder2.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add3.length || this.chunkEnd(cur2.chunkIndex) < add3[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder2.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder2.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder2.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to);
        let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
        openRanges = Math.min(cursor2.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges);
        openRanges = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
      pos = cursor2.to;
      cursor2.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return _RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i = sets.length - 2; i >= 0; i--) {
      for (let layer2 = sets[i]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
        result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
};
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint <= 0)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
        shared.add(set.chunk[i]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index2;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index2] = child;
    index2 = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove(this.active, index2);
    remove(this.activeTo, index2);
    remove(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
};
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)
      comparator.boundChange(end);
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove(array, index2) {
  for (let i = index2, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index2, value) {
  for (let i = array.length - 1; i >= index2; i--)
    array[i + 1] = array[i];
  array[index2] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n = 0;
  for (let i = 0; i < to && i < string2.length; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak2(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak2(string2, i);
  }
  return strict === true ? -1 : string2.length;
}

// node_modules/style-mod/src/style-mod.js
var C = "\u037C";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options2) {
    this.rules = [];
    let { finish } = options2 || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes2 = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes2);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l2) => "-" + l2.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes2) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options2) {
    let set = root[SET], nonce = options2 && options2.nonce;
    if (!set) set = new StyleSet(root, nonce);
    else if (nonce) set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules], root);
  }
};
var adoptedSet = /* @__PURE__ */ new Map();
var StyleSet = class {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index2 = this.modules.indexOf(mod);
      if (index2 < j && index2 > -1) {
        this.modules.splice(index2, 1);
        j--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index2) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text2 = "";
      for (let i = 0; i < this.modules.length; i++)
        text2 += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text2;
      let target = root.head || root;
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
};

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains(dom, selection2.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        };
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x, y;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x && y) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y && cur2.scrollHeight > cur2.clientHeight)
        y = cur2;
      if (!x && cur2.scrollWidth > cur2.clientWidth)
        x = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return { x, y };
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name2, code, mods) {
  let options2 = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  if (mods)
    ({ altKey: options2.altKey, ctrlKey: options2.ctrlKey, shiftKey: options2.shiftKey, metaKey: options2.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options2);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options2);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length)
    node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc2, selection2) {
  let node = selection2.focusNode, offset = selection2.focusOffset;
  if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node));
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
var DOMPos = class _DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var noChildren = [];
var ContentView = class _ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = _ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom)
            next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm$1(next);
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !_ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.flags |= 2;
      if (parent.flags & 1)
        return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom)
      return;
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from, to, children = noChildren) {
    this.markDirty();
    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this && children.indexOf(child) < 0)
        child.destroy();
    }
    if (children.length < 250)
      this.children.splice(from, to - from, ...children);
    else
      this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
    for (let i = 0; i < children.length; i++)
      children[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let child of this.children)
      if (child.parent == this)
        child.destroy();
    this.parent = null;
  }
};
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ChildCursor = class {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before = children.length ? children[fromI] : null;
  let last = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
  let dLen = from - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var MaxJoinLen = 256;
var TextView = class _TextView extends ContentView {
  constructor(text2) {
    super();
    this.text = text2;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from, to, source) {
    if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new _TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    result.flags |= this.flags & 8;
    return result;
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class _MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch of children)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4)
      this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [], off = 0, detachFrom = -1, i = 0;
    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from)
        result.push(off < from ? elt.split(from - off) : elt);
      if (detachFrom < 0 && off >= from)
        detachFrom = i;
      off = end;
      i++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new _MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text2, pos, side) {
  let length = text2.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else if (to < length) {
        to++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else if (to < length)
      to++;
  }
  let rects = textRange(text2, from, to).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
}
var WidgetView = class _WidgetView extends ContentView {
  static create(widget, length, side) {
    return new _WidgetView(widget, length, side);
  }
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  split(from) {
    let result = _WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let { view } = top2, text2 = view && view.state.doc, start = this.posAtStart;
    return text2 ? text2.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
      rect = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
};
var WidgetBufferView = class _WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof _WidgetBufferView && other.side == this.side;
  }
  split() {
    return new _WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return true;
  }
};
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children } = parent, i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j = i; j > 0; j--) {
    let prev = children[j - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j = i; j < children.length; j++) {
    let next = children[j];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
      let child = view2.children[i], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if ((!after || after.isHidden && (side > 0 || onSameLine(after, child))) && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function onSameLine(a, b) {
  let posA = a.coordsAt(0, 1), posB = b.coordsAt(0, 1);
  return posA && posB && posB.top < posA.bottom;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
var noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a, b, ignore) {
  if (a == b)
    return true;
  if (!a)
    a = noAttrs;
  if (!b)
    b = noAttrs;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
    return false;
  for (let key2 of keysA) {
    if (key2 != ignore && (keysB.indexOf(key2) == -1 || a[key2] !== b[key2]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < dom.attributes.length; i++) {
    let attr = dom.attributes[i];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block2 = !!spec.block;
    side += block2 && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block2, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block2 = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block2);
      startSide = (start ? block2 ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block2 ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block2, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a2, _b;
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block2, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block2;
    this.isReplace = isReplace;
    this.mapMode = !block2 ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block2 = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block2, end: end !== null && end !== void 0 ? end : block2 };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
var LineView = class _LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof _LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new _LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i].split(off), 0);
      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
      i++;
    }
    for (let j = i; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i > 0 && this.children[i - 1].length == 0)
      this.children[--i].destroy();
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a2;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView)
      last = last.lastChild;
    if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
      }
    }
    return rect;
  }
  become(other) {
    return other instanceof _LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; i < docView.children.length; i++) {
      let block2 = docView.children[i], end = off + block2.length;
      if (end >= pos) {
        if (block2 instanceof _LineView)
          return block2;
        if (end > pos)
          break;
      }
      off = end + block2.breakAfter;
    }
    return null;
  }
};
var BlockWidgetView = class _BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super();
    this.widget = widget;
    this.length = length;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new _BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    if (this.widget instanceof BlockGapWidget)
      return null;
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
  covers(side) {
    let { startSide, endSide } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
};
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
var ContentBuilder = class _ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
      this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done: done2 } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done2)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to, deco, active, openStart, index2) {
    if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
      } else {
        let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text2, from, to, decorations2, dynamicDecorationMap) {
    let builder2 = new _ContentBuilder(text2, from, to, dynamicDecorationMap);
    builder2.openEnd = RangeSet.spans(decorations2, from, to, builder2);
    if (builder2.openStart < 0)
      builder2.openStart = builder2.openEnd;
    builder2.finish(builder2.openEnd);
    return builder2;
  }
};
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
NullWidget.block = /* @__PURE__ */ new NullWidget("div");
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l2 = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l2] = r;
  Brackets[r] = -l2;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to, level2) {
    this.from = from;
    this.to = to;
    this.level = level2;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index2, level2, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level2)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
function isolatesEq(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    let iA = a[i], iB = b[i];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
var types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < to - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace2;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from, ch, br, type; i < to; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from; i < to; ) {
      let type = types[i];
      if (type == 256) {
        let end = i + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i = end;
      } else {
        prev = type;
        i++;
      }
    }
  }
}
function emitSpans(line, from, to, level2, baseLevel, isolates, order) {
  let ourType = level2 % 2 ? 2 : 1;
  if (level2 % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level2 : level2 + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level2 + 1 : level2, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level2 + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level2 : level2 + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level2 + 1 : level2, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level2 + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level2, baseLevel, isolates, from, to, order) {
  let outerType = level2 % 2 ? 2 : 1;
  computeCharTypes(line, from, to, isolates, outerType);
  processBracketPairs(line, from, to, isolates, outerType);
  processNeutrals(from, to, isolates, outerType);
  emitSpans(line, from, to, level2, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level2 = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level2, level2, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak2(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text2, from, to) {
  for (let i = from; i < to; i++) {
    let type = charType(text2.charCodeAt(i));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
var exceptionSink = /* @__PURE__ */ Facet.define();
var updateListener = /* @__PURE__ */ Facet.define();
var inputHandler = /* @__PURE__ */ Facet.define();
var focusChangeEffect = /* @__PURE__ */ Facet.define();
var clipboardInputFilter = /* @__PURE__ */ Facet.define();
var clipboardOutputFilter = /* @__PURE__ */ Facet.define();
var perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
var scrollHandler = /* @__PURE__ */ Facet.define();
var ScrollTarget = class _ScrollTarget {
  constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
var setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
var nextPluginID = 0;
var viewPlugin = /* @__PURE__ */ Facet.define();
var ViewPlugin = class _ViewPlugin {
  constructor(id, create2, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create2, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new _ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin) => {
      let ext = [viewPlugin.of(plugin)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return _ViewPlugin.define((view) => new cls(view), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = /* @__PURE__ */ Facet.define();
var contentAttributes = /* @__PURE__ */ Facet.define();
var decorations = /* @__PURE__ */ Facet.define();
var outerDecorations = /* @__PURE__ */ Facet.define();
var atomicRanges = /* @__PURE__ */ Facet.define();
var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i) => i instanceof Function ? i(view) : i);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to = toDoc - line.from;
      let level2 = result;
      for (let i = active.length - 1; i >= 0; i--, open--) {
        let direction = active[i].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from, to);
        if (open > 0 && level2.length && (update = level2[level2.length - 1]).to == from && update.direction == direction) {
          update.to = to;
          level2 = update.inner;
        } else {
          let add3 = { from, to, direction, inner: [] };
          level2.push(add3);
          level2 = add3.inner;
        }
      }
    }
  });
  return result;
}
var scrollMargins = /* @__PURE__ */ Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m = source(view);
    if (m) {
      if (m.left != null)
        left = Math.max(left, m.left);
      if (m.right != null)
        right = Math.max(right, m.right);
      if (m.top != null)
        top2 = Math.max(top2, m.top);
      if (m.bottom != null)
        bottom = Math.max(bottom, m.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
var styleModule = /* @__PURE__ */ Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length, me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to);
        if (fromB <= toB)
          new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from, to } = this.hasComposition;
      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let { observer: observer27 } = this.view;
    observer27.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer27.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer27.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer27.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor2 = this.childCursor(oldLength);
    for (let i = ranges.length - 1; ; i--) {
      let next = i >= 0 ? ranges[i] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before.breakAtStart;
        openStart = before.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
          before.content.pop();
        }
        content2 = before.content.concat(compLine).concat(after.content);
      } else {
        ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
    if (composition)
      this.fixCompositionDOM(composition);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  compositionView(composition) {
    let cur2 = new TextView(composition.text.nodeValue);
    cur2.flags |= 8;
    for (let { deco } of composition.marks)
      cur2 = new MarkView(deco, [cur2], cur2.length);
    let line = new LineView();
    line.append(cur2, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c) => c.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev = ContentView.get(dom);
      if (prev && prev != cView2)
        prev.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i = composition.marks.length - 1; i >= -1; i--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text2 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text2)
                anchor = new DOMPos(text2.node, text2.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor2 = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor2.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom)
      return pos;
    for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
      let view = ContentView.get(dom.childNodes[i]);
      if (view instanceof LineView)
        newPos = view.domAtPos(0);
    }
    for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
      let view = ContentView.get(dom.childNodes[i]);
      if (view instanceof LineView)
        newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i, off } = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1; ) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView)
        break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
      let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
      if (end < pos)
        break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
        if (child.deco.startSide < 0)
          break;
        else if (i)
          best = null;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let { i, off } = this.childPos(pos, 1), child = this.children[i];
    if (!(child instanceof LineView))
      return null;
    while (child.children.length) {
      let { i: i2, off: childOff } = child.childPos(off, 1);
      for (; ; i2++) {
        if (i2 == child.children.length)
          return null;
        if ((child = child.children[i2]).length)
          break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView))
      return null;
    let end = findClusterBreak2(child.text, off);
    if (end == off)
      return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (i2 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
        return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  childCursor(pos = this.length) {
    let i = this.children.length;
    if (i)
      pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i = 1;
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i2) => {
      let dynamic = typeof d == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d(this.view) : d;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i < this.decorations.length)
      this.dynamicDecorationMap[i++] = false;
    return this.decorations;
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target))
          return true;
      } catch (e) {
        logException(this.view.state, e, "scroll handler");
      }
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to } = found, text2 = textNode.nodeValue;
  if (/[\n\r]/.test(text2))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text2)
    return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
  let marks2 = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks2.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range, text: textNode, marks: marks2, line: parent };
    else if (parent != view.contentDOM)
      marks2.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak2(line.text, linePos, false);
  else
    to = findClusterBreak2(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak2(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak2(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i + (after ? 1 : 0) };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2, _b;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block2, { docHeight } = view.viewState;
  let { x, y } = coords, yOffset = y - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block2 = view.elementAtHeight(yOffset);
    if (block2.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block2.bottom + halfLine : block2.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block2.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block2, x, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block2, x, y);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node, offset = -1;
  if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        ({ offsetNode: node, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x, y);
      if (range) {
        ({ startContainer: node, startOffset: offset } = range);
        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
          node = void 0;
      }
    }
    if (node)
      offset = Math.min(maxOffset(node), offset);
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block2.top + block2.height / 2 ? block2.to : block2.from;
    ({ node, offset } = domPosAtCoords(line.dom, x, y));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block2, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block2.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block2.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block2.from, block2.to);
  return block2.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function isSuspiciousChromeCaretResult(node, offset, x) {
  if (offset != 0)
    return false;
  for (let cur2 = node; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x - rect.left > 5;
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    let best;
    for (let l2 of line.type) {
      if (l2.from > pos)
        break;
      if (l2.to < pos)
        continue;
      if (l2.from < pos && l2.to > pos)
        return l2;
      if (!best || l2.type == BlockType.Text && (best.type != l2.type || (side < 0 ? l2.from < pos : l2.to > pos)))
        best = l2;
    }
    return best || line;
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1);
          pos = side < 0 ? from : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
var LineBreakPlaceholder = "\uFFFF";
var DOMReader = class {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text2) {
    this.text += text2;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen)
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text2 = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text2.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text2.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re.exec(text2)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak)
          this.lineBreak();
        else
          this.append(i.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, length) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
  }
};
function isAtEnd(parent, node, offset) {
  for (; ; ) {
    if (!node || offset < maxOffset(node))
      return false;
    if (node == parent)
      return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
var DOMChange = class {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from = Math.min(head, anchor), to = Math.max(head, anchor);
        let offFrom = vp.from - from, offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = EditorSelection.single(anchor, head);
    }
  }
};
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text2 = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text2, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to, size = sel.to - sel.from;
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset, from = to - replaced.length;
        if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range.to >= compositionRange.from && range.from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var InputState = class {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    if (this.view.updateState != 0)
      Promise.resolve().then(() => this.runHandlers(event.type, event));
    else
      this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer27 of handlers2.observers)
        observer27(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key2) => key2.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key2 = this.pendingIOSKey;
    if (!key2)
      return false;
    if (key2.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key2.key, key2.keyCode, key2 instanceof KeyboardEvent ? key2 : void 0);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view);
    } catch (e) {
      logException(view.state, e);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin of plugins) {
    let spec = plugin.spec;
    if (spec && spec.domEventHandlers)
      for (let type in spec.domEventHandlers) {
        let f = spec.domEventHandlers[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin.value, f));
      }
    if (spec && spec.domEventObservers)
      for (let type in spec.domEventObservers) {
        let f = spec.domEventObservers[type];
        if (f)
          record(type).observers.push(bindHandler(plugin.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
var PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event.clientX);
    else if (event.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event.clientY);
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x, y } = this.scrollSpeed;
    if (x && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x;
      x = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x || y)
      this.view.win.scrollBy(x, y);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i = 0; i < sel.ranges.length; i++) {
      let range = sel.ranges[i], updated = null;
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0);
        if (pos != range.from)
          updated = EditorSelection.cursor(pos, -1);
      } else {
        let from = skipAtomicRanges(this.atoms, range.from, -1);
        let to = skipAtomicRanges(this.atoms, range.to, 1);
        if (from != range.from || to != range.to)
          updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
      }
      if (updated) {
        if (!ranges)
          ranges = sel.ranges.slice();
        ranges[i] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event) {
    let { view } = this, selection2 = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var observers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text2) {
  for (let filter of state.facet(facet))
    text2 = filter(text2, state);
  return text2;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let { state } = view, changes, i = 1, text2 = state.toText(input);
  let byLine = text2.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text2.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text2.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text2.line(i++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text2);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
var inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend, multiple) {
      let cur2 = queryPos(view, event2), removed;
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i = 0; i < sel.ranges.length; i++) {
    let { from, to } = sel.ranges[i];
    if (from <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main: range } } = view.state;
  if (event.target.draggable) {
    let cView = view.docView.nearest(event.target);
    if (cView && cView.isWidget) {
      let from = cView.posAtStart, to = from + cView.length;
      if (from >= range.to || to <= range.from)
        range = EditorSelection.range(from, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text2, direct) {
  text2 = textFilter(view.state, clipboardInputFilter, text2);
  if (!text2)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text2 };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text2 = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text2.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text2[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
    return true;
  } else {
    let text2 = event.dataTransfer.getData("Text");
    if (text2) {
      dropText(view, event, text2, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text2) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text2;
  target.focus();
  target.selectionEnd = text2.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text: text2, ranges, linewise } = copiedRange(view.state);
  if (!text2 && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text2 : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text2);
    return true;
  } else {
    captureCopy(view, text2);
    return false;
  }
};
var isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2, _b;
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text2 = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
    if (text2 && ranges.length) {
      let r = ranges[0];
      let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
      applyDOMChangeInner(view, { from, to, insert: view.state.toText(text2) }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key2) => key2.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
var appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
};
var QueryType = /* @__PURE__ */ function(QueryType3) {
  QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
  QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
  QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType3;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i)), brk, _HeightMap.of(nodes.slice(j)));
  }
};
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    if (from <= offset + this.length && to >= offset)
      f(this.blockAt(0, oracle, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new _HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    from = Math.max(from, offset);
    to = Math.min(to, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof _HeightMapGap)
        nodes[nodes.length - 1] = new _HeightMapGap(last.length + after);
      else
        nodes.push(null, new _HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap)
        nodes[0] = new _HeightMapGap(from + first.length);
      else
        nodes.unshift(new _HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new _HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new _HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, oracle, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block2) {
    this.enterLine();
    let deco = block2.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block2);
    this.writtenTo = this.pos = this.pos + block2.length;
    if (deco && deco.endSide > 0)
      this.covering = block2;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder2 = new _NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder2, 0);
    return builder2.finish(from);
  }
};
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt) {
  let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to, size, displaySize) {
    this.from = from;
    this.to = to;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i = 0; i < 2; i++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block2) => {
      this.viewportLines.push(scaleBlock(block2, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = prevHeight;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges(update.changes);
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2)
        result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block2 = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block2.top + block2.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block2.top;
        else
          topPos = block2.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from)
            to = lineStart;
        }
        let size = this.gapSize(line, from, to, structure);
        let displaySize = wrapping || size < 2e6 ? size : 2e6;
        gap = new LineGap(from, to, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i = 0; i < ranges.length && !(changed & 8); i++) {
        let old = this.visibleRanges[i], nw = ranges[i];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
            changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l2) => l2.top <= height && l2.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block2 = this.lineBlockAtHeight(scrollTop + 8);
    return block2.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block2 : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
function lineStructure(from, to, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i], size = to - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
var BigScaler = class _BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof _BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
  }
};
function scaleBlock(block2, scaler) {
  if (scaler.scale == 1)
    return block2;
  let bTop = scaler.toDOM(block2.top), bBottom = scaler.toDOM(block2.bottom);
  return new BlockInfo(block2.from, block2.length, bTop, bBottom - bTop, Array.isArray(block2._content) ? block2._content.map((b) => scaleBlock(b, scaler)) : block2._content);
}
var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
var baseThemeID = /* @__PURE__ */ StyleModule.newName();
var baseLightID = /* @__PURE__ */ StyleModule.newName();
var baseDarkID = /* @__PURE__ */ StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries2) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries2) => {
        if (entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection2 = getSelection(view.root);
    if (!selection2)
      return false;
    let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key2, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key3 = this.delayedAndroidKey;
        if (key3) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key3.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key3.force)
            dispatchKey(this.dom, key3.key, key3.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key2 == "Enter")
      this.delayedAndroidKey = {
        key: key2,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return { from, to, typeOver };
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection2) {
  if (selection2.getComposedRanges) {
    let range = selection2.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
var EditContextManager = class {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e) => {
      let main = view.state.selection.main, { anchor, head } = main;
      let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
      let change = { from, to, insert: Text.of(e.text.split("\n")) };
      if (change.from == this.from && anchor < this.from)
        change.from = anchor;
      else if (change.to == this.to && anchor > this.to)
        change.to = anchor;
      if (change.from == change.to && !change.insert.length) {
        let newSel = EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
        if (!newSel.main.eq(main))
          view.dispatch({ selection: newSel, userEvent: "select" });
        return;
      }
      if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
        change = { from, to, insert: Text.of([e.text.replace(".", " ")]) };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
    };
    this.handlers.characterboundsupdate = (e) => {
      let rects = [], prev = null;
      for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
        let rect = view.coordsForChar(i);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e) => {
      let deco = [];
      for (let format of e.getTextFormats()) {
        let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
        if (lineStyle != "None" && thickness != "None") {
          let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
          if (from < to) {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
          }
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let { drifted } = this.composing;
        this.composing = null;
        if (drifted)
          this.reset(view.state);
      }
    };
    for (let event in this.handlers)
      context.addEventListener(event, this.handlers[event]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen);
    let c = this.composing;
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c = this.composing;
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers)
      this.editContext.removeEventListener(event, this.handlers[event]);
  }
};
var EditorView = class _EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config3 = {}) {
    var _a2;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config3.parent)
      config3.parent.appendChild(this.dom);
    let { dispatch } = config3;
    this.dispatchTransactions = config3.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config3.root || getRoot(config3.parent) || document;
    this.viewState = new ViewState(config3.state || EditorState.create(config3));
    if (config3.scrollTo && config3.scrollTo.is(scrollIntoView))
      this.viewState.scrollTarget = config3.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
      document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e of tr.effects)
          if (e.is(scrollIntoView))
            scrollTarget = e.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e) {
          logException(this.state, e, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin of this.plugins) {
      let val = plugin.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e) {
          logException(this.state, e, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i = 0; ; i++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block2 = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block2.from;
            scrollAnchorHeight = block2.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2];
              if (m.write)
                m.write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(_EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(_EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.spec != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options2 = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to == "boolean")
      this.inputState.tabFocusMode = to ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options2) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options2 && options2.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c) => c.fresh))
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add3 = (scope, key2, command2, preventDefault, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key2.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b;
        for (let key2 in scopeObj)
          scopeObj[key2].run.push((view) => any(view, currentKeyEvent));
      }
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add3(scope, name2, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift)
        add3(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
var currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt2(name2, 0), isChar = codePointSize2(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside2) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside2;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y });
  let right = view.posAtCoords({ x: editorRect.right - 1, y });
  if (left == null || right == null)
    return inside2;
  return { from: Math.max(inside2.from, Math.min(left, right)), to: Math.min(inside2.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block2, top2) {
    let y = contentRect.top + (top2 ? block2.top : block2.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false)
      view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = /* @__PURE__ */ Facet.define();
function layer(config3) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config3)),
    layerOrder.of(config3)
  ];
}
var selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config3 = {}) {
  return [
    selectionConfig.of(config3),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
var cursorLayer = /* @__PURE__ */ layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      if (r.empty || conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor2 = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor2))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = /* @__PURE__ */ layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
}));
var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(pos, tr) {
    if (pos != null)
      pos = tr.changes.mapPos(pos);
    return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
  }
});
var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a2;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let { view } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let { scaleX, scaleY } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re, from, to, f) {
  re.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from, to), pos = from, m; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m = re.exec(cursor2.value))
        f(pos + m.index, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to;
    else
      result.push({ from, to });
  }
  return result;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config3) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config3;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add3) => decorate(add3, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add3) => {
        let deco = decoration(match, view, from);
        if (deco)
          add3(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add3) => add3(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add3 = build.add.bind(build);
    for (let { from, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add3));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportMoved || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r of view.visibleRanges) {
      let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
      if (to > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m;
        let add3 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
            this.addMatch(m, view, m.index + fromLine.from, add3);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add3));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
var Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var _supportsTabSize = null;
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let config3 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config3.replaceTabs = !supportsTabSize())
      config3.specialChars = new RegExp("	|" + config3.specialChars.source, UnicodeRegexpSupport);
    if (config3.addSpecialChars)
      config3.specialChars = new RegExp(config3.specialChars.source + "|" + config3.addSpecialChars.source, UnicodeRegexpSupport);
    return config3;
  }
});
function highlightSpecialChars(config3 = {}) {
  return [specialCharConfig.of(config3), specialCharPlugin()];
}
var _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let { doc: doc2 } = view.state;
          let code = codePointAt2(m[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
var DefaultPlaceholder = "\u2022";
function placeholder$1(code) {
  if (code >= 32)
    return DefaultPlaceholder;
  if (code == 10)
    return "\u2424";
  return String.fromCharCode(9216 + code);
}
var SpecialCharWidget = class extends WidgetType {
  constructor(options2, code) {
    super();
    this.options = options2;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom)
      return custom;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var TabWidget = class extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
function highlightActiveLine() {
  return activeLineHighlighter;
}
var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r of view.state.selection.ranges) {
      let line = view.lineBlockAt(r.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var Placeholder = class extends WidgetType {
  constructor(content2) {
    super();
    this.content = content2;
  }
  toDOM(view) {
    let wrap = document.createElement("span");
    wrap.className = "cm-placeholder";
    wrap.style.pointerEvents = "none";
    wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
    wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
    if (!rects.length)
      return null;
    let style = window.getComputedStyle(dom.parentNode);
    let rect = flattenRect(rects[0], style.direction != "rtl");
    let lineHeight = parseInt(style.lineHeight);
    if (rect.bottom - rect.top > lineHeight * 1.5)
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
    return rect;
  }
  ignoreEvent() {
    return false;
  }
};
function placeholder(content2) {
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]) : Decoration.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }
  }, { decorations: (v) => v.decorations });
  return typeof content2 == "string" ? [
    plugin,
    EditorView.contentAttributes.of({ "aria-placeholder": content2 })
  ] : plugin;
}
var MaxOff = 2e3;
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options2) {
  let filter = (options2 === null || options2 === void 0 ? void 0 : options2.eventFilter) || ((e) => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
var keys = {
  Alt: [18, (e) => !!e.altKey],
  Control: [17, (e) => !!e.ctrlKey],
  Shift: [16, (e) => !!e.shiftKey],
  Meta: [91, (e) => !!e.metaKey]
};
var showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options2 = {}) {
  let [code, getter] = keys[options2.key || "Alt"];
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e) {
        this.set(e.keyCode == code || getter(e));
      },
      keyup(e) {
        if (e.keyCode == code || !getter(e))
          this.set(false);
      },
      mousemove(e) {
        this.set(getter(e));
      }
    }
  });
  return [
    plugin,
    EditorView.contentAttributes.of((view) => {
      var _a2;
      return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
    })
  ];
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t2) => t2);
    let prev = null;
    this.tooltipViews = this.tooltips.map((t2) => prev = createTooltipView(t2, prev));
  }
  update(update, above) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips = input.filter((x) => x);
    if (input === this.input) {
      for (let t2 of this.tooltipViews)
        if (t2.update)
          t2.update(update);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i], known = -1;
      if (!tip)
        continue;
      for (let i2 = 0; i2 < this.tooltips.length; i2++) {
        let other = this.tooltips[i2];
        if (other && other.create == tip.create)
          known = i2;
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
        if (newAbove)
          newAbove[i] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (newAbove)
          newAbove[i] = above[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t2 of this.tooltipViews)
      if (tooltipViews.indexOf(t2) < 0) {
        this.removeTooltipView(t2);
        (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
    if (above) {
      newAbove.forEach((val, i) => above[i] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
var tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    var _a2, _b, _c;
    return {
      position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config3 = view.state.facet(tooltipConfig);
    this.position = config3.position;
    this.parent = config3.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t2, p) => this.createTooltip(t2, p), (t2) => {
      if (this.resizeObserver)
        this.resizeObserver.unobserve(t2.dom);
      t2.dom.remove();
    });
    this.above = this.manager.tooltips.map((t2) => !!t2.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries2) => {
      if (Date.now() > this.lastTransaction - 50 && entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t2 of this.manager.tooltipViews)
        this.container.appendChild(t2.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    if (this.resizeObserver)
      this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a2, _b, _c;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    if (this.parent)
      this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom } = this.manager.tooltipViews[0];
      if (browser.gecko) {
        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
      } else if (dom.style.top == Outside && dom.style.left == "0px") {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({ scaleX, scaleY } = this.view.viewState);
      }
    }
    let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
    return {
      visible: {
        left: visible.left + margins.left,
        top: visible.top + margins.top,
        right: visible.right - margins.right,
        bottom: visible.bottom - margins.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((t2, i) => {
        let tv = this.manager.tooltipViews[i];
        return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a2;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = "absolute";
    }
    let { visible, space, scaleX, scaleY } = measured;
    let others = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
      let pos = measured.pos[i], size = measured.size[i];
      if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - 0.1 || pos.left > Math.min(visible.right, space.right) + 0.1)) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
      let above = this.above[i];
      if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
        above = this.above[i] = !above;
      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r of others)
          if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
            top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
        setLeftStyle(dom, (left - measured.parent.left) / scaleX);
      } else {
        dom.style.top = top2 / scaleY + "px";
        setLeftStyle(dom, left / scaleX);
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function setLeftStyle(elt, value) {
  let current = parseInt(elt.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1)
    elt.style.left = value + "px";
}
var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = /* @__PURE__ */ Facet.define({
  combine: (inputs) => inputs.reduce((a, i) => a.concat(i), [])
});
var HoverTooltipHost = class _HoverTooltipHost {
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new _HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t2, p) => this.createHostedView(t2, p), (t2) => t2.dom.remove());
  }
  createHostedView(tooltip, prev) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned(space);
    }
  }
  update(update) {
    this.manager.update(update);
  }
  destroy() {
    var _a2;
    for (let t2 of this.manager.tooltipViews)
      (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
  }
  passProp(name2) {
    let value = void 0;
    for (let view of this.manager.tooltipViews) {
      let given = view[name2];
      if (given !== void 0) {
        if (value === void 0)
          value = given;
        else if (value !== given)
          return void 0;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
};
var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips = state.facet(showHoverTooltip);
  if (tooltips.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips.map((t2) => t2.pos)),
    end: Math.max(...tooltips.map((t2) => {
      var _a2;
      return (_a2 = t2.end) !== null && _a2 !== void 0 ? _a2 : t2.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips[0].above,
    arrow: tooltips.some((t2) => t2.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active.length)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view, lastMove } = this;
    let desc = view.docView.nearest(lastMove.target);
    if (!desc)
      return;
    let pos, side = 1;
    if (desc instanceof WidgetView) {
      pos = desc.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null)
        return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
        return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result && !(Array.isArray(result) && !result.length))
            view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
        }
      }, (e) => logException(view.state, e, "hover tooltip"));
    } else if (open && !(Array.isArray(open) && !open.length)) {
      view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
    }
  }
  get tooltip() {
    let plugin = this.view.plugin(tooltipPlugin);
    let index2 = plugin ? plugin.manager.tooltips.findIndex((t2) => t2.create == HoverTooltipHost.create) : -1;
    return index2 > -1 ? plugin.manager.tooltipViews[index2] : null;
  }
  mousemove(event) {
    var _a2, _b;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let { active, tooltip } = this;
    if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
      let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
        this.view.dispatch({ effects: this.setHover.of([]) });
        this.pending = null;
      }
    }
  }
  mouseleave(event) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let { active } = this;
    if (active.length) {
      let { tooltip } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
      if (!inTooltip)
        this.view.dispatch({ effects: this.setHover.of([]) });
      else
        this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch = (event) => {
      tooltip.removeEventListener("mouseleave", watch);
      if (this.active.length && !this.view.dom.contains(event.relatedTarget))
        this.view.dispatch({ effects: this.setHover.of([]) });
    };
    tooltip.addEventListener("mouseleave", watch);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
var tooltipMargin = 4;
function isInTooltip(tooltip, event) {
  let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top2 = Math.min(arrowRect.top, top2);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
    return false;
  let pos = view.posAtCoords({ x, y }, false);
  return pos >= from && pos <= to;
}
function hoverTooltip(source, options2 = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr) {
      if (value.length) {
        if (options2.hideOnChange && (tr.docChanged || tr.selection))
          value = [];
        else if (options2.hideOn)
          value = value.filter((v) => !options2.hideOn(tr, v));
        if (tr.docChanged) {
          let mapped = [];
          for (let tooltip of value) {
            let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
              copy.pos = newPos;
              if (copy.end != null)
                copy.end = tr.changes.mapPos(copy.end);
              mapped.push(copy);
            }
          }
          value = mapped;
        }
      }
      for (let effect of tr.effects) {
        if (effect.is(setHover))
          value = effect.value;
        if (effect.is(closeHoverTooltipEffect))
          value = [];
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  return {
    active: hoverState,
    extension: [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(
        view,
        source,
        hoverState,
        setHover,
        options2.hoverTime || 300
        /* Hover.Time */
      )),
      showHoverTooltipHost
    ]
  };
}
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin)
    return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
var panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index2 = plugin ? plugin.specs.indexOf(panel) : -1;
  return index2 > -1 ? plugin.panels[index2] : null;
}
var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s) => s);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
};
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var showPanel = /* @__PURE__ */ Facet.define({
  enables: panelPlugin
});
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = /* @__PURE__ */ Facet.define();
var gutterWidgetClass = /* @__PURE__ */ Facet.define();
var defaults2 = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config3) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults2), config3))];
}
var unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
function gutters(config3) {
  let result = [
    gutterView
  ];
  if (config3 && config3.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach)
      this.dom.remove();
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b of line.type) {
          if (b.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b.from);
            for (let cx of contexts)
              cx.line(this.view, b, classSet);
            first = false;
          } else if (b.widget) {
            for (let cx of contexts)
              cx.widget(this.view, b);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx of contexts)
          cx.widget(this.view, line);
      }
    }
    for (let cx of contexts)
      cx.finish();
    if (detach)
      this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  addElement(view, block2, markers) {
    let { gutter: gutter2 } = this, above = (block2.top - this.height) / view.scaleY, height = block2.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block2.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block2) {
    let marker = this.gutter.config.widgetMarker(view, block2.widget, block2), markers = marker ? [marker] : null;
    for (let cls of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls(view, block2.widget, block2);
      if (marker2)
        (markers || (markers = [])).push(marker2);
    }
    if (markers)
      this.addElement(view, block2, markers);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last = gutter2.elements.pop();
      gutter2.dom.removeChild(last.dom);
      last.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config3) {
    this.view = view;
    this.config = config3;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config3.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config3.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray2(config3.markers(view));
    if (config3.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config3.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt of this.elements)
      elt.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c)
          cls += " " + c;
        for (let i = iOld; i < this.markers.length; i++)
          if (this.markers[i].compare(marker)) {
            skipTo = i;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
var lineNumberMarkers = /* @__PURE__ */ Facet.define();
var lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
var lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add3 = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add3(view, line, event2) : add3;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block2) => {
    for (let m of view.state.facet(lineNumberWidgetMarker)) {
      let result = m(view, widget, block2);
      if (result)
        return result;
    }
    return null;
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config3 = {}) {
  return [
    lineNumberConfig.of(config3),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks2 = [], last = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks2.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks2);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range2 = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser3) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser3;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add3 = source(type);
        if (add3) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add3[0].id] = add3[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id in this.props)
        result.push([+id, this.props[id]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index2) {
    let id = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children = [];
    while (index2 < endIndex) {
      children.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a2;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index2, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index2);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i, parent);
          let inner = new _TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index2, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index2) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index: index2, parent } = buffer);
    } else {
      ({ index: index2, _parent: parent } = this._tree);
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (let i = index2 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache; c; c = c._parent)
          if (c.index == index2) {
            if (index2 == this.index)
              return c;
            result = c;
            depth = d + 1;
            break scan;
          }
        index2 = this.stack[--d];
      }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types2[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node2 = reused[id];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id;
        return;
      } else if (size == -4) {
        lookAhead = id;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index2 = data2.length;
      while (cursor2.pos > endPos)
        index2 = copyToBuffer(buffer2.start, data2, index2);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id, start, end, size } = cursor2;
      if (size > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id, start, end);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let { id, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id < minRepeatType) {
      let startIndex = index2;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index2 = copyToBuffer(bufferStart, buffer2, index2);
      }
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id;
    } else if (size == -3) {
      contextHash = id;
    } else if (size == -4) {
      lookAhead = id;
    }
    return index2;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var TreeFragment = class _TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
};
var Parser2 = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done2 = parse.advance();
      if (done2)
        return done2;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name2, set, base2, modified) {
    this.name = name2;
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base2.name, set, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config3 of configs)
          set.push(_Modifier.get(parent, config3));
    return tag;
  }
};
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options2) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options2 || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder2 = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder2.highlightRange(tree.cursor(), from, to, "", builder2.highlighters);
  builder2.flush(to);
}
var HighlightBuilder = class {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor2;
    if (start >= to || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor2) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
      let hasChild2 = cursor2.firstChild();
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor2.from < rangeTo2) {
            this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor2.to <= from)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor2.to), cls);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation2 = t();
var bracket = t(punctuation2);
var meta = t();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation: punctuation2,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation2),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
var sublanguageProp = /* @__PURE__ */ new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser3, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser3;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r of mount.overlay)
              result.push({ from: r.from + from, to: r.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = /* @__PURE__ */ StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
      if (node.type.isTop)
        tree = node;
  }
  return tree;
}
var LRLanguage = class _LRLanguage extends Language {
  constructor(data, parser3, name2) {
    super(data, parser3, [], name2);
    this.parser = parser3;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new _LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options2, name2) {
    return new _LRLanguage(this.data, this.parser.configure(options2), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser3, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser3;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser3, state, viewport) {
    return new _ParseContext(parser3, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done2 = this.parse.advance();
        if (done2) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done2, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done2;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser2 {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser3 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r of ranges)
                cx.tempSkipped.push(r);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser3;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done2 = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done2 || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done2 && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
var LanguageSupport = class {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var indentService = /* @__PURE__ */ Facet.define();
var indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i = 0; i < cols; i++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options2 = {}) {
    this.state = state;
    this.options = options2;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text: text2, from } = this.lineAt(pos, bias);
    return text2.slice(pos - from, Math.min(text2.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text: text2, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text2, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text2, text2.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text: text2, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text2, text2.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add3 = [];
    for (let cur2 = inner; cur2 && !(cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
      add3.push(cur2);
    for (let i = add3.length - 1; i >= 0; i--)
      stack = { node: add3[i], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new _TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (; ; ) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
};
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd)
        return null;
      let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space };
    }
    pos = next.to;
  }
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r) => r.test(lineStart)))
      return tr;
    let { state } = tr, last = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last)
        continue;
      last = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
var foldService = /* @__PURE__ */ Facet.define();
var foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last = node.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end)
    return null;
  let stack = tree.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch = node.lastChild;
  return ch && ch.to == node.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from >= to ? void 0 : { from, to };
}
var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l2) => l2.from <= head && l2.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
var foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
        let { preparePlaceholder } = tr.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
        folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
      } else if (e.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to) => e.value.from != from || e.value.to != to,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
      }
    }
    if (tr.selection) {
      let onSelection = false, { head } = tr.selection.main;
      folded.between(head, head, (a, b) => {
        if (a < head && b > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a, b) => b <= head || a >= head
        });
    }
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to) => {
      ranges.push(from, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i = 0; i < value.length; ) {
      let from = value[i++], to = value[i++];
      if (typeof from != "number" || typeof to != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to));
    }
    return Decoration.set(ranges, true);
  }
});
function findFold(state, from, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to2 };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({ from, to }));
  });
  view.dispatch({ effects });
  return true;
};
var foldKeymap = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
  { key: "Ctrl-Alt-[", run: foldAll },
  { key: "Ctrl-Alt-]", run: unfoldAll }
];
var defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "\u2026"
};
var foldConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, defaultConfig);
  }
});
function codeFolding(config3) {
  let result = [foldState, baseTheme$12];
  if (config3)
    result.push(foldConfig.of(config3));
  return result;
}
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM(view) {
    return widgetToDOM(view, null);
  }
}() });
var PreparedFoldWidget = class extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
};
var foldGutterDefaults = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var FoldMarker = class extends GutterMarker {
  constructor(config3, open) {
    super();
    this.config = config3;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
};
function foldGutter(config3 = {}) {
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config3);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder2 = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder2.add(line.from, line.from, mark);
      }
      return builder2.finish();
    }
  });
  let { domEventHandlers } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a2;
        return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
        if (domEventHandlers.click && domEventHandlers.click(view, line, event))
          return true;
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
          view.dispatch({ effects: unfoldEffect.of(folded) });
          return true;
        }
        let range = foldable(view.state, line.from, line.to);
        if (range) {
          view.dispatch({ effects: foldEffect.of(range) });
          return true;
        }
        return false;
      } })
    }),
    codeFolding()
  ];
}
var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options2) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : void 0;
    const scopeOpt = options2.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options2.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options2) {
    return new _HighlightStyle(specs, options2 || {});
  }
};
var highlighterFacet = /* @__PURE__ */ Facet.define();
var fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options2) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder2 = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to2, style) => {
        builder2.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to);
    }
    return builder2.finish();
  }
};
var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
  let decorations2 = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match.start.from, match.start.to));
  if (match.end)
    decorations2.push(mark.range(match.end.from, match.end.to));
  return decorations2;
}
var bracketMatchingState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config3 = tr.state.facet(bracketMatchingConfig);
    for (let range of tr.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match = matchBrackets(tr.state, range.head, -1, config3) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config3) || config3.afterCursor && (matchBrackets(tr.state, range.head, 1, config3) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config3));
      if (match)
        decorations2 = decorations2.concat(config3.renderMatch(match, tr.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme2
];
function bracketMatching(config3 = {}) {
  return [bracketMatchingConfig.of(config3), bracketMatchingUnique];
}
var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index2 = brackets.indexOf(node.name);
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index2 + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config3 = {}) {
  let maxScanDistance = config3.maxScanDistance || DefaultScanDist, brackets = config3.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text2 = iter.value;
    if (dir < 0)
      distance += text2.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text2.length - 1, end = dir > 0 ? text2.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text2[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance += text2.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var warned = [];
var byTag = /* @__PURE__ */ Object.create(null);
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key2 = name2 + " " + tags$1.map((t2) => t2.id);
  let known = byTag[key2];
  if (known)
    return known.id;
  let type = byTag[key2] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
var marks = {
  rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
  auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config3 = getConfig(target.state, line.from);
  return config3.line ? toggleLineComment(target) : config3.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = /* @__PURE__ */ command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var toggleBlockComment = /* @__PURE__ */ command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var toggleBlockCommentByLine = /* @__PURE__ */ command(
  (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos, 1);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    if (toLine.from > fromLine.from && toLine.from == r.to)
      toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i) => {
      if (comments[i])
        return [];
      return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token = tokens[i], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l2) => l2.comment < 0 && (!l2.empty || l2.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l2) => l2.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = /* @__PURE__ */ Annotation.define();
var isolateHistory = /* @__PURE__ */ Annotation.define();
var invertedEffects = /* @__PURE__ */ Facet.define();
var historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
    });
  }
});
var historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config3 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config3.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config3, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config3.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
  },
  fromJSON(json2) {
    return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
  }
});
function history2(config3 = {}) {
  return [
    historyField_,
    historyConfig.of(config3),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = /* @__PURE__ */ cmd(0, false);
var redo = /* @__PURE__ */ cmd(1, false);
var undoSelection = /* @__PURE__ */ cmd(0, true);
var redoSelection = /* @__PURE__ */ cmd(1, true);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(json2) {
    return new _HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection2) {
    let effects = none2;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none2);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none2, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++], to = ranges[i++];
      if (t2 >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
var none2 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none2;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none2;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done2, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done2;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config3, tr) {
    let done2 = this.done, lastEvent = done2[done2.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config3.newGroupDelay && config3.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done2 = updateBranch(done2, done2.length - 1, config3.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
    } else {
      done2 = updateBranch(done2, done2.length, config3.minDepth, event);
    }
    return new _HistoryState(done2, none2, time, userEvent);
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
      return this;
    return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection: selection2 }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node } = cur2;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection2 = null;
  if (cur2.ranges.length > 1)
    selection2 = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak2(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak2(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak2(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak2(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak2(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block2 of selectedLineBlocks(state)) {
    if (forward ? block2.to == state.doc.length : block2.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block2.to + 1 : block2.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block2.to, to: nextLine.to }, { from: block2.from, insert: nextLine.text + state.lineBreak });
      for (let r of block2.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block2.from }, { from: block2.to, insert: state.lineBreak + nextLine.text });
      for (let r of block2.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block2 of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block2.from, insert: state.doc.slice(block2.from, block2.to) + state.lineBreak });
    else
      changes.push({ from: block2.to, insert: state.lineBreak + state.doc.slice(block2.from, block2.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block2 = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist2 = block2.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist2);
  }).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
var defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);
var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value = next[name2];
      if (typeof value == "string") elt.setAttribute(name2, value);
      else if (value != null) elt[name2] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add2(elt, arguments[i]);
  return elt;
}
function add2(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add2(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text2, query, from = 0, to = text2.length, normalize, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text2.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt2(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize2(next);
      let norm = this.normalize(str);
      if (norm.length)
        for (let i = 0, pos = start; ; i++) {
          let code = norm.charCodeAt(i);
          let match = this.match(code, pos, this.bufferPos + this.bufferStart);
          if (i == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start && i < str.length && str.charCodeAt(i) == code)
            pos++;
        }
    }
  }
  match(code, pos, end) {
    let match = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let index2 = this.matches[i], keep = false;
      if (this.query.charCodeAt(index2) == code) {
        if (index2 == this.query.length - 1) {
          match = { from: this.matches[i + 1], to: end };
        } else {
          this.matches[i]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: end };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text2, query, options2, from = 0, to = text2.length) {
    this.text = text2;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text2, query, options2, from, to);
    this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
    this.test = options2 === null || options2 === void 0 ? void 0 : options2.test;
    this.iter = text2.iter();
    let startLine = text2.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text2, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text2) {
    this.from = from;
    this.text = text2;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc2.sliceString(from, to));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text: text2, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text2 = doc2.sliceString(from, cachedFrom) + text2;
      cachedFrom = from;
    }
    if (cached.to < to)
      text2 += doc2.sliceString(cached.to, to);
    flattened.set(doc2, new _FlattenedDoc(cachedFrom, text2));
    return new _FlattenedDoc(from, text2.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text2, query, options2, from, to) {
    this.text = text2;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text2, from);
    this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
    this.test = options2 === null || options2 === void 0 ? void 0 : options2.test;
    this.flat = FlattenedDoc.get(text2, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text2, pos) {
  if (pos >= text2.length)
    return pos;
  let line = text2.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")), crelt("button", {
    name: "close",
    onclick: () => {
      view.dispatch({ effects: dialogEffect.of(false) });
      view.focus();
    },
    "aria-label": view.state.phrase("close"),
    type: "button"
  }, ["\xD7"]));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, { y: "center" })],
      selection: selection2
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = /* @__PURE__ */ StateEffect.define();
var dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(dialogEffect))
        value = e.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = /* @__PURE__ */ Facet.define({
  combine(options2) {
    return combineConfig(options2, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options2) {
  let ext = [defaultTheme2, matchHighlighter];
  if (options2)
    ext.push(highlightConfig.of(options2));
  return ext;
}
var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to);
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor2.next().done) {
        let { from, to } = cursor2.value;
        if (!check || insideWordBoundaries(check, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme2 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection: selection2 } = state;
  let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
  if (newSel.eq(selection2))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r) => r.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config3) {
    this.search = config3.search;
    this.caseSensitive = !!config3.caseSensitive;
    this.literal = !!config3.literal;
    this.regexp = !!config3.regexp;
    this.replace = config3.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config3.wholeWord;
  }
  /**
  @internal
  */
  unquote(text2) {
    return this.literal ? text2 : text2.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st.doc.length;
    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
  }
};
var QueryType2 = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to) {
  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType2 {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor2.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
      cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
    }
    return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor2.nextOverlapping().done)
        range = cursor2.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom);
    if (!found)
      found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
    return found && (found.from != curFrom || found.to != curTo) ? found : null;
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add3) {
    let cursor2 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor2.next().done)
      add3(cursor2.value.from, cursor2.value.to);
  }
};
function regexpCursor(spec, state, from, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to);
}
function charBefore(str, index2) {
  return str.slice(findClusterBreak2(str, index2, false), index2);
}
function charAfter(str, index2) {
  return str.slice(index2, findClusterBreak2(str, index2));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType2 {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor2.done)
      cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(state, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor2 = regexpCursor(this.spec, state, start, to), range = null;
      while (!cursor2.next().done)
        range = cursor2.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i) => {
      if (i == "&")
        return result.match[0];
      if (i == "$")
        return "$";
      for (let l2 = i.length; l2 > 0; l2--) {
        let n = +i.slice(0, l2);
        if (n > 0 && n < result.match.length)
          return result.match[n] + i.slice(l2);
      }
      return m;
    });
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add3) {
    let cursor2 = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor2.next().done)
      add3(cursor2.value.from, cursor2.value.to);
  }
};
var setSearchQuery = /* @__PURE__ */ StateEffect.define();
var togglePanel = /* @__PURE__ */ StateEffect.define();
var searchState = /* @__PURE__ */ StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder2 = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l2 = ranges.length; i < l2; i++) {
      let { from, to } = ranges[i];
      while (i < l2 - 1 && to > ranges[i + 1].from - 2 * 250)
        to = ranges[++i].to;
      query.highlight(view.state, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
        builder2.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder2.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state, to, to);
  if (!next)
    return false;
  let selection2 = EditorSelection.single(next.from, next.to);
  let config3 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, next), config3.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection2 = EditorSelection.single(prev.from, prev.to);
  let config3 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, prev), config3.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let match = query.nextMatch(state, from, from);
  if (!match)
    return false;
  let next = match;
  let changes = [], selection2, replacement;
  let effects = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= match.to ? 0 : match.to - match.from - replacement.length;
    selection2 = EditorSelection.single(next.from - off, next.to - off);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
  }
  view.dispatch({
    changes,
    selection: selection2,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config3 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config3.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config3.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config3.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config3.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config3.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e) {
    if (runScopeHandlers(this.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == this.searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e.keyCode == 13 && e.target == this.replaceField) {
      e.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text2 = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text2[i + 1]) && Break.test(text2[i])) {
        text2 = text2.slice(i);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i = text2.length - 1; i > text2.length - AnnounceMargin; i--)
      if (!Break.test(text2[i - 1]) && Break.test(text2[i])) {
        text2 = text2.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text2} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  /* @__PURE__ */ Prec.low(searchHighlighter),
  baseTheme3
];

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options2) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options2 && options2.onDocChange)
        this.abortOnDocChange = true;
    }
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options2) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options2) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options2 = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match] = options2.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options: options2, validFor } : null;
  };
}
var Option = class {
  constructor(completion, source, match, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a2;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = /* @__PURE__ */ Annotation.define();
function insertCompletionText(state, text2, from, to) {
  let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
  return Object.assign(Object.assign({}, state.changeByRange((range) => {
    if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
      return { range };
    let lines = state.toText(text2);
    return {
      changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
      range: EditorSelection.cursor(range.from + fromOff + lines.length)
    };
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt2(pattern, p), size = codePointSize2(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt2(word, 0), firstSize = codePointSize2(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next = codePointAt2(word, i);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize2(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next = codePointAt2(word, i);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i += codePointSize2(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [], i = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
      if (i && result[i - 1] == pos)
        result[i - 1] = to;
      else {
        result[i++] = pos;
        result[i++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match == null)
      return null;
    this.matched = [0, start.length];
    this.score = match + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a, b) => a.label.localeCompare(b.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a, b) => a && b,
      closeOnBlur: (a, b) => a && b,
      icons: (a, b) => a && b,
      tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
      optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
      addToOptions: (a, b) => a.concat(b),
      filterStrict: (a, b) => a || b
    });
  }
});
function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config3) {
  let content2 = config3.addToOptions.slice();
  if (config3.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j = 0; j < match.length; ) {
        let from = match[j++], to = match[j++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options: options2, selected } = cState.open;
    let config3 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config3);
    this.optionClass = config3.optionClass;
    this.tooltipClass = config3.tooltipClass;
    this.range = rangeAroundSelected(options2.length, selected, config3.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e) => {
      let { options: options3 } = view.state.field(stateField).open;
      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options3.length) {
          this.applyCompletion(view, options3[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options2, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options2, id) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options2, id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a2;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options: options2, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options2) {
        this.range = rangeAroundSelected(options2.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options2, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(" "))
        if (c)
          this.dom.classList.remove(c);
      for (let c of cls.split(" "))
        if (c)
          this.dom.classList.add(c);
      this.currentClass = cls;
    }
  }
  positioned(space) {
    this.space = space;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e) => logException(this.view.state, e, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    if (content2.nodeType != null) {
      wrap.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom, destroy } = content2;
      wrap.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i--;
      } else if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set)
      scrollIntoView2(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space = this.space;
    if (!space) {
      let docElt = this.dom.ownerDocument.documentElement;
      space = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
    }
    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options2, id, range) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    ul.addEventListener("mousedown", (e) => {
      if (e.target == ul)
        e.preventDefault();
    });
    let curSection = null;
    for (let i = range.from; i < range.to; i++) {
      let { completion, match } = options2[i], { section } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i > range.from || range.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match);
        if (node)
          li.appendChild(node);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options2.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self2.top < parent.top)
    container.scrollTop -= (parent.top - self2.top) / scaleY;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options2 = [];
  let sections = null;
  let addOption = (option) => {
    options2.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s) => s.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a of active)
    if (a.hasResult()) {
      let getMatch = a.result.getMatch;
      if (a.result.filter === false) {
        for (let option of a.result.options) {
          addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options2.length));
        }
      } else {
        let pattern = state.sliceDoc(a.from, a.to), match;
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a.result.options)
          if (match = matcher.match(option.label)) {
            let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
            addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a, b) => {
      var _a2, _b;
      return ((_a2 = a.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);
    };
    for (let s of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s.name] = pos;
    }
    for (let option of options2) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options2.sort((a, b) => b.score - a.score || compare2(a.completion, b.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options2, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options2;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s) => s.isPending))
      return prev.setDisabled();
    let options2 = sortOptions(active, state);
    if (!options2.length)
      return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i = 0; i < options2.length; i++)
        if (options2[i].completion == selectedValue) {
          selected = i;
          break;
        }
    }
    return new _CompletionDialog(options2, makeAttrs(id, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id, open) {
    this.active = active;
    this.id = id;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s) => s.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a) => a.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active;
    let open = this.open, didSet = tr.effects.some((e) => e.is(setActiveEffect));
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet)
      open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some((a) => a.isPending))
      open = null;
    if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult()))
      active = active.map((a) => a.hasResult() ? new ActiveSource(
        a.source,
        0
        /* State.Inactive */
      ) : a);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
  }
};
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult())
      iA++;
    while (iB < b.length && !b[iB].hasResult())
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs2 = {};
function makeAttrs(id, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id
  };
  if (selected > -1)
    result["aria-activedescendant"] = id + "-" + selected;
  return result;
}
var none3 = [];
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  get isPending() {
    return this.state == 1;
  }
  update(tr, conf) {
    let type = getUpdateType(tr, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr))
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type & 4 && value.state == 0)
      value = new _ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr, type);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr, type) {
    return this.map(tr.changes);
  }
  map(changes) {
    return this;
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result, from, to) {
    super(source, 3, explicit);
    this.limit = limit;
    this.result = result;
    this.from = from;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  updateFor(tr, type) {
    var _a2;
    if (!(type & 3))
      return this.map(tr.changes);
    let result = this.result;
    if (result.map && !tr.changes.empty)
      result = result.map(result, tr.changes);
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if (pos > to || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit))
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      );
    let limit = tr.changes.mapPos(this.limit);
    if (checkValid(result.validFor, tr.state, from, to))
      return new _ActiveResult(this.source, this.explicit, limit, result, from, to);
    if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
      return new _ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
    return new ActiveSource(this.source, 1, this.explicit);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state, from, to) {
  if (!validFor)
    return false;
  let text2 = state.sliceDoc(from, to);
  return typeof validFor == "function" ? validFor(text2, from, to, state) : ensureAnchor(validFor, true).test(text2);
}
var setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s) => s.map(mapping));
  }
});
var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
var completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply2 = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a) => a.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply2 == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply2, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply2(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a) => a.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.isPending)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    let conf = update.state.facet(completionConfig);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      let type = getUpdateType(tr, conf);
      return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
    });
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            logException(this.view.state, e);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    if (update.transactions.some((tr) => tr.effects.some((e) => e.is(startCompletionEffect))))
      this.pendingStart = true;
    let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a) => a.isPending && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (tr.isUserEvent("input.type"))
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.isPending && !this.running.some((r) => r.active.source == active.source))
        this.startQuery(active);
    }
    if (this.running.length && cState.open && cState.open.disabled)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicit, this.view);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === void 0)
        continue;
      this.running.splice(i--, 1);
      if (query.done) {
        let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
        let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
        let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
        for (let tr of query.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = cState.active.find((a) => a.source == query.active.source);
      if (current && current.isPending) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (!active.isPending)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length || cState.open && cState.open.disabled)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur(event) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event.relatedTarget))
          setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
var windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
var commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    let field = view.state.field(completionState, false);
    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
      return false;
    let option = field.open.options[field.open.selected];
    let result = field.active.find((a) => a.source == option.source);
    let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
    if (commitChars && commitChars.indexOf(event.key) > -1)
      applyCompletion(view, option);
    return false;
  }
}));
var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var defaults3 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    if (tr.selection) {
      let line = tr.state.doc.lineAt(tr.selection.main.head);
      value = value.update({ filter: (from) => from >= line.from && from <= line.to });
    }
    for (let effect of tr.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults3;
}
var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
var deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults3.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt2(token, 0)))
          return {
            changes: { from: range.head - token.length, to: range.head + token.length },
            range: EditorSelection.cursor(range.head - token.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
var closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults3.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt2(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults3.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize2(codePointAt2(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize2(codePointAt2(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config3) {
  let stringPrefixes = config3.stringPrefixes || defaults3.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
  for (let i = 0; i < 5; i++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config3 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config3),
    completionPlugin,
    completionKeymapExt,
    baseTheme4
  ];
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { mac: "Alt-`", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      diagnostics = diagnosticFilter(diagnostics, state);
    let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);
    let deco = new RangeSetBuilder(), active = [], pos = 0;
    for (let i = 0; ; ) {
      let next = i == sorted.length ? null : sorted[i];
      if (!next && !active.length)
        break;
      let from, to;
      if (active.length) {
        from = pos;
        to = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from ? next.from : 1e8);
      } else {
        from = next.from;
        to = next.to;
        active.push(next);
        i++;
      }
      while (i < sorted.length) {
        let next2 = sorted[i];
        if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
          active.push(next2);
          i++;
          to = Math.min(next2.to, to);
        } else {
          to = Math.min(next2.from, to);
          break;
        }
      }
      let sev = maxSeverity(active);
      if (active.some((d) => d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)) {
        deco.add(from, from, Decoration.widget({
          widget: new DiagnosticWidget(sev),
          diagnostics: active.slice()
        }));
      } else {
        let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
        deco.add(from, to, Decoration.mark({
          class: "cm-lintRange cm-lintRange-" + sev + markClass,
          diagnostics: active.slice(),
          inclusiveEnd: active.some((a) => a.to > to)
        }));
      }
      pos = to;
      for (let i2 = 0; i2 < active.length; i2++)
        if (active[i2].to <= pos)
          active.splice(i2--, 1);
    }
    let set = deco.finish();
    return new _LintState(set, panel, findDiagnostic(set));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
      return;
    if (!found)
      found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
    else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
      return false;
    else
      found = new SelectedDiagnostic(found.from, to, found.diagnostic);
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let from = tooltip.pos, to = tooltip.end || from;
  let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
  if (result != null)
    return result;
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
var togglePanel2 = /* @__PURE__ */ StateEffect.define();
var movePanelSelection = /* @__PURE__ */ StateEffect.define();
var lintState = /* @__PURE__ */ StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged && value.diagnostics.size) {
      let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
        panel = null;
      value = new LintState(mapped, panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
        value = LintState.init(effect.value, panel, tr.state);
      } else if (effect.is(togglePanel2)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s) => s.diagnostics)
  ]
});
var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found, start = -1, end = -1;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found = spec.diagnostics;
      start = from;
      end = to;
      return false;
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (found && diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found)
    return null;
  return {
    pos: start,
    end,
    above: view.state.doc.lineAt(start).to < end,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintConfig = /* @__PURE__ */ Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i) => i.source).filter((x) => x != null) }, combineConfig(input.map((i) => i.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (a, b) => !a ? b : !b ? a : (u) => a(u) || b(u)
    }));
  }
});
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name2 } of actions) {
      for (let i = 0; i < name2.length; i++) {
        let ch = name2[i];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action9, i) => {
    let fired = false, click = (e) => {
      e.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action9.apply(view, found.from, found.to);
    };
    let { name: name2 } = action9, keyIndex = keys2[i] ? name2.indexOf(keys2[i]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(sev) {
    super();
    this.sev = sev;
  }
  eq(other) {
    return other.sev == this.sev;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
        for (let i = 0; i < keys2.length; i++)
          if (keys2[i].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].dom.contains(event.target))
          this.moveSelection(i);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "\xD7"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i = 0; i < this.items.length; i++)
      if (this.items[i].diagnostic == selected.diagnostic)
        return i;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i = 0, needsSync = false, newSelectedItem = null;
    let seen = /* @__PURE__ */ new Set();
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      for (let diagnostic of spec.diagnostics) {
        if (seen.has(diagnostic))
          continue;
        seen.add(diagnostic);
        let found = -1, item;
        for (let j = i; j < this.items.length; j++)
          if (this.items[j].diagnostic == diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, diagnostic);
          this.items.splice(i, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i) {
            this.items.splice(i, found - i);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i++;
      }
    });
    while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection2)
      return;
    this.view.dispatch({
      selection: { anchor: selection2.from, head: selection2.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection2)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg2(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg2(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
  let sev = "hint", weight = 1;
  for (let d of diagnostics) {
    let w = severityWeight(d.severity);
    if (w > weight) {
      weight = w;
      sev = d.severity;
    }
  }
  return sev;
}
var lintExtensions = [
  lintState,
  /* @__PURE__ */ EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme5
];

// node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js
var basicSetup = function basicSetup2(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var {
    crosshairCursor: initCrosshairCursor = false
  } = options2;
  var keymaps = [];
  if (options2.closeBracketsKeymap !== false) {
    keymaps = keymaps.concat(closeBracketsKeymap);
  }
  if (options2.defaultKeymap !== false) {
    keymaps = keymaps.concat(defaultKeymap);
  }
  if (options2.searchKeymap !== false) {
    keymaps = keymaps.concat(searchKeymap);
  }
  if (options2.historyKeymap !== false) {
    keymaps = keymaps.concat(historyKeymap);
  }
  if (options2.foldKeymap !== false) {
    keymaps = keymaps.concat(foldKeymap);
  }
  if (options2.completionKeymap !== false) {
    keymaps = keymaps.concat(completionKeymap);
  }
  if (options2.lintKeymap !== false) {
    keymaps = keymaps.concat(lintKeymap);
  }
  var extensions = [];
  if (options2.lineNumbers !== false) extensions.push(lineNumbers());
  if (options2.highlightActiveLineGutter !== false) extensions.push(highlightActiveLineGutter());
  if (options2.highlightSpecialChars !== false) extensions.push(highlightSpecialChars());
  if (options2.history !== false) extensions.push(history2());
  if (options2.foldGutter !== false) extensions.push(foldGutter());
  if (options2.drawSelection !== false) extensions.push(drawSelection());
  if (options2.dropCursor !== false) extensions.push(dropCursor());
  if (options2.allowMultipleSelections !== false) extensions.push(EditorState.allowMultipleSelections.of(true));
  if (options2.indentOnInput !== false) extensions.push(indentOnInput());
  if (options2.syntaxHighlighting !== false) extensions.push(syntaxHighlighting(defaultHighlightStyle, {
    fallback: true
  }));
  if (options2.bracketMatching !== false) extensions.push(bracketMatching());
  if (options2.closeBrackets !== false) extensions.push(closeBrackets());
  if (options2.autocompletion !== false) extensions.push(autocompletion());
  if (options2.rectangularSelection !== false) extensions.push(rectangularSelection());
  if (initCrosshairCursor !== false) extensions.push(crosshairCursor());
  if (options2.highlightActiveLine !== false) extensions.push(highlightActiveLine());
  if (options2.highlightSelectionMatches !== false) extensions.push(highlightSelectionMatches());
  if (options2.tabSize && typeof options2.tabSize === "number") extensions.push(indentUnit.of(" ".repeat(options2.tabSize)));
  return extensions.concat([keymap.of(keymaps.flat())]).filter(Boolean);
};

// node_modules/@codemirror/theme-one-dark/dist/index.js
var chalky = "#e5c07b";
var coral = "#e06c75";
var cyan = "#56b6c2";
var invalid = "#ffffff";
var ivory = "#abb2bf";
var stone = "#7d8799";
var malibu = "#61afef";
var sage = "#98c379";
var whiskey = "#d19a66";
var violet = "#c678dd";
var darkBackground = "#21252b";
var highlightBackground = "#2c313a";
var background = "#282c34";
var tooltipBackground = "#353a42";
var selection = "#3E4451";
var cursor = "#528bff";
var oneDarkTheme = /* @__PURE__ */ EditorView.theme({
  "&": {
    color: ivory,
    backgroundColor: background
  },
  ".cm-content": {
    caretColor: cursor
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
  ".cm-panels": { backgroundColor: darkBackground, color: ivory },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: background,
    color: stone,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground,
    borderBottomColor: tooltipBackground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground,
      color: ivory
    }
  }
}, { dark: true });
var oneDarkHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.keyword,
    color: violet
  },
  {
    tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
    color: coral
  },
  {
    tag: [/* @__PURE__ */ tags.function(tags.variableName), tags.labelName],
    color: malibu
  },
  {
    tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
    color: whiskey
  },
  {
    tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator],
    color: ivory
  },
  {
    tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
    color: chalky
  },
  {
    tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, /* @__PURE__ */ tags.special(tags.string)],
    color: cyan
  },
  {
    tag: [tags.meta, tags.comment],
    color: stone
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.link,
    color: stone,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    fontWeight: "bold",
    color: coral
  },
  {
    tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)],
    color: whiskey
  },
  {
    tag: [tags.processingInstruction, tags.string, tags.inserted],
    color: sage
  },
  {
    tag: tags.invalid,
    color: invalid
  }
]);
var oneDark = [oneDarkTheme, /* @__PURE__ */ syntaxHighlighting(oneDarkHighlightStyle)];

// node_modules/@uiw/react-codemirror/esm/theme/light.js
var defaultLightThemeOption = EditorView.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: false
});

// node_modules/@uiw/react-codemirror/esm/getDefaultExtensions.js
var getDefaultExtensions = function getDefaultExtensions2(optios) {
  if (optios === void 0) {
    optios = {};
  }
  var {
    indentWithTab: defaultIndentWithTab = true,
    editable: editable2 = true,
    readOnly: readOnly2 = false,
    theme: theme2 = "light",
    placeholder: placeholderStr = "",
    basicSetup: defaultBasicSetup = true
  } = optios;
  var getExtensions = [];
  if (defaultIndentWithTab) {
    getExtensions.unshift(keymap.of([indentWithTab]));
  }
  if (defaultBasicSetup) {
    if (typeof defaultBasicSetup === "boolean") {
      getExtensions.unshift(basicSetup());
    } else {
      getExtensions.unshift(basicSetup(defaultBasicSetup));
    }
  }
  if (placeholderStr) {
    getExtensions.unshift(placeholder(placeholderStr));
  }
  switch (theme2) {
    case "light":
      getExtensions.push(defaultLightThemeOption);
      break;
    case "dark":
      getExtensions.push(oneDark);
      break;
    case "none":
      break;
    default:
      getExtensions.push(theme2);
      break;
  }
  if (editable2 === false) {
    getExtensions.push(EditorView.editable.of(false));
  }
  if (readOnly2) {
    getExtensions.push(EditorState.readOnly.of(true));
  }
  return [...getExtensions];
};

// node_modules/@uiw/react-codemirror/esm/utils.js
var getStatistics = (view) => {
  return {
    line: view.state.doc.lineAt(view.state.selection.main.from),
    lineCount: view.state.doc.lines,
    lineBreak: view.state.lineBreak,
    length: view.state.doc.length,
    readOnly: view.state.readOnly,
    tabSize: view.state.tabSize,
    selection: view.state.selection,
    selectionAsSingle: view.state.selection.asSingle().main,
    ranges: view.state.selection.ranges,
    selectionCode: view.state.sliceDoc(view.state.selection.main.from, view.state.selection.main.to),
    selections: view.state.selection.ranges.map((r) => view.state.sliceDoc(r.from, r.to)),
    selectedText: view.state.selection.ranges.some((r) => !r.empty)
  };
};

// node_modules/@uiw/react-codemirror/esm/useCodeMirror.js
var External = Annotation.define();
var emptyExtensions = [];
function useCodeMirror(props) {
  var {
    value,
    selection: selection2,
    onChange,
    onStatistics,
    onCreateEditor,
    onUpdate,
    extensions = emptyExtensions,
    autoFocus,
    theme: theme2 = "light",
    height = null,
    minHeight = null,
    maxHeight = null,
    width = null,
    minWidth = null,
    maxWidth = null,
    placeholder: placeholderStr = "",
    editable: editable2 = true,
    readOnly: readOnly2 = false,
    indentWithTab: defaultIndentWithTab = true,
    basicSetup: defaultBasicSetup = true,
    root,
    initialState
  } = props;
  var [container, setContainer] = useState3();
  var [view, setView] = useState3();
  var [state, setState] = useState3();
  var defaultThemeOption = EditorView.theme({
    "&": {
      height,
      minHeight,
      maxHeight,
      width,
      minWidth,
      maxWidth
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  });
  var updateListener2 = EditorView.updateListener.of((vu) => {
    if (vu.docChanged && typeof onChange === "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !vu.transactions.some((tr) => tr.annotation(External))) {
      var doc2 = vu.state.doc;
      var _value = doc2.toString();
      onChange(_value, vu);
    }
    onStatistics && onStatistics(getStatistics(vu));
  });
  var defaultExtensions = getDefaultExtensions({
    theme: theme2,
    editable: editable2,
    readOnly: readOnly2,
    placeholder: placeholderStr,
    indentWithTab: defaultIndentWithTab,
    basicSetup: defaultBasicSetup
  });
  var getExtensions = [updateListener2, defaultThemeOption, ...defaultExtensions];
  if (onUpdate && typeof onUpdate === "function") {
    getExtensions.push(EditorView.updateListener.of(onUpdate));
  }
  getExtensions = getExtensions.concat(extensions);
  useLayoutEffect(() => {
    if (container && !state) {
      var config3 = {
        doc: value,
        selection: selection2,
        extensions: getExtensions
      };
      var stateCurrent = initialState ? EditorState.fromJSON(initialState.json, config3, initialState.fields) : EditorState.create(config3);
      setState(stateCurrent);
      if (!view) {
        var viewCurrent = new EditorView({
          state: stateCurrent,
          parent: container,
          root
        });
        setView(viewCurrent);
        onCreateEditor && onCreateEditor(viewCurrent, stateCurrent);
      }
    }
    return () => {
      if (view) {
        setState(void 0);
        setView(void 0);
      }
    };
  }, [container, state]);
  useEffect3(() => {
    if (props.container) {
      setContainer(props.container);
    }
  }, [props.container]);
  useEffect3(() => () => {
    if (view) {
      view.destroy();
      setView(void 0);
    }
  }, [view]);
  useEffect3(() => {
    if (autoFocus && view) {
      view.focus();
    }
  }, [autoFocus, view]);
  useEffect3(() => {
    if (view) {
      view.dispatch({
        effects: StateEffect.reconfigure.of(getExtensions)
      });
    }
  }, [theme2, extensions, height, minHeight, maxHeight, width, minWidth, maxWidth, placeholderStr, editable2, readOnly2, defaultIndentWithTab, defaultBasicSetup, onChange, onUpdate]);
  useEffect3(() => {
    if (value === void 0) {
      return;
    }
    var currentValue = view ? view.state.doc.toString() : "";
    if (view && value !== currentValue) {
      view.dispatch({
        changes: {
          from: 0,
          to: currentValue.length,
          insert: value || ""
        },
        annotations: [External.of(true)]
      });
    }
  }, [value, view]);
  return {
    state,
    setState,
    view,
    setView,
    container,
    setContainer
  };
}

// node_modules/@uiw/react-codemirror/esm/index.js
import { jsx as _jsx } from "react/jsx-runtime";
var _excluded = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"];
var ReactCodeMirror = /* @__PURE__ */ forwardRef((props, ref) => {
  var {
    className,
    value = "",
    selection: selection2,
    extensions = [],
    onChange,
    onStatistics,
    onCreateEditor,
    onUpdate,
    autoFocus,
    theme: theme2 = "light",
    height,
    minHeight,
    maxHeight,
    width,
    minWidth,
    maxWidth,
    basicSetup: basicSetup3,
    placeholder: placeholder2,
    indentWithTab: indentWithTab2,
    editable: editable2,
    readOnly: readOnly2,
    root,
    initialState
  } = props, other = (0, import_objectWithoutPropertiesLoose.default)(props, _excluded);
  var editor = useRef2(null);
  var {
    state,
    view,
    container,
    setContainer
  } = useCodeMirror({
    root,
    value,
    autoFocus,
    theme: theme2,
    height,
    minHeight,
    maxHeight,
    width,
    minWidth,
    maxWidth,
    basicSetup: basicSetup3,
    placeholder: placeholder2,
    indentWithTab: indentWithTab2,
    editable: editable2,
    readOnly: readOnly2,
    selection: selection2,
    onChange,
    onStatistics,
    onCreateEditor,
    onUpdate,
    extensions,
    initialState
  });
  useImperativeHandle(ref, () => ({
    editor: editor.current,
    state,
    view
  }), [editor, container, state, view]);
  var setEditorRef = useCallback2((el) => {
    editor.current = el;
    setContainer(el);
  }, [setContainer]);
  if (typeof value !== "string") {
    throw new Error("value must be typeof string but got " + typeof value);
  }
  var defaultClassNames = typeof theme2 === "string" ? "cm-theme-" + theme2 : "cm-theme";
  return /* @__PURE__ */ _jsx("div", (0, import_extends.default)({
    ref: setEditorRef,
    className: "" + defaultClassNames + (className ? " " + className : "")
  }, other));
});
ReactCodeMirror.displayName = "CodeMirror";
var esm_default = ReactCodeMirror;

// node_modules/@uiw/codemirror-theme-material/esm/index.js
var import_extends2 = __toESM(require_extends());

// node_modules/@uiw/codemirror-themes/esm/index.js
var createTheme = (_ref) => {
  var {
    theme: theme2,
    settings = {},
    styles = []
  } = _ref;
  var themeOptions = {
    ".cm-gutters": {}
  };
  var baseStyle = {};
  if (settings.background) {
    baseStyle.backgroundColor = settings.background;
  }
  if (settings.backgroundImage) {
    baseStyle.backgroundImage = settings.backgroundImage;
  }
  if (settings.foreground) {
    baseStyle.color = settings.foreground;
  }
  if (settings.fontSize) {
    baseStyle.fontSize = settings.fontSize;
  }
  if (settings.background || settings.foreground) {
    themeOptions["&"] = baseStyle;
  }
  if (settings.fontFamily) {
    themeOptions["&.cm-editor .cm-scroller"] = {
      fontFamily: settings.fontFamily
    };
  }
  if (settings.gutterBackground) {
    themeOptions[".cm-gutters"].backgroundColor = settings.gutterBackground;
  }
  if (settings.gutterForeground) {
    themeOptions[".cm-gutters"].color = settings.gutterForeground;
  }
  if (settings.gutterBorder) {
    themeOptions[".cm-gutters"].borderRightColor = settings.gutterBorder;
  }
  if (settings.caret) {
    themeOptions[".cm-content"] = {
      caretColor: settings.caret
    };
    themeOptions[".cm-cursor, .cm-dropCursor"] = {
      borderLeftColor: settings.caret
    };
  }
  var activeLineGutterStyle = {};
  if (settings.gutterActiveForeground) {
    activeLineGutterStyle.color = settings.gutterActiveForeground;
  }
  if (settings.lineHighlight) {
    themeOptions[".cm-activeLine"] = {
      backgroundColor: settings.lineHighlight
    };
    activeLineGutterStyle.backgroundColor = settings.lineHighlight;
  }
  themeOptions[".cm-activeLineGutter"] = activeLineGutterStyle;
  if (settings.selection) {
    themeOptions["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
      background: settings.selection + " !important"
    };
  }
  if (settings.selectionMatch) {
    themeOptions["& .cm-selectionMatch"] = {
      backgroundColor: settings.selectionMatch
    };
  }
  var themeExtension = EditorView.theme(themeOptions, {
    dark: theme2 === "dark"
  });
  var highlightStyle = HighlightStyle.define(styles);
  var extension = [themeExtension, syntaxHighlighting(highlightStyle)];
  return extension;
};

// node_modules/@uiw/codemirror-theme-material/esm/index.js
var defaultSettingsMaterial = {
  background: "#2e3235",
  foreground: "#bdbdbd",
  caret: "#a0a4ae",
  selection: "#d7d4f063",
  selectionMatch: "#d7d4f063",
  gutterBackground: "#2e3235",
  gutterForeground: "#999",
  gutterActiveForeground: "#4f5b66",
  lineHighlight: "#545b6130"
};
var materialDarkStyle = [{
  tag: tags.keyword,
  color: "#cf6edf"
}, {
  tag: [tags.name, tags.deleted, tags.character, tags.macroName],
  color: "#56c8d8"
}, {
  tag: [tags.propertyName],
  color: "#facf4e"
}, {
  tag: [tags.variableName],
  color: "#bdbdbd"
}, {
  tag: [tags.function(tags.variableName)],
  color: "#56c8d8"
}, {
  tag: [tags.labelName],
  color: "#cf6edf"
}, {
  tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)],
  color: "#facf4e"
}, {
  tag: [tags.definition(tags.name), tags.separator],
  color: "#fa5788"
}, {
  tag: [tags.brace],
  color: "#cf6edf"
}, {
  tag: [tags.annotation],
  color: "#ff5f52"
}, {
  tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
  color: "#ffad42"
}, {
  tag: [tags.typeName, tags.className],
  color: "#ffad42"
}, {
  tag: [tags.operator, tags.operatorKeyword],
  color: "#7186f0"
}, {
  tag: [tags.tagName],
  color: "#99d066"
}, {
  tag: [tags.squareBracket],
  color: "#ff5f52"
}, {
  tag: [tags.angleBracket],
  color: "#606f7a"
}, {
  tag: [tags.attributeName],
  color: "#bdbdbd"
}, {
  tag: [tags.regexp],
  color: "#ff5f52"
}, {
  tag: [tags.quote],
  color: "#6abf69"
}, {
  tag: [tags.string],
  color: "#99d066"
}, {
  tag: tags.link,
  color: "#56c8d8",
  textDecoration: "underline",
  textUnderlinePosition: "under"
}, {
  tag: [tags.url, tags.escape, tags.special(tags.string)],
  color: "#facf4e"
}, {
  tag: [tags.meta],
  color: "#707d8b"
}, {
  tag: [tags.comment],
  color: "#707d8b",
  fontStyle: "italic"
}, {
  tag: tags.monospace,
  color: "#bdbdbd"
}, {
  tag: tags.strong,
  fontWeight: "bold",
  color: "#ff5f52"
}, {
  tag: tags.emphasis,
  fontStyle: "italic",
  color: "#99d066"
}, {
  tag: tags.strikethrough,
  textDecoration: "line-through"
}, {
  tag: tags.heading,
  fontWeight: "bold",
  color: "#facf4e"
}, {
  tag: tags.heading1,
  fontWeight: "bold",
  color: "#facf4e"
}, {
  tag: [tags.heading2, tags.heading3, tags.heading4],
  fontWeight: "bold",
  color: "#facf4e"
}, {
  tag: [tags.heading5, tags.heading6],
  color: "#facf4e"
}, {
  tag: [tags.atom, tags.bool, tags.special(tags.variableName)],
  color: "#56c8d8"
}, {
  tag: [tags.processingInstruction, tags.inserted],
  color: "#ff5f52"
}, {
  tag: [tags.contentSeparator],
  color: "#56c8d8"
}, {
  tag: tags.invalid,
  color: "#606f7a",
  borderBottom: "1px dotted #ff5f52"
}];
var materialInit = (options2) => {
  var {
    theme: theme2 = "dark",
    settings = {},
    styles = []
  } = options2 || {};
  return createTheme({
    theme: theme2,
    settings: (0, import_extends2.default)({}, defaultSettingsMaterial, settings),
    styles: [...materialDarkStyle, ...styles]
  });
};
var materialDark = materialInit();
var material = materialInit();
var defaultSettingsMaterialLight = {
  background: "#FAFAFA",
  foreground: "#90A4AE",
  caret: "#272727",
  selection: "#80CBC440",
  selectionMatch: "#80CBC440",
  gutterBackground: "#FAFAFA",
  gutterForeground: "#90A4AE",
  gutterBorder: "transparent",
  lineHighlight: "#CCD7DA50"
};
var materialLightStyle = [{
  tag: tags.keyword,
  color: "#39ADB5"
}, {
  tag: [tags.name, tags.deleted, tags.character, tags.macroName],
  color: "#90A4AE"
}, {
  tag: [tags.propertyName],
  color: "#6182B8"
}, {
  tag: [tags.processingInstruction, tags.string, tags.inserted, tags.special(tags.string)],
  color: "#91B859"
}, {
  tag: [tags.function(tags.variableName), tags.labelName],
  color: "#6182B8"
}, {
  tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)],
  color: "#39ADB5"
}, {
  tag: [tags.definition(tags.name), tags.separator],
  color: "#90A4AE"
}, {
  tag: [tags.className],
  color: "#E2931D"
}, {
  tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
  color: "#F76D47"
}, {
  tag: [tags.typeName],
  color: "#E2931D",
  fontStyle: "#E2931D"
}, {
  tag: [tags.operator, tags.operatorKeyword],
  color: "#39ADB5"
}, {
  tag: [tags.url, tags.escape, tags.regexp, tags.link],
  color: "#91B859"
}, {
  tag: [tags.meta, tags.comment],
  color: "#90A4AE"
}, {
  tag: tags.strong,
  fontWeight: "bold"
}, {
  tag: tags.emphasis,
  fontStyle: "italic"
}, {
  tag: tags.link,
  textDecoration: "underline"
}, {
  tag: tags.heading,
  fontWeight: "bold",
  color: "#39ADB5"
}, {
  tag: [tags.atom, tags.bool, tags.special(tags.variableName)],
  color: "#90A4AE"
}, {
  tag: tags.invalid,
  color: "#E5393570"
}, {
  tag: tags.strikethrough,
  textDecoration: "line-through"
}];
var materialLightInit = (options2) => {
  var {
    theme: theme2 = "light",
    settings = {},
    styles = []
  } = options2 || {};
  return createTheme({
    theme: theme2,
    settings: (0, import_extends2.default)({}, defaultSettingsMaterialLight, settings),
    styles: [...materialLightStyle, ...styles]
  });
};
var materialLight = materialLightInit();

// node_modules/@lezer/lr/dist/index.js
var Stack = class _Stack {
  /**
  @internal
  */
  constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new _Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action9) {
    var _a2;
    let depth = action9 >> 19, type = action9 & 65535;
    let { parser: parser3 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord)
      this.setLookAhead(this.pos);
    let dPrec = parser3.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser3.getGoto(this.state, type, true), this.reducePos);
      if (type < parser3.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action9 & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser3.minRepeatTerm || action9 & 131072) {
      let pos = parser3.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action9 & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser3.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0) {
        let mustMove = false;
        for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index2 > 0 && this.buffer[index2 - 2] > end) {
            this.buffer[index2] = this.buffer[index2 - 4];
            this.buffer[index2 + 1] = this.buffer[index2 - 3];
            this.buffer[index2 + 2] = this.buffer[index2 - 2];
            this.buffer[index2 + 3] = this.buffer[index2 - 1];
            index2 -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start;
      this.buffer[index2 + 2] = end;
      this.buffer[index2 + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action9, type, start, end) {
    if (action9 & 131072) {
      this.pushState(action9 & 65535, this.pos);
    } else if ((action9 & 262144) == 0) {
      let nextState = action9, { parser: parser3 } = this.p;
      if (end > this.pos || type <= parser3.maxNode) {
        this.pos = end;
        if (!parser3.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        ))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser3.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action9, next, nextStart, nextEnd) {
    if (action9 & 65536)
      this.reduce(action9);
    else
      this.shift(action9, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index2,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action9 = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action9 == 0)
        return false;
      if ((action9 & 65536) == 0)
        return true;
      sim.reduce(action9);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser3 } = this.p;
    let reduce = parser3.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce & 65536) == 0)
      return false;
    if (!parser3.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser3.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser3 } = this.p, seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser3.allActions(state, (action9) => {
        if (action9 & (262144 | 131072)) ;
        else if (action9 & 65536) {
          let rDepth = (action9 >> 19) - depth;
          if (rDepth > 1) {
            let term = action9 & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser3.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action9, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser3 } = this.p;
    return parser3.data[parser3.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser3.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action9) {
    let term = action9 & 65535, depth = action9 >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index2) {
    this.stack = stack;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range, index2 = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index2)
        return null;
      let next = this.ranges[--index2];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index2 == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index2];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id) {
    this.data = data;
    this.id = id;
  }
  token(input, stack) {
    let { parser: parser3 } = stack.p;
    readToken(this.data, input, stack, this.id, parser3.data, parser3.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data[state]) == 0)
      break;
    let accEnd = data[state + 1];
    for (let i = state + 3; i < accEnd; i += 2)
      if ((data[i + 1] & groupMask) > 0) {
        let term = data[i];
        if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
    let next = input.next, low = 0, high = data[state + 2];
    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index2 = accEnd + mid + (mid << 1);
      let from = data[index2], to = data[index2 + 1] || 65536;
      if (next < from)
        high = mid;
      else if (next >= to)
        low = mid + 1;
      else {
        state = data[index2 + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index2 = this.index[last];
      if (index2 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index2];
      let start = this.start[last] + top2.positions[index2];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser3, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser3.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser3 } = stack.p, { tokenizers } = parser3;
    let mask = parser3.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser3 } = stack.p;
      for (let i = 0; i < parser3.specialized.length; i++)
        if (parser3.specialized[i] == token.value) {
          let result = parser3.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action9, token, end, index2) {
    for (let i = 0; i < index2; i += 3)
      if (this.actions[i] == action9)
        return index2;
    this.actions[index2++] = action9;
    this.actions[index2++] = token;
    this.actions[index2++] = end;
    return index2;
  }
  addActions(stack, token, end, index2) {
    let { state } = stack, { parser: parser3 } = stack.p, { data } = parser3;
    for (let set = 0; set < 2; set++) {
      for (let i = parser3.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index2 == 0 && data[i + 1] == 2)
              index2 = this.putAction(pair(data, i + 2), token, end, index2);
            break;
          }
        }
        if (data[i] == token)
          index2 = this.putAction(pair(data, i + 1), token, end, index2);
      }
    }
    return index2;
  }
};
var Parse = class {
  constructor(parser3, input, fragments, ranges) {
    this.parser = parser3;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser3, this.stream);
    this.topTerm = parser3.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser3.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser3.bufferLength * 4 ? new FragmentCursor(fragments, parser3.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i = 0; i < newStacks.length - 1; i++) {
        let stack = newStacks[i];
        for (let j = i + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12)
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser3 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser3.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser3.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser3.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser3.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action9 = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action9, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action9 & 65536) == 0 ? "shift" : `reduce of ${parser3.getName(
          action9 & 65535
          /* Action.ValueMask */
        )}`} for ${parser3.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done2 = this.advanceFully(stack, newStacks);
        if (done2)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done2 = this.advanceFully(force, newStacks);
        if (done2)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id)
      stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
    return id + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var LRParser = class _LRParser extends Parser2 {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action9) {
    return !!this.allActions(state, (a) => a == action9 ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action9) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action9(deflt) : void 0;
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      result = action9(pair(this.data, i + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config3) {
    let copy = Object.assign(Object.create(_LRParser.prototype), this);
    if (config3.props)
      copy.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy.top = info;
    }
    if (config3.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config3.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config3.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config3.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config3.contextTracker)
      copy.context = config3.contextTracker;
    if (config3.dialect)
      copy.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy.strict = config3.strict;
    if (config3.wrap)
      copy.wrappers = copy.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy.bufferLength = config3.bufferLength;
    return copy;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id = values.indexOf(part);
        if (id >= 0)
          flags[id] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/json/dist/index.js
var jsonHighlighting = styleTags({
  String: tags.string,
  Number: tags.number,
  "True False": tags.bool,
  PropertyName: tags.propertyName,
  Null: tags.null,
  ", :": tags.separator,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});
var parser2 = LRParser.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { "JsonText": [0, 1] },
  tokenPrec: 0
});

// node_modules/@codemirror/lang-json/dist/index.js
var jsonLanguage = /* @__PURE__ */ LRLanguage.define({
  name: "json",
  parser: /* @__PURE__ */ parser2.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Object: /* @__PURE__ */ continuedIndent({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ continuedIndent({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Object Array": foldInside
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function json() {
  return new LanguageSupport(jsonLanguage);
}

// src/components/TryItConsole/Params.tsx
import React39 from "react";
import { Field as Field3 } from "react-final-form";
import { FieldArray } from "react-final-form-arrays";
import validator2 from "validator";
import { useMemo as useMemo2 } from "react";
import { Fragment as Fragment11, jsx as jsx46, jsxs as jsxs33 } from "react/jsx-runtime";
var required2 = (value) => !value && value !== 0 || validator2.isEmpty(`${value}`.trim()) ? "Field is required" : void 0;
var Params = ({ fields, path }) => {
  const params = useMemo2(() => {
    const tmp = [];
    fields.forEach((field) => {
      var _a2, _b;
      const isEnum = ((_a2 = field.schema.enum) == null ? void 0 : _a2.length) > 0;
      const options2 = [
        field.required ? false : { value: "", label: "" },
        ...(_b = field.schema.enum) == null ? void 0 : _b.map((item) => ({ value: item, label: item }))
      ].filter(Boolean);
      tmp.push({
        type: field.schema.type,
        isEnum,
        name: `${path}.${field.name}`,
        options: options2,
        label: field.name,
        required: field.required,
        placeholder: Array.isArray(field.schema.type) ? field.schema.type.join(",") : field.schema.type
      });
    });
    return tmp;
  }, [fields, path]);
  return /* @__PURE__ */ jsx46(Fragment11, { children: params.map((parameter, index2) => /* @__PURE__ */ jsx46("div", { children: parameter.type === "array" ? /* @__PURE__ */ jsx46(FieldArray, { name: parameter.name, children: ({ fields: fields2 }) => {
    return /* @__PURE__ */ jsxs33(Fragment11, { children: [
      /* @__PURE__ */ jsxs33(ArrayFieldContainer, { children: [
        /* @__PURE__ */ jsxs33(Label2, { children: [
          parameter.label,
          " (",
          fields2.length,
          " items)"
        ] }),
        /* @__PURE__ */ jsx46("span", { onClick: () => fields2.push(""), children: "Add item +" })
      ] }),
      fields2.map((fieldName, index3) => /* @__PURE__ */ jsxs33(ArrayItem, { children: [
        /* @__PURE__ */ jsx46(DeleteButton, { onClick: () => fields2.remove(index3), children: "delete" }),
        /* @__PURE__ */ jsx46(
          Field3,
          {
            name: fieldName,
            validate: parameter.required ? required2 : void 0,
            children: ({ input, meta: meta2 }) => {
              return /* @__PURE__ */ jsx46(
                Input,
                {
                  input,
                  meta: meta2,
                  label: `[${index3}]`,
                  required: parameter.required,
                  placeholder: "string"
                }
              );
            }
          }
        )
      ] }, fieldName))
    ] });
  } }) : /* @__PURE__ */ jsx46(Field3, { name: parameter.name, validate: parameter.required ? required2 : void 0, children: ({ input, meta: meta2 }) => {
    if (parameter.isEnum) {
      return /* @__PURE__ */ jsx46(
        DropdownOrLabel,
        {
          variant: "dark",
          options: parameter.options,
          onChange: (value) => input.onChange(value.value),
          value: input.value,
          Label: MimeLabel2,
          Dropdown: InvertedSimpleDropdown
        }
      );
    }
    return /* @__PURE__ */ jsx46(
      Input,
      {
        input,
        meta: meta2,
        label: parameter.label,
        required: parameter.required,
        placeholder: parameter.placeholder
      }
    );
  } }) }, index2)) });
};
var Params_default = React39.memo(Params);

// src/components/TryItConsole/RequestBody.tsx
import { getIn } from "final-form";
import { useCallback as useCallback3, useMemo as useMemo3, useState as useState4 } from "react";
import { jsx as jsx47, jsxs as jsxs34 } from "react/jsx-runtime";
function DropdownWithinHeader(props) {
  return /* @__PURE__ */ jsx47(DropdownOrLabel, { ...props, Label: MimeLabel2, Dropdown: InvertedSimpleDropdown });
}
var config2 = { subscription: { errors: true, touched: true } };
var RequestBody = ({
  initialExpanded,
  serverOptions,
  mimeOptions,
  sections,
  security,
  requestBody
}) => {
  const [expanded, setExpanded] = useState4(initialExpanded);
  const expandAuth = useCallback3(() => setExpanded((old) => old === 1 ? 0 : 1), []);
  const expandParams = useCallback3(() => setExpanded((old) => old === 2 ? 0 : 2), []);
  const expandBody = useCallback3(() => setExpanded((old) => old === 3 ? 0 : 3), []);
  const formState = useFormState(config2);
  const valid = useMemo3(() => {
    const { touched = {}, errors = {} } = formState;
    const touchedKeys = Object.keys(touched);
    const authKeys = touchedKeys.filter((key2) => key2.startsWith("auth."));
    const parameterKeys = touchedKeys.filter(
      (key2) => ["query", "path", "header", "cookie"].some((option) => key2.startsWith(`${option}.`))
    );
    return {
      auth: authKeys.length === 0 || !authKeys.some((key2) => touched[key2] === true && !!getIn(errors, key2)),
      parameters: parameterKeys.length === 0 || !parameterKeys.some((key2) => touched[key2] === true && !!getIn(errors, key2)),
      body: true
    };
  }, [formState]);
  return /* @__PURE__ */ jsxs34(IntRequestBody, { children: [
    /* @__PURE__ */ jsx47(Title, { children: "Target server:" }),
    /* @__PURE__ */ jsx47(Field4, { name: "server", children: ({ input }) => /* @__PURE__ */ jsx47(
      DropdownWithinHeader,
      {
        variant: "dark",
        options: serverOptions,
        onChange: (value) => input.onChange(value.value),
        value: input.value
      }
    ) }),
    security.length > 0 && /* @__PURE__ */ jsxs34(Section2, { children: [
      /* @__PURE__ */ jsxs34(SectionHeader, { onClick: expandAuth, expanded: expanded === 1, children: [
        /* @__PURE__ */ jsxs34(SectionHeaderText, { children: [
          /* @__PURE__ */ jsx47("span", { children: "Security" }),
          /* @__PURE__ */ jsx47(ShelfIcon, { size: "14px", color: "white", direction: expanded === 1 ? "down" : "right" })
        ] }),
        valid.auth ? /* @__PURE__ */ jsx47(PadlockIcon, { size: "14px", color: "success" }) : /* @__PURE__ */ jsx47(ErrorIcon, { size: "14px" })
      ] }),
      /* @__PURE__ */ jsxs34(SectionContent, { expanded: expanded === 1, children: [
        security.map((security2, index2) => /* @__PURE__ */ jsx47(Auths_default, { definitions: security2.schemes }, index2)),
        /* @__PURE__ */ jsxs34("small", { children: [
          /* @__PURE__ */ jsx47("strong", { children: "Note" }),
          ": Your credentials will be saved until the end of the browser session"
        ] })
      ] })
    ] }),
    requestBody && /* @__PURE__ */ jsxs34(Section2, { children: [
      /* @__PURE__ */ jsx47(SectionHeader, { onClick: expandBody, expanded: expanded === 3, children: /* @__PURE__ */ jsxs34(SectionHeaderText, { children: [
        /* @__PURE__ */ jsx47("span", { children: "Body" }),
        /* @__PURE__ */ jsx47(ShelfIcon, { size: "14px", color: "white", direction: expanded === 3 ? "down" : "right" })
      ] }) }),
      /* @__PURE__ */ jsxs34(SectionContent, { expanded: expanded === 3, children: [
        /* @__PURE__ */ jsx47(Field4, { name: "request.mimeType", children: ({ input }) => /* @__PURE__ */ jsx47(
          DropdownWithinHeader,
          {
            variant: "dark",
            options: mimeOptions,
            onChange: (value) => input.onChange(value.value),
            value: input.value
          }
        ) }),
        /* @__PURE__ */ jsx47(Field4, { name: "request.body", children: ({ input }) => /* @__PURE__ */ jsx47(
          esm_default,
          {
            value: input.value,
            height: "500px",
            theme: material,
            extensions: [json()],
            onChange: (value) => {
              input.onChange(value);
            }
          }
        ) })
      ] })
    ] }),
    Object.keys(sections).length > 0 && /* @__PURE__ */ jsxs34(Section2, { children: [
      /* @__PURE__ */ jsxs34(SectionHeader, { onClick: expandParams, expanded: expanded === 2, children: [
        /* @__PURE__ */ jsxs34(SectionHeaderText, { children: [
          /* @__PURE__ */ jsx47("span", { children: "Parameters" }),
          /* @__PURE__ */ jsx47(ShelfIcon, { size: "14px", color: "white", direction: expanded === 2 ? "down" : "right" })
        ] }),
        valid.parameters ? null : /* @__PURE__ */ jsx47(ErrorIcon, { size: "14px" })
      ] }),
      /* @__PURE__ */ jsx47(SectionContent, { expanded: expanded === 2, children: Object.keys(sections).map((key2, index2) => /* @__PURE__ */ jsxs34(React40.Fragment, { children: [
        /* @__PURE__ */ jsxs34(SectionTitle, { children: [
          "# ",
          key2,
          " parameters"
        ] }),
        /* @__PURE__ */ jsx47(Params_default, { fields: sections[key2], path: key2 })
      ] }, index2)) })
    ] })
  ] });
};
var RequestBody_default = React40.memo(RequestBody);

// src/components/TryItConsole/TryItConsole.tsx
import { Fragment as Fragment12, jsx as jsx48, jsxs as jsxs35 } from "react/jsx-runtime";
var opts = new RedocNormalizedOptions({});
var subscription = { values: true };
var mutators = {
  ...arrayMutators
};
var decorator = createDecorator();
var calculate = createCalculator({
  field: /auth/,
  updates: (_a2, _b, allValues, prevValues) => {
    if (!allValues || !prevValues) {
      return {};
    }
    sessionStorage.setItem("saved-auth", JSON.stringify({ auth: allValues.auth }));
    return {};
  }
});
var undecorate = [decorator, calculate];
var getInitialState = () => {
  const savedState = sessionStorage.getItem("saved-auth");
  let json2 = {};
  if (savedState) {
    try {
      json2 = JSON.parse(savedState);
    } catch (e) {
    }
  }
  return json2;
};
var createSearch = (data) => {
  const ret = [];
  Object.keys(data).forEach((key2) => {
    const one = data[key2];
    if (key2 !== "" && one && one !== "") {
      ret.push(`${key2}=${encodeURIComponent(one)}`);
    }
  });
  return ret.length > 0 ? `?${ret.join("&")}` : "";
};
var TryItConsole = observer11(({ operation, onClose }) => {
  const [activeTab, setActiveTab] = useState5(0);
  const [content2, setContent] = useState5(null);
  const [headers, setHeaders] = useState5(null);
  const [meta2, setMetadata] = useState5(null);
  const [submitting, setSubmitting] = useState5(false);
  const [submitted, setSubmitted] = useState5(false);
  const fetchData = useCallback4(
    async (formData) => {
      setSubmitting(true);
      const parser3 = new OpenAPIParser({ openapi: "3.0.1" }, void 0, opts);
      const { server, request, query, header, path, cookie, auth } = formData;
      const startTime = Date.now();
      const headers2 = {
        "Content-Type": (request == null ? void 0 : request.mimeType) || "application/json",
        Accept: "application/json"
      };
      if (auth) {
        operation.security.forEach((security) => {
          security.schemes.forEach((schema) => {
            var _a2, _b;
            if (schema.type === "apiKey" && auth[schema.id] && schema.name) {
              if (schema.in === "header") {
                headers2[schema.name] = auth[schema.id];
              }
              if (schema.in === "cookie") {
                cookie[schema.name] = auth[schema.id];
              }
              if (schema.in === "query") {
                query[schema.name] = auth[schema.id];
              }
            } else if (schema.type === "http") {
              headers2["Authorization"] = `Basic ${btoa(
                `${(_a2 = auth.basic) == null ? void 0 : _a2.username}:${(_b = auth.basic) == null ? void 0 : _b.password}`
              )}`;
            }
          });
        });
      }
      if (header) {
        Object.keys(header).forEach((key2) => {
          headers2[key2] = header[key2];
        });
      }
      let preparedPath = operation.path;
      if (path) {
        Object.keys(path).forEach((key2) => {
          preparedPath = preparedPath.replace(key2, path[key2]);
        });
      }
      const handleResponse = (response) => {
        const time = (Date.now() - startTime) / 1e3;
        const responseHeader = new Headers(response.headers);
        const example = new ExampleModel(
          parser3,
          { value: response.data },
          responseHeader.get("Content-Type") || "application/json",
          void 0
        );
        setContent(example);
        const keys2 = responseHeader.keys();
        const tmpHeaders = {};
        let entry;
        let done2 = false;
        entry = keys2.next();
        do {
          const key2 = entry.value;
          if (key2) {
            tmpHeaders[key2] = responseHeader.get(key2);
          }
          if (!entry.done) {
            entry = keys2.next();
          } else {
            done2 = true;
          }
        } while (!done2);
        setHeaders(tmpHeaders);
        setMetadata({
          status: response.status,
          statusText: response.statusText,
          size: Number(responseHeader.get("Content-Length")),
          time
        });
        setActiveTab(1);
      };
      try {
        const instance = axios.create({
          baseURL: server,
          headers: headers2
        });
        instance.interceptors.response.use(
          (response) => {
            handleResponse(response);
            return response;
          },
          (error) => {
            handleResponse(error.response);
            return Promise.reject(error);
          }
        );
        await instance[operation.httpVerb](preparedPath, {
          params: query,
          body: request == null ? void 0 : request.body
        });
      } catch (e) {
      } finally {
        setSubmitted(true);
        setSubmitting(false);
      }
    },
    [operation]
  );
  const serverOptions = useMemo4(
    () => operation.servers.map((serv) => ({
      value: serv.url,
      title: `${serv.description} - ${serv.url}`
    })),
    [operation.servers]
  );
  const initialValues = useMemo4(() => {
    var _a2, _b, _c;
    const { requestBody } = operation;
    if (requestBody && requestBody.content) {
      const {
        content: { active, mediaTypes }
      } = requestBody;
      const examples = active.examples;
      let body = "";
      const mimeType = mediaTypes[0].name;
      if (examples) {
        const example = (_a2 = Object.values(examples).find((ex) => ex.mime === mimeType)) == null ? void 0 : _a2.value;
        body = JSON.stringify(example, void 0, 2);
      }
      if (!body) {
        body = JSON.stringify(
          active == null ? void 0 : active.generateExample(operation.parser, mediaTypes[0]),
          void 0,
          2
        );
      }
      return {
        ...getInitialState(),
        server: (_b = operation.servers[0]) == null ? void 0 : _b.url,
        request: {
          mimeType,
          body
        }
      };
    }
    return {
      ...getInitialState(),
      server: (_c = operation.servers[0]) == null ? void 0 : _c.url
    };
  }, [operation]);
  const initialExpanded = useMemo4(() => {
    if (operation.security.length) {
      return 1;
    }
    if (operation.requestBody) {
      return 3;
    }
    return operation.parameters.length > 0 ? 2 : 0;
  }, [operation]);
  const sections = useMemo4(() => {
    const groups = {};
    operation.parameters.forEach((param) => {
      const key2 = param.in;
      if (!groups[key2]) {
        groups[key2] = [];
      }
      groups[key2].push(param);
    });
    return groups;
  }, [operation]);
  const mimeOptions = useMemo4(
    () => {
      var _a2, _b;
      return (_b = (_a2 = operation.requestBody) == null ? void 0 : _a2.content) == null ? void 0 : _b.mediaTypes.map((mediaType) => ({
        value: mediaType.name,
        label: mediaType.name
      }));
    },
    [operation]
  );
  const showRequest = useCallback4(() => setActiveTab(0), []);
  const showResponse = useCallback4(() => setActiveTab(1), []);
  return /* @__PURE__ */ jsx48(
    Form,
    {
      onSubmit: fetchData,
      subscription,
      initialValues,
      mutators,
      decorators: undecorate,
      children: ({ handleSubmit, values }) => {
        const preparedPath = `${operation.path}${values.query ? createSearch(values.query) : ""}`;
        return /* @__PURE__ */ jsxs35("div", { children: [
          /* @__PURE__ */ jsxs35(Header, { children: [
            /* @__PURE__ */ jsxs35("div", { children: [
              /* @__PURE__ */ jsx48(HeaderButton, { active: activeTab === 0, onClick: showRequest, children: submitted ? "Edit Request" : "Request" }, "request"),
              /* @__PURE__ */ jsx48(
                HeaderButton,
                {
                  active: activeTab === 1,
                  onClick: showResponse,
                  disabled: !submitted,
                  children: "Response"
                },
                "response"
              )
            ] }),
            /* @__PURE__ */ jsx48(Close, { onClick: onClose, children: "x" })
          ] }),
          activeTab === 0 ? /* @__PURE__ */ jsx48(
            RequestBody_default,
            {
              initialExpanded,
              serverOptions,
              sections,
              mimeOptions,
              requestBody: !!operation.requestBody,
              security: operation.security
            }
          ) : /* @__PURE__ */ jsx48(ResponseBody, { children: submitted && /* @__PURE__ */ jsxs35(Fragment12, { children: [
            meta2 && /* @__PURE__ */ jsxs35(StatusRow, { children: [
              /* @__PURE__ */ jsxs35(Meta, { color: getStatusCodeType(meta2.status), children: [
                "Status: ",
                meta2.status
              ] }),
              /* @__PURE__ */ jsxs35(Meta, { children: [
                "Time: ",
                meta2.time,
                "ms"
              ] }),
              /* @__PURE__ */ jsxs35(Meta, { children: [
                "Size: ",
                meta2.size,
                " B"
              ] })
            ] }),
            /* @__PURE__ */ jsxs35("div", { children: [
              /* @__PURE__ */ jsx48(Title, { children: "Headers:" }),
              /* @__PURE__ */ jsx48(HeadersSnippet, { children: headers && Object.keys(headers).map((key2) => /* @__PURE__ */ jsxs35("div", { children: [
                /* @__PURE__ */ jsxs35("strong", { children: [
                  key2,
                  ":"
                ] }),
                /* @__PURE__ */ jsx48("code", { children: headers[key2] })
              ] }, key2)) }),
              /* @__PURE__ */ jsx48(Title, { children: "Body:" }),
              /* @__PURE__ */ jsx48("div", { children: content2 && /* @__PURE__ */ jsx48(Example, { example: content2, mimeType: "application/json" }) })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxs35(OperationEndpointWrap, { $tryItExpanded: true, children: [
            /* @__PURE__ */ jsxs35(EndpointInfo, { children: [
              /* @__PURE__ */ jsx48(HttpVerb, { type: operation.httpVerb, $compact: false, children: operation.httpVerb }),
              /* @__PURE__ */ jsx48(ServerRelativeURL, { $wrap: true, children: preparedPath })
            ] }),
            /* @__PURE__ */ jsx48(TryItButton, { onClick: handleSubmit, children: submitting ? "Sending..." : /* @__PURE__ */ jsx48(Fragment12, { children: submitted ? "Resend" : "Send" }) })
          ] })
        ] });
      }
    }
  );
});

// src/components/Endpoint/Endpoint.tsx
import { Fragment as Fragment13, jsx as jsx49, jsxs as jsxs36 } from "react/jsx-runtime";
var Endpoint = class extends React42.Component {
  constructor(props) {
    super(props);
    this.toggle = () => {
      this.setState({ expanded: !this.state.expanded });
    };
    this.toggleTryIt = (event) => {
      event.stopPropagation();
      event.preventDefault();
      this.setState({ tryItExpanded: !this.state.tryItExpanded, expanded: false });
    };
    this.state = {
      expanded: false,
      tryItExpanded: false
    };
  }
  render() {
    const { operation, inverted, hideHostname } = this.props;
    const { expanded, tryItExpanded } = this.state;
    return /* @__PURE__ */ jsx49(OptionsContext.Consumer, { children: (options2) => /* @__PURE__ */ jsx49(Fragment13, { children: tryItExpanded ? /* @__PURE__ */ jsx49(TryItConsole, { onClose: this.toggleTryIt, operation }) : /* @__PURE__ */ jsxs36("div", { children: [
      /* @__PURE__ */ jsxs36(
        OperationEndpointWrap,
        {
          onClick: this.toggle,
          $expanded: expanded,
          $inverted: inverted,
          $tryItExpanded: tryItExpanded,
          children: [
            /* @__PURE__ */ jsxs36(EndpointInfo, { children: [
              /* @__PURE__ */ jsx49(HttpVerb, { type: operation.httpVerb, $compact: this.props.compact, children: operation.httpVerb }),
              /* @__PURE__ */ jsx49(ServerRelativeURL, { children: operation.path }),
              /* @__PURE__ */ jsx49(
                ShelfIcon,
                {
                  float: "right",
                  color: inverted ? "black" : "rgba(245, 247, 250)",
                  size: "20px",
                  direction: expanded ? "down" : "right"
                }
              )
            ] }),
            /* @__PURE__ */ jsx49(TryItButton, { onClick: this.toggleTryIt, children: "Try it" })
          ]
        }
      ),
      expanded && /* @__PURE__ */ jsx49(Servers, { "aria-hidden": !expanded, children: operation.servers.map((server) => {
        const normalizedUrl = options2.expandDefaultServerVariables ? expandDefaultServerVariables(server.url, server.variables) : server.url;
        const basePath = getBasePath(normalizedUrl);
        return /* @__PURE__ */ jsxs36(ServerItem, { children: [
          /* @__PURE__ */ jsx49(Markdown, { source: server.description || "", compact: true }),
          /* @__PURE__ */ jsx49(SelectOnClick, { children: /* @__PURE__ */ jsxs36(ServerUrl, { children: [
            /* @__PURE__ */ jsx49("span", { children: hideHostname || options2.hideHostname ? basePath === "/" ? "" : basePath : normalizedUrl }),
            operation.path
          ] }) })
        ] }, normalizedUrl);
      }) })
    ] }) }) });
  }
};

// src/components/Parameters/Parameters.tsx
import React45 from "react";

// src/components/Parameters/ParametersGroup.tsx
import React43 from "react";
import { jsx as jsx50, jsxs as jsxs37 } from "react/jsx-runtime";
var ParametersGroup = class extends React43.PureComponent {
  render() {
    const { place, parameters } = this.props;
    if (!parameters || !parameters.length) {
      return null;
    }
    return /* @__PURE__ */ jsxs37("div", { children: [
      /* @__PURE__ */ jsxs37(UnderlinedHeader, { children: [
        place,
        " Parameters"
      ] }),
      /* @__PURE__ */ jsx50(PropertiesTable, { children: /* @__PURE__ */ jsx50("tbody", { children: mapWithLast(parameters, (field, isLast) => /* @__PURE__ */ jsx50(Field, { isLast, field, showExamples: true }, field.name)) }) })
    ] }, place);
  }
};

// src/components/MediaTypeSwitch/MediaTypesSwitch.tsx
import { observer as observer12 } from "mobx-react";
import React44 from "react";
import { Fragment as Fragment14, jsx as jsx51, jsxs as jsxs38 } from "react/jsx-runtime";
var MediaTypesSwitch = class extends React44.Component {
  constructor() {
    super(...arguments);
    this.switchMedia = ({ idx }) => {
      if (this.props.content && idx !== void 0) {
        this.props.content.activate(idx);
      }
    };
  }
  render() {
    const { content: content2 } = this.props;
    if (!content2 || !content2.mediaTypes || !content2.mediaTypes.length) {
      return null;
    }
    const activeMimeIdx = content2.activeMimeIdx;
    const options2 = content2.mediaTypes.map((mime, idx) => {
      return {
        value: mime.name,
        idx
      };
    });
    const Wrapper3 = ({ children }) => this.props.withLabel ? /* @__PURE__ */ jsxs38(DropdownWrapper, { children: [
      /* @__PURE__ */ jsx51(DropdownLabel, { children: "Content type" }),
      children
    ] }) : children;
    return /* @__PURE__ */ jsxs38(Fragment14, { children: [
      /* @__PURE__ */ jsx51(Wrapper3, { children: this.props.renderDropdown({
        value: options2[activeMimeIdx].value,
        options: options2,
        onChange: this.switchMedia,
        ariaLabel: "Content type"
      }) }),
      this.props.children(content2.active)
    ] });
  }
};
MediaTypesSwitch = __decorateClass([
  observer12
], MediaTypesSwitch);

// src/components/Parameters/Parameters.tsx
import { Fragment as Fragment15, jsx as jsx52, jsxs as jsxs39 } from "react/jsx-runtime";
function safePush(obj, prop, item) {
  if (!obj[prop]) {
    obj[prop] = [];
  }
  obj[prop].push(item);
}
var PARAM_PLACES = ["path", "query", "cookie", "header"];
var Parameters = class extends React45.PureComponent {
  orderParams(params) {
    const res = {};
    params.forEach((param) => {
      safePush(res, param.in, param);
    });
    return res;
  }
  render() {
    const { body, parameters = [] } = this.props;
    if (body === void 0 && parameters === void 0) {
      return null;
    }
    const paramsMap = this.orderParams(parameters);
    const paramsPlaces = parameters.length > 0 ? PARAM_PLACES : [];
    const bodyContent = body && body.content;
    const bodyDescription = body && body.description;
    const bodyRequired = body && body.required;
    return /* @__PURE__ */ jsxs39(Fragment15, { children: [
      paramsPlaces.map((place) => /* @__PURE__ */ jsx52(ParametersGroup, { place, parameters: paramsMap[place] }, place)),
      bodyContent && /* @__PURE__ */ jsx52(
        BodyContent,
        {
          content: bodyContent,
          description: bodyDescription,
          bodyRequired
        }
      )
    ] });
  }
};
function DropdownWithinHeader2({
  bodyRequired,
  ...props
}) {
  const isRequired = typeof bodyRequired === "boolean" && !!bodyRequired;
  const isOptional = typeof bodyRequired === "boolean" && !bodyRequired;
  return /* @__PURE__ */ jsxs39(UnderlinedHeader, { children: [
    "Request Body schema: ",
    /* @__PURE__ */ jsx52(DropdownOrLabel, { ...props }),
    isRequired && /* @__PURE__ */ jsx52(RequiredBody, { children: "required" }),
    isOptional && /* @__PURE__ */ jsx52(OptionalBody, { children: "optional" })
  ] }, "header");
}
function BodyContent(props) {
  const { content: content2, description, bodyRequired } = props;
  const { isRequestType } = content2;
  return /* @__PURE__ */ jsx52(
    MediaTypesSwitch,
    {
      content: content2,
      renderDropdown: (props2) => /* @__PURE__ */ jsx52(DropdownWithinHeader2, { bodyRequired, ...props2 }),
      children: ({ schema }) => {
        return /* @__PURE__ */ jsxs39(Fragment15, { children: [
          description !== void 0 && /* @__PURE__ */ jsx52(Markdown, { source: description }),
          (schema == null ? void 0 : schema.type) === "object" && /* @__PURE__ */ jsx52(ConstraintsView, { constraints: (schema == null ? void 0 : schema.constraints) || [] }),
          /* @__PURE__ */ jsx52(
            Schema,
            {
              skipReadOnly: isRequestType,
              skipWriteOnly: !isRequestType,
              schema
            },
            "schema"
          )
        ] });
      }
    }
  );
}
var commonStyles = `
  text-transform: lowercase;
  margin-left: 0;
  line-height: 1.5em;
`;
var RequiredBody = styled_components_default(RequiredLabel)`
  ${commonStyles}
`;
var OptionalBody = styled_components_default("div")`
  ${commonStyles}
  color: ${({ theme: theme2 }) => theme2.colors.text.secondary};
  font-size: ${(props) => props.theme.schema.labelsTextSize};
`;

// src/components/Responses/ResponsesList.tsx
import React50 from "react";

// src/components/Responses/Response.tsx
import React49 from "react";
import { observer as observer13 } from "mobx-react";

// src/components/Responses/ResponseDetails.tsx
import React48 from "react";

// src/components/Responses/ResponseHeaders.tsx
import React47 from "react";

// src/components/Responses/ResponseTitle.tsx
import React46 from "react";
import { jsx as jsx53, jsxs as jsxs40 } from "react/jsx-runtime";
function ResponseTitleComponent({
  title,
  type,
  empty: empty2,
  code,
  opened,
  className,
  onClick
}) {
  return /* @__PURE__ */ jsxs40(
    "button",
    {
      className,
      onClick: !empty2 && onClick || void 0,
      "aria-expanded": opened,
      disabled: empty2,
      children: [
        !empty2 && /* @__PURE__ */ jsx53(
          ShelfIcon,
          {
            size: "1.5em",
            color: type,
            direction: opened ? "down" : "right",
            float: "left"
          }
        ),
        /* @__PURE__ */ jsxs40(Code, { children: [
          code,
          " "
        ] }),
        /* @__PURE__ */ jsx53(Markdown, { compact: true, inline: true, source: title })
      ]
    }
  );
}
var ResponseTitle = React46.memo(ResponseTitleComponent);

// src/components/Responses/styled.elements.ts
var StyledResponseTitle = styled_components_default(ResponseTitle)`
  display: block;
  border: 0;
  width: 100%;
  text-align: left;
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  cursor: pointer;

  color: ${(props) => props.theme.colors.responses[props.type].color};
  background-color: ${(props) => props.theme.colors.responses[props.type].backgroundColor};
  &:focus {
    outline: auto ${(props) => props.theme.colors.responses[props.type].color};
  }
  ${(props) => props.empty && `
cursor: default;
&::before {
  content: "\u2014";
  font-weight: bold;
  width: 1.5em;
  text-align: center;
  display: inline-block;
  vertical-align: top;
}
&:focus {
  outline: 0;
}
` || ""};
`;
var ResponseDetailsWrap = styled_components_default.div`
  padding: 10px;
`;
var HeadersCaption = styled_components_default(UnderlinedHeader).attrs({
  as: "caption"
})`
  text-align: left;
  margin-top: 1em;
  caption-side: top;
`;
var Code = styled_components_default.strong`
  vertical-align: top;
`;

// src/components/Responses/ResponseHeaders.tsx
import { jsx as jsx54, jsxs as jsxs41 } from "react/jsx-runtime";
var ResponseHeaders = class extends React47.PureComponent {
  render() {
    const { headers } = this.props;
    if (headers === void 0 || headers.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxs41(PropertiesTable, { children: [
      /* @__PURE__ */ jsx54(HeadersCaption, { children: " Response Headers " }),
      /* @__PURE__ */ jsx54("tbody", { children: mapWithLast(headers, (header, isLast) => /* @__PURE__ */ jsx54(Field, { isLast, field: header, showExamples: true }, header.name)) })
    ] });
  }
};

// src/components/Responses/ResponseDetails.tsx
import { Fragment as Fragment16, jsx as jsx55, jsxs as jsxs42 } from "react/jsx-runtime";
var ResponseDetails = class extends React48.PureComponent {
  constructor() {
    super(...arguments);
    this.renderDropdown = (props) => {
      return /* @__PURE__ */ jsxs42(UnderlinedHeader, { children: [
        "Response Schema: ",
        /* @__PURE__ */ jsx55(DropdownOrLabel, { ...props })
      ] }, "header");
    };
  }
  render() {
    const { description, extensions, headers, content: content2 } = this.props.response;
    return /* @__PURE__ */ jsxs42(Fragment16, { children: [
      description && /* @__PURE__ */ jsx55(Markdown, { source: description }),
      /* @__PURE__ */ jsx55(Extensions, { extensions }),
      /* @__PURE__ */ jsx55(ResponseHeaders, { headers }),
      /* @__PURE__ */ jsx55(MediaTypesSwitch, { content: content2, renderDropdown: this.renderDropdown, children: ({ schema }) => {
        return /* @__PURE__ */ jsxs42(Fragment16, { children: [
          (schema == null ? void 0 : schema.type) === "object" && /* @__PURE__ */ jsx55(ConstraintsView, { constraints: (schema == null ? void 0 : schema.constraints) || [] }),
          /* @__PURE__ */ jsx55(Schema, { skipWriteOnly: true, schema }, "schema")
        ] });
      } })
    ] });
  }
};

// src/components/Responses/Response.tsx
import { jsx as jsx56, jsxs as jsxs43 } from "react/jsx-runtime";
var ResponseView = observer13(({ response }) => {
  const { extensions, headers, type, summary, description, code, expanded, content: content2 } = response;
  const mimes = React49.useMemo(
    () => content2 === void 0 ? [] : content2.mediaTypes.filter((mime) => mime.schema !== void 0),
    [content2]
  );
  const empty2 = React49.useMemo(
    () => (!extensions || Object.keys(extensions).length === 0) && headers.length === 0 && mimes.length === 0 && !description,
    [extensions, headers, mimes, description]
  );
  return /* @__PURE__ */ jsxs43("div", { children: [
    /* @__PURE__ */ jsx56(
      StyledResponseTitle,
      {
        onClick: () => response.toggle(),
        type,
        empty: empty2,
        title: summary || "",
        code,
        opened: expanded
      }
    ),
    expanded && !empty2 && /* @__PURE__ */ jsx56(ResponseDetailsWrap, { children: /* @__PURE__ */ jsx56(ResponseDetails, { response }) })
  ] });
});

// src/components/Responses/ResponsesList.tsx
import { jsx as jsx57, jsxs as jsxs44 } from "react/jsx-runtime";
var ResponsesHeader = styled_components_default.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: theme2 }) => theme2.colors.text.primary};
  font-weight: normal;
`;
var ResponsesList = class extends React50.PureComponent {
  render() {
    const { responses, isCallback } = this.props;
    if (!responses || responses.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxs44("div", { children: [
      /* @__PURE__ */ jsx57(ResponsesHeader, { children: isCallback ? l("callbackResponses") : l("responses") }),
      responses.map((response) => {
        return /* @__PURE__ */ jsx57(ResponseView, { response }, response.code);
      })
    ] });
  }
};

// src/components/SecurityRequirement/SecurityRequirement.tsx
import { useState as useState6 } from "react";

// src/components/SecurityRequirement/SecurityHeader.tsx
import { jsx as jsx58, jsxs as jsxs45 } from "react/jsx-runtime";
function SecurityHeader(props) {
  const { security, showSecuritySchemeType, expanded } = props;
  const grouping = security.schemes.length > 1;
  if (security.schemes.length === 0)
    return /* @__PURE__ */ jsx58(SecurityRequirementOrWrap, { $expanded: expanded, children: "None" });
  return /* @__PURE__ */ jsxs45(SecurityRequirementOrWrap, { $expanded: expanded, children: [
    grouping && "(",
    security.schemes.map((scheme) => {
      return /* @__PURE__ */ jsxs45(SecurityRequirementAndWrap, { children: [
        showSecuritySchemeType && `${AUTH_TYPES[scheme.type] || scheme.type}: `,
        /* @__PURE__ */ jsx58("i", { children: scheme.displayName }),
        expanded && scheme.scopes.length ? [
          " (",
          scheme.scopes.map((scope) => /* @__PURE__ */ jsx58(ScopeName, { children: scope }, scope)),
          ") "
        ] : null
      ] }, scheme.id);
    }),
    grouping && ") "
  ] });
}

// src/components/SecurityRequirement/RequiredScopesRow.tsx
import React51 from "react";
import { jsx as jsx59, jsxs as jsxs46 } from "react/jsx-runtime";
var RequiredScopesRow = ({ scopes }) => {
  if (!scopes.length) return null;
  return /* @__PURE__ */ jsxs46("div", { children: [
    /* @__PURE__ */ jsx59("b", { children: "Required scopes: " }),
    scopes.map((scope, idx) => {
      return /* @__PURE__ */ jsxs46(React51.Fragment, { children: [
        /* @__PURE__ */ jsx59("code", { children: scope }),
        " "
      ] }, idx);
    })
  ] });
};

// src/components/SecurityRequirement/SecurityRequirement.tsx
import { Fragment as Fragment17, jsx as jsx60, jsxs as jsxs47 } from "react/jsx-runtime";
function SecurityRequirements(props) {
  const store2 = useStore();
  const showSecuritySchemeType = store2 == null ? void 0 : store2.options.showSecuritySchemeType;
  const [expanded, setExpanded] = useState6(false);
  const { securities } = props;
  if (!(securities == null ? void 0 : securities.length) || (store2 == null ? void 0 : store2.options.hideSecuritySection)) {
    return null;
  }
  const operationSecuritySchemes = store2 == null ? void 0 : store2.spec.securitySchemes.schemes.filter(({ id }) => {
    return securities.find((security) => security.schemes.find((scheme) => scheme.id === id));
  });
  return /* @__PURE__ */ jsxs47(Fragment17, { children: [
    /* @__PURE__ */ jsxs47(Wrap, { $expanded: expanded, children: [
      /* @__PURE__ */ jsxs47(AuthHeaderColumn, { onClick: () => setExpanded(!expanded), children: [
        /* @__PURE__ */ jsx60(AuthHeader, { children: "Authorizations:" }),
        /* @__PURE__ */ jsx60(ShelfIcon, { size: "1.3em", direction: expanded ? "down" : "right" })
      ] }),
      /* @__PURE__ */ jsx60(SecuritiesColumn, { $expanded: expanded, children: securities.map((security, idx) => /* @__PURE__ */ jsx60(
        SecurityHeader,
        {
          expanded,
          showSecuritySchemeType,
          security
        },
        idx
      )) })
    ] }),
    expanded && !!(operationSecuritySchemes == null ? void 0 : operationSecuritySchemes.length) && operationSecuritySchemes.map((scheme, idx) => /* @__PURE__ */ jsxs47(SecurityDetailsStyle, { children: [
      /* @__PURE__ */ jsxs47("h5", { children: [
        /* @__PURE__ */ jsx60(LockIcon, {}),
        " ",
        AUTH_TYPES[scheme.type] || scheme.type,
        ": ",
        scheme.id
      ] }),
      /* @__PURE__ */ jsx60(Markdown, { source: scheme.description || "" }),
      /* @__PURE__ */ jsx60(
        SecurityDetails,
        {
          scheme,
          RequiredScopes: /* @__PURE__ */ jsx60(RequiredScopesRow, { scopes: getRequiredScopes(scheme.id, securities) })
        },
        scheme.id
      )
    ] }, idx))
  ] });
}
var LockIcon = () => /* @__PURE__ */ jsx60("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "11", height: "11", children: /* @__PURE__ */ jsx60(
  "path",
  {
    fill: "currentColor",
    d: "M18 10V6A6 6 0 0 0 6 6v4H3v14h18V10h-3zM8 6c0-2.206 1.794-4 4-4s4 1.794 4 4v4H8V6zm11 16H5V12h14v10z"
  }
) });
function getRequiredScopes(id, securities) {
  const allScopes = [];
  let securitiesLength = securities.length;
  while (securitiesLength--) {
    const security = securities[securitiesLength];
    let schemesLength = security.schemes.length;
    while (schemesLength--) {
      const scheme = security.schemes[schemesLength];
      if (scheme.id === id && Array.isArray(scheme.scopes)) {
        allScopes.push(...scheme.scopes);
      }
    }
  }
  return Array.from(new Set(allScopes));
}

// src/components/Callbacks/CallbackDetails.tsx
import { jsx as jsx61, jsxs as jsxs48 } from "react/jsx-runtime";
var CallbackDetails = class extends React52.Component {
  render() {
    const { operation } = this.props;
    const { description, externalDocs } = operation;
    const hasDescription = !!(description || externalDocs);
    return /* @__PURE__ */ jsxs48(CallbackDetailsWrap, { children: [
      hasDescription && /* @__PURE__ */ jsxs48(Description, { children: [
        description !== void 0 && /* @__PURE__ */ jsx61(Markdown, { source: description }),
        externalDocs && /* @__PURE__ */ jsx61(ExternalDocumentation, { externalDocs })
      ] }),
      /* @__PURE__ */ jsx61(Endpoint, { operation: this.props.operation, inverted: true, compact: true }),
      /* @__PURE__ */ jsx61(Extensions, { extensions: operation.extensions }),
      /* @__PURE__ */ jsx61(SecurityRequirements, { securities: operation.security }),
      /* @__PURE__ */ jsx61(Parameters, { parameters: operation.parameters, body: operation.requestBody }),
      /* @__PURE__ */ jsx61(ResponsesList, { responses: operation.responses, isCallback: operation.isCallback })
    ] });
  }
};
CallbackDetails = __decorateClass([
  observer14
], CallbackDetails);
var Description = styled_components_default.div`
  margin-bottom: ${({ theme: theme2 }) => theme2.spacing.unit * 3}px;
`;

// src/components/Callbacks/CallbackOperation.tsx
import { Fragment as Fragment18, jsx as jsx62, jsxs as jsxs49 } from "react/jsx-runtime";
var CallbackOperation = class extends React53.Component {
  constructor() {
    super(...arguments);
    this.toggle = () => {
      this.props.callbackOperation.toggle();
    };
  }
  render() {
    const { name: name2, expanded, httpVerb, deprecated } = this.props.callbackOperation;
    return /* @__PURE__ */ jsxs49(Fragment18, { children: [
      /* @__PURE__ */ jsx62(
        StyledCallbackTitle,
        {
          onClick: this.toggle,
          name: name2,
          opened: expanded,
          httpVerb,
          deprecated
        }
      ),
      expanded && /* @__PURE__ */ jsx62(CallbackDetails, { operation: this.props.callbackOperation })
    ] });
  }
};
CallbackOperation = __decorateClass([
  observer15
], CallbackOperation);

// src/components/Callbacks/CallbacksList.tsx
import React54 from "react";
import { jsx as jsx63, jsxs as jsxs50 } from "react/jsx-runtime";
var CallbacksList = class extends React54.PureComponent {
  render() {
    const { callbacks } = this.props;
    if (!callbacks || callbacks.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxs50("div", { children: [
      /* @__PURE__ */ jsx63(CallbacksHeader, { children: " Callbacks " }),
      callbacks.map((callback) => {
        return callback.operations.map((operation, index2) => {
          return /* @__PURE__ */ jsx63(CallbackOperation, { callbackOperation: operation }, `${callback.name}_${index2}`);
        });
      })
    ] });
  }
};
var CallbacksHeader = styled_components_default.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: theme2 }) => theme2.colors.text.primary};
  font-weight: normal;
`;

// src/components/CallbackSamples/CallbackSamples.tsx
import { observer as observer18 } from "mobx-react";
import React58 from "react";

// src/components/GenericChildrenSwitcher/GenericChildrenSwitcher.tsx
import { observer as observer16 } from "mobx-react";
import React55 from "react";
import { Fragment as Fragment19, jsx as jsx64, jsxs as jsxs51 } from "react/jsx-runtime";
var GenericChildrenSwitcher = class extends React55.Component {
  constructor(props) {
    super(props);
    this.switchItem = ({ idx }) => {
      if (this.props.items && idx !== void 0) {
        this.setState({
          activeItemIdx: idx
        });
      }
    };
    this.state = {
      activeItemIdx: 0
    };
  }
  render() {
    const { items } = this.props;
    if (!items || !items.length) {
      return null;
    }
    const Wrapper3 = ({ children }) => this.props.label ? /* @__PURE__ */ jsxs51(DropdownWrapper, { children: [
      /* @__PURE__ */ jsx64(DropdownLabel, { children: this.props.label }),
      children
    ] }) : children;
    return /* @__PURE__ */ jsxs51(Fragment19, { children: [
      /* @__PURE__ */ jsx64(Wrapper3, { children: this.props.renderDropdown({
        value: this.props.options[this.state.activeItemIdx].value,
        options: this.props.options,
        onChange: this.switchItem,
        ariaLabel: this.props.label || "Callback"
      }) }),
      this.props.children(items[this.state.activeItemIdx])
    ] });
  }
};
GenericChildrenSwitcher = __decorateClass([
  observer16
], GenericChildrenSwitcher);

// src/components/CallbackSamples/CallbackReqSamples.tsx
import React57 from "react";

// src/components/PayloadSamples/PayloadSamples.tsx
import { observer as observer17 } from "mobx-react";
import React56 from "react";
import { jsx as jsx65 } from "react/jsx-runtime";
var PayloadSamples = class extends React56.Component {
  constructor() {
    super(...arguments);
    this.renderDropdown = (props) => {
      return /* @__PURE__ */ jsx65(
        DropdownOrLabel,
        {
          Label: MimeLabel2,
          Dropdown: InvertedSimpleDropdown,
          ...props,
          variant: "dark"
        }
      );
    };
  }
  render() {
    const mimeContent = this.props.content;
    if (mimeContent === void 0) {
      return null;
    }
    return /* @__PURE__ */ jsx65(
      MediaTypesSwitch,
      {
        content: mimeContent,
        renderDropdown: this.renderDropdown,
        withLabel: false,
        children: (mediaType) => /* @__PURE__ */ jsx65(
          MediaTypeSamples,
          {
            mediaType,
            renderDropdown: this.renderDropdown
          },
          "samples"
        )
      }
    );
  }
};
PayloadSamples = __decorateClass([
  observer17
], PayloadSamples);

// src/components/CallbackSamples/CallbackReqSamples.tsx
import { jsx as jsx66 } from "react/jsx-runtime";
var CallbackPayloadSample = class extends React57.Component {
  render() {
    const payloadSample = this.props.callback.codeSamples.find(
      (sample2) => isPayloadSample(sample2)
    );
    if (!payloadSample) {
      return null;
    }
    return /* @__PURE__ */ jsx66(PayloadSampleWrapper, { children: /* @__PURE__ */ jsx66(PayloadSamples, { content: payloadSample.requestBodyContent }) });
  }
};
var PayloadSampleWrapper = styled_components_default.div`
  margin-top: 15px;
`;

// src/components/CallbackSamples/CallbackSamples.tsx
import { jsx as jsx67, jsxs as jsxs52 } from "react/jsx-runtime";
var CallbackSamples = class extends React58.Component {
  constructor() {
    super(...arguments);
    this.renderDropdown = (props) => {
      return /* @__PURE__ */ jsx67(
        DropdownOrLabel,
        {
          Label: MimeLabel2,
          Dropdown: InvertedSimpleDropdown,
          ...props,
          variant: "dark"
        }
      );
    };
  }
  render() {
    const { callbacks } = this.props;
    if (!callbacks || callbacks.length === 0) {
      return null;
    }
    const operations = callbacks.map((callback) => callback.operations.map((operation) => operation)).reduce((a, b) => a.concat(b), []);
    const hasSamples = operations.some((operation) => operation.codeSamples.length > 0);
    if (!hasSamples) {
      return null;
    }
    const dropdownOptions = operations.map((callback, idx) => {
      return {
        value: `${callback.httpVerb.toUpperCase()}: ${callback.name}`,
        idx
      };
    });
    return /* @__PURE__ */ jsxs52("div", { children: [
      /* @__PURE__ */ jsx67(RightPanelHeader, { children: " Callback payload samples " }),
      /* @__PURE__ */ jsx67(SamplesWrapper2, { children: /* @__PURE__ */ jsx67(
        GenericChildrenSwitcher,
        {
          items: operations,
          renderDropdown: this.renderDropdown,
          label: "Callback",
          options: dropdownOptions,
          children: (callback) => /* @__PURE__ */ jsx67(
            CallbackPayloadSample,
            {
              callback,
              renderDropdown: this.renderDropdown
            },
            "callbackPayloadSample"
          )
        }
      ) })
    ] });
  }
};
CallbackSamples.contextType = OptionsContext;
CallbackSamples = __decorateClass([
  observer18
], CallbackSamples);
var SamplesWrapper2 = styled_components_default.div`
  background: ${({ theme: theme2 }) => theme2.codeBlock.backgroundColor};
  padding: ${(props) => props.theme.spacing.unit * 4}px;
`;

// src/components/RequestSamples/RequestSamples.tsx
import { observer as observer19 } from "mobx-react";
import React60 from "react";

// src/common-elements/Expandable.tsx
import React59 from "react";
import { useCallback as useCallback5, useState as useState7 } from "react";
import { jsx as jsx68, jsxs as jsxs53 } from "react/jsx-runtime";
var Header2 = styled_components_default.div`
  position: relative;
  z-index: 1;
  align-items: center;
  justify-content: space-between;
  white-space: nowrap;
  cursor: pointer;
  border-radius: ${({ expanded }) => expanded ? "8px 8px 0 0" : "8px"};
  pointer-events: auto;

  padding: 10px 20px;
  line-height: 30px;
  background-color: rgb(50, 63, 75);
  min-height: 50px;
`;
var SectionHeaderText2 = styled_components_default.div`
  display: inline-flex;
  align-items: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  > span {
    line-height: 1;
    margin-right: 4px;
    font-weight: 700;
    color: rgb(245, 247, 250);
  }
`;
var expand2 = keyframes`
  0% {
    max-height: 0;
  }
  100% {
    max-height: unset;
  }
`;
var collapse2 = keyframes`
  0% {
    max-height: unset;
  }
  100% {
    max-height: 0;
  }
`;
var SectionContent2 = styled_components_default.div`
  animation: 0.2s ease ${collapse2};
  visibility: hidden;
  border-radius: 0 0 8px 8px;
  background-color: rgb(82, 96, 109);
  color: rgb(245, 247, 250);
  max-height: 0;
  overflow: hidden;

  ${({ expanded }) => expanded && css`
      padding: 10px 20px 20px;
      animation: 0.2s ease ${expand2};
      visibility: visible;
      max-height: unset;
    `}
`;
var Expandable = ({ defaultExpanded, title, children }) => {
  const [expanded, setExpanded] = useState7(defaultExpanded || false);
  const toggle = useCallback5(() => setExpanded((old) => !old), []);
  return /* @__PURE__ */ jsxs53("div", { children: [
    /* @__PURE__ */ jsx68(Header2, { onClick: toggle, expanded, children: /* @__PURE__ */ jsxs53(SectionHeaderText2, { children: [
      /* @__PURE__ */ jsx68("span", { children: title }),
      /* @__PURE__ */ jsx68(ShelfIcon, { size: "14px", color: "white", direction: expanded ? "down" : "right" })
    ] }) }),
    /* @__PURE__ */ jsx68(SectionContent2, { expanded, children })
  ] });
};
var Expandable_default = React59.memo(Expandable);

// src/components/RequestSamples/RequestSamples.tsx
import { jsx as jsx69, jsxs as jsxs54 } from "react/jsx-runtime";
var RequestSamples = class extends React60.Component {
  render() {
    const { operation } = this.props;
    const samples = operation.codeSamples;
    const hasSamples = samples.length > 0;
    const hideTabList = samples.length === 1 ? this.context.hideSingleRequestSampleTab : false;
    return hasSamples && /* @__PURE__ */ jsx69(Expandable_default, { defaultExpanded: true, title: l("requestSamples"), children: /* @__PURE__ */ jsx69("div", { children: /* @__PURE__ */ jsxs54(Tabs, { defaultIndex: 0, children: [
      /* @__PURE__ */ jsx69(TabList, { hidden: hideTabList, children: samples.map((sample2) => /* @__PURE__ */ jsx69(Tab, { children: sample2.label !== void 0 ? sample2.label : sample2.lang }, sample2.lang + "_" + (sample2.label || ""))) }),
      samples.map((sample2) => /* @__PURE__ */ jsx69(TabPanel, { children: isPayloadSample(sample2) ? /* @__PURE__ */ jsx69("div", { children: /* @__PURE__ */ jsx69(PayloadSamples, { content: sample2.requestBodyContent }) }) : /* @__PURE__ */ jsx69(SourceCodeWithCopy, { lang: sample2.lang, source: sample2.source }) }, sample2.lang + "_" + (sample2.label || "")))
    ] }) }) }) || null;
  }
};
RequestSamples.contextType = OptionsContext;
RequestSamples = __decorateClass([
  observer19
], RequestSamples);

// src/components/ResponseSamples/ResponseSamples.tsx
import { observer as observer20 } from "mobx-react";
import React61 from "react";
import { jsx as jsx70, jsxs as jsxs55 } from "react/jsx-runtime";
var ResponseSamples = class extends React61.Component {
  render() {
    const { operation } = this.props;
    const responses = operation.responses.filter((response) => {
      return response.content && response.content.hasSample;
    });
    return responses.length > 0 && /* @__PURE__ */ jsx70(Expandable_default, { defaultExpanded: true, title: l("responseSamples"), children: /* @__PURE__ */ jsx70("div", { children: /* @__PURE__ */ jsxs55(Tabs, { defaultIndex: 0, children: [
      /* @__PURE__ */ jsx70(TabList, { children: responses.map((response) => /* @__PURE__ */ jsx70(Tab, { className: "tab-" + response.type, children: response.code }, response.code)) }),
      responses.map((response) => /* @__PURE__ */ jsx70(TabPanel, { children: /* @__PURE__ */ jsx70("div", { children: /* @__PURE__ */ jsx70(PayloadSamples, { content: response.content }) }) }, response.code))
    ] }) }) }) || null;
  }
};
ResponseSamples = __decorateClass([
  observer20
], ResponseSamples);

// src/components/Operation/Operation.tsx
import { jsx as jsx71, jsxs as jsxs56 } from "react/jsx-runtime";
var Description2 = styled_components_default.div`
  margin-bottom: ${({ theme: theme2 }) => theme2.spacing.unit * 6}px;
`;
var Operation = observer21(({ operation }) => {
  const {
    name: summary,
    description,
    deprecated,
    externalDocs,
    isWebhook,
    httpVerb,
    badges
  } = operation;
  const hasDescription = !!(description || externalDocs);
  const { showWebhookVerb } = React62.useContext(OptionsContext);
  const badgesBefore = badges.filter(({ position }) => position === "before");
  const badgesAfter = badges.filter(({ position }) => position === "after");
  return /* @__PURE__ */ jsx71(OptionsContext.Consumer, { children: (options2) => /* @__PURE__ */ jsxs56(Row, { ...{ [SECTION_ATTR]: operation.operationHash }, id: operation.operationHash, children: [
    /* @__PURE__ */ jsxs56(MiddlePanel, { children: [
      /* @__PURE__ */ jsxs56(H2, { children: [
        /* @__PURE__ */ jsx71(ShareLink, { to: operation.id }),
        badgesBefore.map(({ name: name2, color }) => /* @__PURE__ */ jsx71(Badge, { type: "primary", color, children: name2 }, name2)),
        summary,
        " ",
        deprecated && /* @__PURE__ */ jsx71(Badge, { type: "warning", children: " Deprecated " }),
        isWebhook && /* @__PURE__ */ jsxs56(Badge, { type: "primary", children: [
          " ",
          "Webhook ",
          showWebhookVerb && httpVerb && "| " + httpVerb.toUpperCase()
        ] }),
        badgesAfter.map(({ name: name2, color }) => /* @__PURE__ */ jsx71(Badge, { type: "primary", color, children: name2 }, name2))
      ] }),
      options2.pathInMiddlePanel && !isWebhook && /* @__PURE__ */ jsx71(Endpoint, { operation, inverted: true }),
      hasDescription && /* @__PURE__ */ jsxs56(Description2, { children: [
        description !== void 0 && /* @__PURE__ */ jsx71(Markdown, { source: description }),
        externalDocs && /* @__PURE__ */ jsx71(ExternalDocumentation, { externalDocs })
      ] }),
      /* @__PURE__ */ jsx71(Extensions, { extensions: operation.extensions }),
      /* @__PURE__ */ jsx71(SecurityRequirements, { securities: operation.security }),
      /* @__PURE__ */ jsx71(Parameters, { parameters: operation.parameters, body: operation.requestBody }),
      /* @__PURE__ */ jsx71(ResponsesList, { responses: operation.responses }),
      /* @__PURE__ */ jsx71(CallbacksList, { callbacks: operation.callbacks })
    ] }),
    /* @__PURE__ */ jsxs56(DarkRightPanel, { children: [
      !options2.pathInMiddlePanel && !isWebhook && /* @__PURE__ */ jsx71(Endpoint, { operation }),
      /* @__PURE__ */ jsx71(RequestSamples, { operation }),
      /* @__PURE__ */ jsx71(ResponseSamples, { operation }),
      /* @__PURE__ */ jsx71(CallbackSamples, { callbacks: operation.callbacks })
    ] })
  ] }) });
});

// src/components/ContentItems/ContentItems.tsx
import { Fragment as Fragment20, jsx as jsx72, jsxs as jsxs57 } from "react/jsx-runtime";
var ContentItems = class extends React63.Component {
  render() {
    const items = this.props.items;
    if (items.length === 0) {
      return null;
    }
    return items.map((item) => {
      return /* @__PURE__ */ jsx72(ContentItem, { item }, item.id);
    });
  }
};
ContentItems = __decorateClass([
  observer22
], ContentItems);
var ContentItem = class extends React63.Component {
  render() {
    const item = this.props.item;
    let content2;
    const { type } = item;
    switch (type) {
      case "group":
        content2 = null;
        break;
      case "tag":
      case "section":
        content2 = /* @__PURE__ */ jsx72(SectionItem, { ...this.props });
        break;
      case "operation":
        content2 = /* @__PURE__ */ jsx72(OperationItem, { item });
        break;
      default:
        content2 = /* @__PURE__ */ jsx72(SectionItem, { ...this.props });
    }
    return /* @__PURE__ */ jsxs57(Fragment20, { children: [
      content2 && /* @__PURE__ */ jsx72(Section, { id: item.id, $underlined: item.type === "operation", children: content2 }),
      item.items && /* @__PURE__ */ jsx72(ContentItems, { items: item.items })
    ] });
  }
};
ContentItem = __decorateClass([
  observer22
], ContentItem);
var middlePanelWrap = (component) => /* @__PURE__ */ jsx72(MiddlePanel, { $compact: true, children: component });
var SectionItem = class extends React63.Component {
  render() {
    const { name: name2, description, externalDocs, level: level2 } = this.props.item;
    const Header3 = level2 === 2 ? H3 : H2;
    return /* @__PURE__ */ jsxs57(Fragment20, { children: [
      /* @__PURE__ */ jsx72(Row, { children: /* @__PURE__ */ jsx72(MiddlePanel, { $compact: false, children: /* @__PURE__ */ jsxs57(Header3, { children: [
        /* @__PURE__ */ jsx72(ShareLink, { to: this.props.item.id }),
        name2
      ] }) }) }),
      /* @__PURE__ */ jsx72(
        AdvancedMarkdown,
        {
          parentId: this.props.item.id,
          source: description || "",
          htmlWrap: middlePanelWrap
        }
      ),
      externalDocs && /* @__PURE__ */ jsx72(Row, { children: /* @__PURE__ */ jsx72(MiddlePanel, { children: /* @__PURE__ */ jsx72(ExternalDocumentation, { externalDocs }) }) })
    ] });
  }
};
SectionItem = __decorateClass([
  observer22
], SectionItem);
var OperationItem = class extends React63.Component {
  render() {
    return /* @__PURE__ */ jsx72(Operation, { operation: this.props.item });
  }
};
OperationItem = __decorateClass([
  observer22
], OperationItem);

// src/components/SideMenu/SideMenu.tsx
import { observer as observer25 } from "mobx-react";
import React66 from "react";

// src/components/SideMenu/MenuItems.tsx
import { observer as observer24 } from "mobx-react";
import React65 from "react";

// src/components/SideMenu/MenuItem.tsx
import { observer as observer23 } from "mobx-react";
import React64 from "react";
import { jsx as jsx73, jsxs as jsxs58 } from "react/jsx-runtime";
var MenuItem = class extends React64.Component {
  constructor() {
    super(...arguments);
    this.ref = React64.createRef();
    this.activate = (evt) => {
      this.props.onActivate(this.props.item);
      evt.stopPropagation();
    };
  }
  componentDidMount() {
    this.scrollIntoViewIfActive();
  }
  componentDidUpdate() {
    this.scrollIntoViewIfActive();
  }
  scrollIntoViewIfActive() {
    if (this.props.item.active && this.ref.current) {
      scrollIntoViewIfNeeded(this.ref.current);
    }
  }
  render() {
    const { item, withoutChildren } = this.props;
    return /* @__PURE__ */ jsxs58(
      MenuItemLi,
      {
        tabIndex: 0,
        onClick: this.activate,
        onKeyDown: (evt) => {
          if (evt.key === "Enter" || evt.key === " ") {
            this.props.onActivate(this.props.item);
            evt.stopPropagation();
          }
        },
        depth: item.depth,
        "data-item-id": item.id,
        role: "menuitem",
        "aria-label": item.sidebarLabel,
        "aria-expanded": item.expanded,
        children: [
          item.type === "operation" ? /* @__PURE__ */ jsx73(OperationMenuItemContent, { ...this.props, item }) : /* @__PURE__ */ jsxs58(MenuItemLabel, { $depth: item.depth, $active: item.active, $type: item.type, ref: this.ref, children: [
            item.type === "schema" && /* @__PURE__ */ jsx73(OperationBadge, { type: "schema", children: "schema" }),
            /* @__PURE__ */ jsxs58(MenuItemTitle, { width: "calc(100% - 38px)", title: item.sidebarLabel, children: [
              item.sidebarLabel,
              this.props.children
            ] }),
            item.depth > 0 && item.items.length > 0 && /* @__PURE__ */ jsx73(ShelfIcon, { float: "right", direction: item.expanded ? "down" : "right" }) || null
          ] }),
          !withoutChildren && item.items && item.items.length > 0 && /* @__PURE__ */ jsx73(
            MenuItems,
            {
              expanded: item.expanded,
              items: item.items,
              onActivate: this.props.onActivate
            }
          )
        ]
      }
    );
  }
};
MenuItem = __decorateClass([
  observer23
], MenuItem);
var OperationMenuItemContent = observer23((props) => {
  var _a2;
  const { item } = props;
  const ref = React64.createRef();
  const { showWebhookVerb } = React64.useContext(OptionsContext);
  React64.useEffect(() => {
    if (props.item.active && ref.current) {
      scrollIntoViewIfNeeded(ref.current);
    }
  }, [props.item.active, ref]);
  return /* @__PURE__ */ jsxs58(
    MenuItemLabel,
    {
      $depth: item.depth,
      $active: item.active,
      $deprecated: item.deprecated,
      ref,
      children: [
        item.badges && ((_a2 = item.badges) == null ? void 0 : _a2.map(({ name: name2, color }) => /* @__PURE__ */ jsx73(OperationBadge, { type: "badge", color, children: name2 }, name2))),
        item.isWebhook ? /* @__PURE__ */ jsx73(OperationBadge, { type: "hook", children: showWebhookVerb ? item.httpVerb : l("webhook") }) : /* @__PURE__ */ jsx73(OperationBadge, { type: item.httpVerb, children: shortenHTTPVerb(item.httpVerb) }),
        /* @__PURE__ */ jsxs58(MenuItemTitle, { tabIndex: 0, width: "calc(100% - 38px)", children: [
          item.sidebarLabel,
          props.children
        ] })
      ]
    }
  );
});

// src/components/SideMenu/MenuItems.tsx
import { jsx as jsx74 } from "react/jsx-runtime";
var MenuItems = class extends React65.Component {
  render() {
    const { items, root, className } = this.props;
    const expanded = this.props.expanded == null ? true : this.props.expanded;
    return /* @__PURE__ */ jsx74(
      MenuItemUl,
      {
        className,
        style: this.props.style,
        $expanded: expanded,
        ...root ? { role: "menu" } : {},
        children: items.map((item, idx) => /* @__PURE__ */ jsx74(MenuItem, { item, onActivate: this.props.onActivate }, idx))
      }
    );
  }
};
MenuItems = __decorateClass([
  observer24
], MenuItems);

// src/components/SideMenu/Logo.tsx
import { useEffect as useEffect4, useState as useState8 } from "react";
import { jsx as jsx75 } from "react/jsx-runtime";
function RedoclyLogo() {
  const [isDisplay, setDisplay] = useState8(false);
  useEffect4(() => {
    setDisplay(true);
  }, []);
  return isDisplay ? /* @__PURE__ */ jsx75(
    "img",
    {
      alt: "redocly logo",
      onError: () => setDisplay(false),
      src: "https://cdn.redoc.ly/redoc/logo-mini.svg"
    }
  ) : null;
}

// src/components/SideMenu/SideMenu.tsx
import { jsx as jsx76, jsxs as jsxs59 } from "react/jsx-runtime";
var SideMenu = class extends React66.Component {
  constructor() {
    super(...arguments);
    this.activate = (item) => {
      if (item && item.active && this.context.menuToggle) {
        return item.expanded ? item.collapse() : item.expand();
      }
      this.props.menu.activateAndScroll(item, true);
      setTimeout(() => {
        if (this._updateScroll) {
          this._updateScroll();
        }
      });
    };
    this.saveScrollUpdate = (upd) => {
      this._updateScroll = upd;
    };
  }
  render() {
    const store2 = this.props.menu;
    return /* @__PURE__ */ jsxs59(
      PerfectScrollbarWrap,
      {
        updateFn: this.saveScrollUpdate,
        className: this.props.className,
        options: {
          wheelPropagation: false
        },
        children: [
          /* @__PURE__ */ jsx76(MenuItems, { items: store2.items, onActivate: this.activate, root: true }),
          /* @__PURE__ */ jsx76(RedocAttribution, { children: /* @__PURE__ */ jsxs59("a", { target: "_blank", rel: "noopener noreferrer", href: "https://redocly.com/redoc/", children: [
            /* @__PURE__ */ jsx76(RedoclyLogo, {}),
            "API docs by Redocly"
          ] }) })
        ]
      }
    );
  }
};
SideMenu.contextType = OptionsContext;
SideMenu = __decorateClass([
  observer25
], SideMenu);

// src/components/StickySidebar/StickyResponsiveSidebar.tsx
import { observer as observer26 } from "mobx-react";
import React67 from "react";

// src/components/StickySidebar/ChevronSvg.tsx
import { jsx as jsx77, jsxs as jsxs60 } from "react/jsx-runtime";
var AnimatedChevronButton = ({ open }) => {
  const iconOffset = open ? 8 : -4;
  return /* @__PURE__ */ jsxs60(ChevronContainer, { children: [
    /* @__PURE__ */ jsx77(
      ChevronSvg,
      {
        size: 15,
        style: {
          transform: `translate(2px, ${iconOffset}px) rotate(180deg)`,
          transition: "transform 0.2s ease"
        }
      }
    ),
    /* @__PURE__ */ jsx77(
      ChevronSvg,
      {
        size: 15,
        style: {
          transform: `translate(2px, ${0 - iconOffset}px)`,
          transition: "transform 0.2s ease"
        }
      }
    )
  ] });
};
var ChevronSvg = ({ size = 10, className = "", style }) => /* @__PURE__ */ jsx77(
  "svg",
  {
    className,
    style: style || {},
    viewBox: "0 0 926.23699 573.74994",
    version: "1.1",
    x: "0px",
    y: "0px",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx77("g", { transform: "translate(904.92214,-879.1482)", children: /* @__PURE__ */ jsx77(
      "path",
      {
        d: `
          m -673.67664,1221.6502 -231.2455,-231.24803 55.6165,
          -55.627 c 30.5891,-30.59485 56.1806,-55.627 56.8701,-55.627 0.6894,
          0 79.8637,78.60862 175.9427,174.68583 l 174.6892,174.6858 174.6892,
          -174.6858 c 96.079,-96.07721 175.253196,-174.68583 175.942696,
          -174.68583 0.6895,0 26.281,25.03215 56.8701,
          55.627 l 55.6165,55.627 -231.245496,231.24803 c -127.185,127.1864
          -231.5279,231.248 -231.873,231.248 -0.3451,0 -104.688,
          -104.0616 -231.873,-231.248 z
        `,
        fill: "currentColor"
      }
    ) })
  }
);
var ChevronContainer = styled_components_default.div`
  user-select: none;
  width: 20px;
  height: 20px;
  align-self: center;
  display: flex;
  flex-direction: column;
  color: ${(props) => props.theme.colors.primary.main};
`;

// src/components/StickySidebar/StickyResponsiveSidebar.tsx
import { Fragment as Fragment21, jsx as jsx78, jsxs as jsxs61 } from "react/jsx-runtime";
async function loadStickyfill() {
  if (IS_BROWSER) {
    try {
      const module = await Promise.resolve().then(() => __toESM(require_stickyfill(), 1));
      return module.default || module;
    } catch (e) {
      console.error("Failed to load Stickyfill:", e);
      return null;
    }
  }
  return null;
}
var StyledStickySidebar = styled_components_default.div`
  width: ${(props) => props.theme.sidebar.width};
  background-color: ${(props) => props.theme.sidebar.backgroundColor};
  overflow: hidden;
  display: flex;
  flex-direction: column;

  backface-visibility: hidden;
  /* contain: strict; TODO: breaks layout since Chrome 80*/

  height: 100vh;
  position: sticky;
  position: -webkit-sticky;
  top: 0;

  ${media.lessThan("small")`
    position: fixed;
    z-index: 20;
    width: 100%;
    background: ${({ theme: theme2 }) => theme2.sidebar.backgroundColor};
    display: ${(props) => props.$open ? "flex" : "none"};
  `};

  @media print {
    display: none;
  }
`;
var FloatingButton = styled_components_default.div`
  outline: none;
  user-select: none;
  background-color: ${({ theme: theme2 }) => theme2.fab.backgroundColor};
  color: ${(props) => props.theme.colors.primary.main};
  display: none;
  cursor: pointer;
  position: fixed;
  right: 20px;
  z-index: 100;
  border-radius: 50%;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
  ${media.lessThan("small")`
    display: flex;
  `};

  bottom: 44px;

  width: 60px;
  height: 60px;
  padding: 0 20px;
  svg {
    color: ${({ theme: theme2 }) => theme2.fab.color};
  }

  @media print {
    display: none;
  }
`;
var StickyResponsiveSidebar = class extends React67.Component {
  constructor() {
    super(...arguments);
    this.state = { offsetTop: "0px" };
    this.stickyfillInstance = null;
    this.toggleNavMenu = () => {
      this.props.menu.toggleSidebar();
    };
  }
  async componentDidMount() {
    if (IS_BROWSER) {
      const Stickyfill = await loadStickyfill();
      if (Stickyfill) {
        this.stickyfillInstance = Stickyfill();
        this.stickyfillInstance.add(this.stickyElement);
      }
    }
    this.setState({
      offsetTop: this.getScrollYOffset(this.context)
    });
  }
  componentWillUnmount() {
    if (this.stickyfillInstance) {
      this.stickyfillInstance.remove(this.stickyElement);
    }
  }
  getScrollYOffset(options2) {
    let top2;
    if (this.props.scrollYOffset !== void 0) {
      top2 = RedocNormalizedOptions.normalizeScrollYOffset(this.props.scrollYOffset)();
    } else {
      top2 = options2.scrollYOffset();
    }
    return top2 + "px";
  }
  render() {
    const open = this.props.menu.sideBarOpened;
    const top2 = this.state.offsetTop;
    return /* @__PURE__ */ jsxs61(Fragment21, { children: [
      /* @__PURE__ */ jsx78(
        StyledStickySidebar,
        {
          $open: open,
          className: this.props.className,
          style: {
            top: top2,
            height: `calc(100vh - ${top2})`
          },
          ref: (el) => {
            this.stickyElement = el;
          },
          children: this.props.children
        }
      ),
      !this.context.hideFab && /* @__PURE__ */ jsx78(FloatingButton, { onClick: this.toggleNavMenu, children: /* @__PURE__ */ jsx78(AnimatedChevronButton, { open }) })
    ] });
  }
};
StickyResponsiveSidebar.contextType = OptionsContext;
StickyResponsiveSidebar = __decorateClass([
  observer26
], StickyResponsiveSidebar);

// src/components/Redoc/styled.elements.tsx
var RedocWrap = styled_components_default.div`
  ${({ theme: theme2 }) => `
  font-family: ${theme2.typography.fontFamily};
  font-size: ${theme2.typography.fontSize};
  font-weight: ${theme2.typography.fontWeightRegular};
  line-height: ${theme2.typography.lineHeight};
  color: ${theme2.colors.text.primary};
  display: flex;
  position: relative;
  text-align: left;

  -webkit-font-smoothing: ${theme2.typography.smoothing};
  font-smoothing: ${theme2.typography.smoothing};
  ${theme2.typography.optimizeSpeed && "text-rendering: optimizeSpeed !important" || ""};

  tap-highlight-color: rgba(0, 0, 0, 0);
  text-size-adjust: 100%;

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
  }
`};
`;
var ApiContentWrap = styled_components_default.div`
  z-index: 1;
  position: relative;
  overflow: hidden;
  width: calc(100% - ${(props) => props.theme.sidebar.width});
  ${media.lessThan("small", true)`
    width: 100%;
  `};

  contain: layout;
`;
var BackgroundStub = styled_components_default.div`
  background: ${({ theme: theme2 }) => theme2.rightPanel.backgroundColor};
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: ${({ theme: theme2 }) => {
  if (theme2.rightPanel.width.endsWith("%")) {
    const percents = parseInt(theme2.rightPanel.width, 10);
    return `calc((100% - ${theme2.sidebar.width}) * ${percents / 100})`;
  } else {
    return theme2.rightPanel.width;
  }
}};
  ${media.lessThan("medium", true)`
    display: none;
  `};
`;

// src/components/SearchBox/SearchBox.tsx
import React68 from "react";
var import_decko3 = __toESM(require_decko(), 1);

// src/components/SearchBox/styled.elements.tsx
var import_polished8 = __toESM(require_polished_cjs(), 1);
import { jsx as jsx79 } from "react/jsx-runtime";
var SearchWrap = styled_components_default.div`
  padding: 5px 0;
`;
var SearchInput = styled_components_default.input.attrs(() => ({
  className: "search-input"
}))`
  width: calc(100% - ${(props) => props.theme.spacing.unit * 8}px);
  box-sizing: border-box;
  margin: 0 ${(props) => props.theme.spacing.unit * 4}px;
  padding: 5px ${(props) => props.theme.spacing.unit * 2}px 5px
    ${(props) => props.theme.spacing.unit * 4}px;
  border: 0;
  border-bottom: 1px solid
    ${({ theme: theme2 }) => ((0, import_polished8.getLuminance)(theme2.sidebar.backgroundColor) > 0.5 ? import_polished8.darken : import_polished8.lighten)(
  0.1,
  theme2.sidebar.backgroundColor
)};
  font-family: ${({ theme: theme2 }) => theme2.typography.fontFamily};
  font-weight: bold;
  font-size: 13px;
  color: ${(props) => props.theme.sidebar.textColor};
  background-color: transparent;
  outline: none;
`;
var SearchIcon = styled_components_default((props) => /* @__PURE__ */ jsx79(
  "svg",
  {
    className: props.className,
    version: "1.1",
    viewBox: "0 0 1000 1000",
    x: "0px",
    xmlns: "http://www.w3.org/2000/svg",
    y: "0px",
    children: /* @__PURE__ */ jsx79("path", { d: "M968.2,849.4L667.3,549c83.9-136.5,66.7-317.4-51.7-435.6C477.1-25,252.5-25,113.9,113.4c-138.5,138.3-138.5,362.6,0,501C219.2,730.1,413.2,743,547.6,666.5l301.9,301.4c43.6,43.6,76.9,14.9,104.2-12.4C981,928.3,1011.8,893,968.2,849.4z M524.5,522c-88.9,88.7-233,88.7-321.8,0c-88.9-88.7-88.9-232.6,0-321.3c88.9-88.7,233-88.7,321.8,0C613.4,289.4,613.4,433.3,524.5,522z" })
  }
)).attrs({
  className: "search-icon"
})`
  position: absolute;
  left: ${(props) => props.theme.spacing.unit * 4}px;
  height: 1.8em;
  width: 0.9em;

  path {
    fill: ${(props) => props.theme.sidebar.textColor};
  }
`;
var SearchResultsBox = styled_components_default.div`
  padding: ${(props) => props.theme.spacing.unit}px 0;
  background-color: ${({ theme: theme2 }) => (0, import_polished8.darken)(0.05, theme2.sidebar.backgroundColor)}};
  color: ${(props) => props.theme.sidebar.textColor};
  min-height: 150px;
  max-height: 250px;
  border-top: ${({ theme: theme2 }) => (0, import_polished8.darken)(0.1, theme2.sidebar.backgroundColor)}};
  border-bottom: ${({ theme: theme2 }) => (0, import_polished8.darken)(0.1, theme2.sidebar.backgroundColor)}};
  margin-top: 10px;
  line-height: 1.4;
  font-size: 0.9em;

  li {
    background-color: inherit;
  }

  ${MenuItemLabel} {
    padding-top: 6px;
    padding-bottom: 6px;

    &:hover,
    &.active {
      background-color: ${({ theme: theme2 }) => (0, import_polished8.darken)(0.1, theme2.sidebar.backgroundColor)};
    }

    > svg {
      display: none;
    }
  }
`;
var ClearIcon = styled_components_default.i`
  position: absolute;
  display: inline-block;
  width: ${(props) => props.theme.spacing.unit * 2}px;
  text-align: center;
  right: ${(props) => props.theme.spacing.unit * 4}px;
  line-height: 2em;
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  font-style: normal;
  color: '#666';
`;

// src/components/SearchBox/SearchBox.tsx
import { jsx as jsx80, jsxs as jsxs62 } from "react/jsx-runtime";
var SearchBox = class extends React68.PureComponent {
  constructor(props) {
    super(props);
    this.activeItemRef = null;
    this.clear = () => {
      this.setState({
        results: [],
        noResults: false,
        term: "",
        activeItemIdx: -1
      });
      this.props.marker.unmark();
    };
    this.handleKeyDown = (event) => {
      if (event.keyCode === 27) {
        this.clear();
      }
      if (event.keyCode === 40) {
        this.setState({
          activeItemIdx: Math.min(this.state.activeItemIdx + 1, this.state.results.length - 1)
        });
        event.preventDefault();
      }
      if (event.keyCode === 38) {
        this.setState({
          activeItemIdx: Math.max(0, this.state.activeItemIdx - 1)
        });
        event.preventDefault();
      }
      if (event.keyCode === 13) {
        const activeResult = this.state.results[this.state.activeItemIdx];
        if (activeResult) {
          const item = this.props.getItemById(activeResult.meta);
          if (item) {
            this.props.onActivate(item);
          }
        }
      }
    };
    this.search = (event) => {
      const { minCharacterLengthToInitSearch } = this.context;
      const q = event.target.value;
      if (q.length < minCharacterLengthToInitSearch) {
        this.clearResults(q);
        return;
      }
      this.setState(
        {
          term: q
        },
        () => this.searchCallback(this.state.term)
      );
    };
    this.state = {
      results: [],
      noResults: false,
      term: "",
      activeItemIdx: -1
    };
  }
  clearResults(term) {
    this.setState({
      results: [],
      noResults: false,
      term
    });
    this.props.marker.unmark();
  }
  setResults(results, term) {
    this.setState({
      results,
      noResults: results.length === 0
    });
    this.props.marker.mark(term);
  }
  searchCallback(searchTerm) {
    this.props.search.search(searchTerm).then((res) => {
      this.setResults(res, searchTerm);
    });
  }
  render() {
    const { activeItemIdx } = this.state;
    const results = this.state.results.filter((res) => this.props.getItemById(res.meta)).map((res) => ({
      item: this.props.getItemById(res.meta),
      score: res.score
    })).sort((a, b) => b.score - a.score);
    return /* @__PURE__ */ jsxs62(SearchWrap, { role: "search", children: [
      this.state.term && /* @__PURE__ */ jsx80(ClearIcon, { onClick: this.clear, children: "\xD7" }),
      /* @__PURE__ */ jsx80(SearchIcon, {}),
      /* @__PURE__ */ jsx80(
        SearchInput,
        {
          value: this.state.term,
          onKeyDown: this.handleKeyDown,
          placeholder: "Search...",
          "aria-label": "Search",
          type: "text",
          onChange: this.search
        }
      ),
      results.length > 0 && /* @__PURE__ */ jsx80(
        PerfectScrollbarWrap,
        {
          options: {
            wheelPropagation: false
          },
          children: /* @__PURE__ */ jsx80(SearchResultsBox, { "data-role": "search:results", children: results.map((res, idx) => /* @__PURE__ */ jsx80(
            MenuItem,
            {
              item: Object.create(res.item, {
                active: {
                  value: idx === activeItemIdx
                }
              }),
              onActivate: this.props.onActivate,
              withoutChildren: true,
              "data-role": "search:result"
            },
            res.item.id
          )) })
        }
      ),
      this.state.term && this.state.noResults ? /* @__PURE__ */ jsx80(SearchResultsBox, { "data-role": "search:results", children: l("noResultsFound") }) : null
    ] });
  }
};
SearchBox.contextType = OptionsContext;
__decorateClass([
  import_decko3.bind,
  (0, import_decko3.debounce)(400)
], SearchBox.prototype, "searchCallback", 1);

// src/components/Redoc/Redoc.tsx
import { jsx as jsx81, jsxs as jsxs63 } from "react/jsx-runtime";
var Redoc = class extends React69.Component {
  componentDidMount() {
    this.props.store.onDidMount();
  }
  componentWillUnmount() {
    this.props.store.dispose();
  }
  render() {
    const {
      store: { spec, menu, options: options2, search: search2, marker }
    } = this.props;
    const store2 = this.props.store;
    return /* @__PURE__ */ jsx81(ThemeProvider, { theme: options2.theme, children: /* @__PURE__ */ jsx81(Provider, { value: store2, children: /* @__PURE__ */ jsx81(OptionsProvider, { value: options2, children: /* @__PURE__ */ jsxs63(RedocWrap, { className: "redoc-wrap", children: [
      /* @__PURE__ */ jsxs63(StickyResponsiveSidebar, { menu, className: "menu-content", children: [
        /* @__PURE__ */ jsx81(ApiLogo, { info: spec.info }),
        !options2.disableSearch && /* @__PURE__ */ jsx81(
          SearchBox,
          {
            search: search2,
            marker,
            getItemById: menu.getItemById,
            onActivate: menu.activateAndScroll
          }
        ) || null,
        /* @__PURE__ */ jsx81(SideMenu, { menu })
      ] }),
      /* @__PURE__ */ jsxs63(ApiContentWrap, { className: "api-content", children: [
        /* @__PURE__ */ jsx81(ApiInfo, { store: store2 }),
        /* @__PURE__ */ jsx81(ContentItems, { items: menu.items })
      ] })
    ] }) }) }) });
  }
};
Redoc.propTypes = {
  store: import_prop_types.default.instanceOf(AppStore).isRequired
};

// src/components/RedocStandalone.tsx
import { jsx as jsx82 } from "react/jsx-runtime";
var RedocStandalone = function(props) {
  const { spec, specUrl, options: options2 = {}, onLoaded } = props;
  const hideLoading = argValueToBoolean(options2.hideLoading, false);
  const normalizedOpts = new RedocNormalizedOptions(options2);
  if (normalizedOpts.nonce !== void 0) {
    try {
      __webpack_nonce__ = normalizedOpts.nonce;
    } catch {
    }
  }
  return /* @__PURE__ */ jsx82(ErrorBoundary, { children: /* @__PURE__ */ jsx82(
    StoreBuilder,
    {
      spec: spec ? { ...spec } : void 0,
      specUrl,
      options: options2,
      onLoaded,
      children: ({ loading, store: store2 }) => !loading ? /* @__PURE__ */ jsx82(Redoc, { store: store2 }) : hideLoading ? null : /* @__PURE__ */ jsx82(Loading, { color: normalizedOpts.theme.colors.primary.main })
    }
  ) });
};
export {
  AUTH_TYPES,
  ApiContentWrap,
  ApiInfo,
  ApiInfoModel,
  ApiLogo,
  AppStore,
  ArrayFieldContainer,
  ArrayItem,
  ArraySchema,
  BackgroundStub,
  BodyContent,
  COMPONENT_REGEXP,
  CallbackModel,
  ClipboardService,
  ContentItem,
  ContentItems,
  DeleteButton,
  DiscriminatorDropdown,
  Dropdown2 as Dropdown,
  DropdownLabel,
  DropdownOrLabel,
  DropdownWrapper,
  ErrorBoundary,
  Example,
  ExampleModel,
  ExternalExample,
  FieldModel,
  GROUP_DEPTH,
  GroupModel,
  HistoryService,
  IS_BROWSER,
  InvertedSimpleDropdown,
  JsonPointer,
  JsonViewer,
  LEGACY_REGEXP,
  Label2 as Label,
  Loading,
  MDX_COMPONENT_REGEXP,
  Markdown,
  MarkdownRenderer,
  MarkerService,
  MediaContentModel,
  MediaTypeModel,
  MediaTypesSwitch,
  MenuBuilder,
  MenuItem,
  MenuItemLabel,
  MenuItemLi,
  MenuItemTitle,
  MenuItemUl,
  MenuItems,
  MenuStore,
  MiddlePanel,
  MimeLabel2 as MimeLabel,
  NoSampleLabel,
  OLD_SECURITY_DEFINITIONS_JSX_NAME,
  ObjectSchema,
  OneOfButton2 as OneOfButton,
  OneOfSchema,
  OpenAPIParser,
  Operation,
  OperationBadge,
  OperationItem,
  OperationMenuItemContent,
  OperationModel,
  OptionsConsumer,
  OptionsContext,
  OptionsProvider,
  Parameters,
  PayloadSamples,
  Redoc,
  RedocAttribution,
  RedocNormalizedOptions,
  RedocStandalone,
  RedocWrap,
  RequestBodyModel,
  ResponseDetails,
  ResponseHeaders,
  ResponseModel,
  ResponseSamples,
  ResponseTitle,
  ResponseView,
  ResponsesList,
  RightPanel,
  Row,
  SCHEMA_DEFINITION_JSX_NAME,
  SECTION_ATTR,
  SECURITY_DEFINITIONS_JSX_NAME,
  SECURITY_SCHEMES_SECTION_PREFIX,
  Schema,
  SchemaDefinition,
  SchemaModel,
  ScrollService,
  SearchBox,
  SearchStore,
  Section,
  SectionItem,
  SecurityDefs,
  SecuritySchemeModel,
  SecuritySchemesModel,
  SideMenu,
  SideNavStyleEnum,
  SimpleDropdown,
  SourceCode,
  SourceCodeWithCopy,
  SpecStore,
  StickyResponsiveSidebar,
  StoreBuilder,
  Consumer as StoreConsumer,
  StoreContext,
  Provider as StoreProvider,
  StyledMarkdownBlock,
  ThemeProvider,
  Throttle,
  alphabeticallyByProp,
  appendToMdHeading,
  argValueToBoolean,
  buildComponentComment,
  concatRefStacks,
  convertSwagger2OpenAPI,
  createGlobalStyle,
  createStore,
  css,
  debugTime,
  debugTimeEnd,
  detectType,
  escapeHTMLAttrChars,
  expandDefaultServerVariables,
  extensionsHook,
  extractExtensions,
  flattenByProp,
  getBasePath,
  getContentWithLegacyExamples,
  getDefinitionName,
  getOperationSummary,
  getSerializedValue,
  getStatusCodeType,
  highlight,
  history,
  html2Str,
  humanizeConstraints,
  humanizeNumberRange,
  isAbsoluteUrl,
  isArray,
  isBoolean,
  isFormUrlEncoded,
  isJsonLike,
  isNamedDefinition,
  isNumeric,
  isObject,
  isOperationName,
  isPayloadSample,
  isPrimitiveType,
  isRedocExtension,
  isStatusCode,
  keyframes,
  langFromMime,
  loadAndBundleSpec,
  mapLang,
  mapValues,
  mapWithLast,
  media,
  memoize,
  menuItemDepth,
  mergeObjects,
  mergeParams,
  mergeSimilarMediaTypes,
  normalizeServers,
  parseURL,
  pluralizeType,
  pushRef,
  querySelector,
  removeQueryStringAndHash,
  resolveUrl,
  safeSlugify,
  scrollIntoViewIfNeeded,
  serializeParameterValue,
  serializeParameterValueWithMime,
  setSecuritySchemePrefix,
  shortenHTTPVerb,
  sortByField,
  sortByRequired,
  stripTrailingSlash,
  styled_components_default as styled,
  titleize,
  unescapeHTMLChars,
  urlFormEncodePayload,
  useStore
};
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

mark.js/dist/mark.js:
  (*!***************************************************
  * mark.js v8.11.1
  * https://markjs.io/
  * Copyright (c) 2014–2018, Julian Kühnel
  * Released under the MIT license https://git.io/vwTVl
  *****************************************************)

lunr/lunr.js:
  (**
   * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
   * Copyright (C) 2020 Oliver Nightingale
   * @license MIT
   *)
  (*!
   * lunr.utils
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.Set
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.tokenizer
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.Pipeline
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.Vector
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.stemmer
   * Copyright (C) 2020 Oliver Nightingale
   * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
   *)
  (*!
   * lunr.stopWordFilter
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.trimmer
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.TokenSet
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.Index
   * Copyright (C) 2020 Oliver Nightingale
   *)
  (*!
   * lunr.Builder
   * Copyright (C) 2020 Oliver Nightingale
   *)

perfect-scrollbar/dist/perfect-scrollbar.common.js:
  (*!
   * perfect-scrollbar v1.5.6
   * Copyright 2024 Hyunje Jun, MDBootstrap and Contributors
   * Licensed under MIT
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

stickyfill/index.js:
  (*!
   * Stickyfill -- `position: sticky` polyfill
   * v. 1.1.1 | https://github.com/wilddeer/stickyfill
   * Copyright Oleg Korsunsky | http://wd.dizaina.net/
   *
   * MIT License
   *)

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE *)
*/
//# sourceMappingURL=redoc.esm.mjs.map
